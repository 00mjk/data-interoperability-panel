<pre class="metadata">
Title: Proposal for an Interoperable Solid Ecosystem
Shortname: your-spec
Level: 1
Max ToC Depth: 2
Status: w3c/ED
Group: w3c
URL: http://example.com/url-this-spec-will-live-at
Editor: Justin Bingham
Editor: Eric Prud'hommeaux
Editor: Josh Collins
Markup Shorthands: markdown yes
Abstract:
  A proposal for a Solid ecosystem that supports data interoperability across
  applications while enabling secure collaboration and query using intuitive
  data boundaries without changing the fundamentals of Solid, presented in the
  form of an end-to-end use case.
</pre>

<!-- For bikeshed style overrides -->
<style>
table.permissions thead tr {
  font-size: 12px;
}

table.permissions tbody tr:nth-child(even) {
  background-color: lightgray;
  font-size: 10px;
}

table.permissions tbody td {
  font-size: 10px;
}

pre {
  font-size: .8em;
}

figcaption {
  text-align: left;
}
</style>

Problems and Goals {#problems-goals}
=====================

Solid affords us the opportunity to create a valuable and
powerful ecosystem where people and organizations retain control of their data,
but are also able to put it to work and use it to its full potential. The
fundamentals of Solid make this possible, but further definition of standard
methods and mechanisms must be established to make it practical, intuitive, and
secure.

<div class="assertion">

[Problem #1](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-1---disparate-applications-cannot-practically-interoperate-over-the-same-data-safely-and-effectively) -
    Disparate applications cannot practically interoperate over the same data
    safely and effectively.

* <b>[Goal](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-1---seamless-data-interoperability-across-disparate-applications) -
    Seamless data interoperability across disparate applications.</b>

[Problem #2](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-2---people-must-be-able-to-understand-what-data-they-have-to-effectively-use-it-or-share-it-safely) -
    People must be able to understand what data they have to effectively use it
    or share it safely.

* <b>[Goal](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-2---use-intuitive-data-boundaries-to-provide-human-to-machine-interoperability) -
    Use intuitive data boundaries to provide human to machine interoperability.</b>

[Problem #3](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-3---disparate-entities-using-different-applications-must-be-able-to-safely-and-effectively-interoperate-within-their-scope-of-authorization) -
    Disparate entities using different applications must be able to
    safely and effectively interoperate within their scope of authorization.

* <b>[Goal](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-3---secure-collaboration-over-intuitive-data-boundaries) -
    Secure collaboration over intuitive data boundaries.</b>

[Problem #4](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-4---people-shouldnt-need-to-think-about-how-to-physically-organize-their-data-to-use-solid) -
    People shouldn’t need to think about how to physically organize
    their data to use Solid.

* <b>[Goal](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-4---standard-and-flexible-organizing-model-for-data) -
    Standard and flexible organizing model for data.</b>

[Problem #5](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-5---when-data-is-stored-and-secure-it-should-be-queryable-using-any-mechanism-and-able-to-be-requested-in-different-representations) -
    When data is stored and secure, it should be queryable using any
    mechanism, and able to be requested in different representations.

* <b>[Goal](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-5---flexibility-and-support-for-different-and-evolving-query-mechanisms) -
    Flexibility and support for different and evolving query mechanisms.</b>

[Problem #6](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-6---these-problems-must-be-solvable-using-the-fundamentals-of-solid-as-it-exists-today) -
    These problems must be solvable using the fundamentals of Solid
    as it exists today.

* <b>[Goal](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-6---optimize-and-extend-but-do-not-change-solid-fundamentals) -
    Optimize and extend, but do not change Solid fundamentals.</b>

</div>

We must be able to support data interoperability across applications while
enabling secure collaboration and query using intuitive data boundaries.

Diversity in how the same data will be accessed and manipulated by different
entities and applications exacerbates the need for reliable mechanisms that
protect against data corruption, data leakage, or broken workflows

Standard methods and mechanisms for interoperability, collaboration, and
security of data in a Solid Pod must realize these needs, and it must be done
without changing the fundamentals of Solid.

Note: See [[PROBLEMS-AND-GOALS]] for a detailed explanation of each discrete
problem.

Proposal {#proposal}
=====================

In this proposal, we aim to address the stated problems and associated goals
by providing straightforward patterns that can be used in concert to realize
an [=interoperable ecosystem=] for [=Solid=]. To aid in understanding,
we structure the proposal in the form of an end-to-end use case.

We introduce [=shape trees=] as a fundamental means through which we model,
validate, organize, and authorize data stored in a Solid [=pod=]. Data becomes
durable, interoperable, and available to be retrieved in different
representations or discovered through any query mechanism.

Nowhere in this proposal does an [=agent=] or
[=application=] need to worry about where to store data, or where to find it.
Data is organized and shared using intuitive data boundaries
provided by [=shape trees=], making it easy for Alice, Bob, and their respective
applications to interoperate with each other in a way that they all understand.
In concert with [=acl resources=], this organization scheme facilitates
straightforward compartmentalized access by [=authenticated agents=] and
[=applications=], and allows them to operate using the least amount of
privilege necessary to complete their tasks.


We introduce patterns for [[#appreg|registering applications]], authorizing
access to data, keeping track of access grants, and of remote resources
for which access has been granted to the [=resource controller=].
[=trusted agents|Trusted Agents=] perform important actions for the
[=resource controller's=] with escalated privileges to help her securely
manage her data and make informed, intuitive, and secure decisions.

Most importantly, this proposal can work with Solid as it exists today, on its
own or alongside other conventions, with some caveats.

<div class="assertion">

* Identifying the [=ApplicationID=] in an [=acl resource=] statement
    requires [[WAC]] extension and IdP support. This proposal still works
    without this, but you would no longer be able to compartmentalize
    access between [=user-piloted applications=] in use by the
    [=resource controller=].
* This proposal assumes support for [=shape=] validation on the [=Solid=]
    server. It will still work without this support, but will significantly
    hamper data durability, integrity, and interoperability. Similarly,
    it doesn't require the server to perform [=shape tree=] validation,
    but more reliable and durable interoperability would be achieved with
    server-side support.

</div>

Reference Use Case {#usecase}
=====================

In our use case, Alice wants to use a new application to record and manage
her personal and professional notes. She does a Web search and finds
NeverNote (https://nevernote.example), a web-based application that advertises
itself as Solid Enabled. Alice is excited about this because she recently
created a Solid Pod for herself at https://alice.pod.example.

We follow Alice (and then Bob) through the following sequence:

1. Alice decides to use a Solid-enabled web application called NeverNote
1. NeverNote checks to see if it has been registered with Alice’s Pod already
1. NeverNote is registered with Alice’s Pod through the help of Alice’s
    Application Registration Agent.
1. Through the help of her Authorization Agent, Alice grants NeverNote the
    following privileges:
    * Access to Notes that already existed in her Pod
    * Ability to create new Notes that NeverNote will have permission to manage
    * Ability to create new Notebooks that NeverNote will have permission to manage
1. Alice later expands NeverNote’s access to include her Contacts
1. Alice and Bob collaborate on a Notebook in Alice’s Pod. Bob is using a
    different application than NeverNote called OtherNote.

Client Identification {#client}
=====================

Throughout this proposal, we see cases where Alice compartmentalizes access
to her data based on who or what is access it - the [=authenticated agent=].
In certain cases, we also limit access based on the application in use
by Alice - the
[=user-piloted application=].

We utilize a new optional predicate in an [=acl resource=] statement to
restrict access to permitted [=user-piloted applications=], identified by their
[=ApplicationIDs=].

Limiting access to data based on
the [=user-piloted application=] in use is only reliable in certain
instances when the [=application=] can be identified with confidence.

## Identifying client applications ## {#client-id}

For identification purposes, client [=applications=] in use across the world
today fall into two buckets; *strongly identifiable* and *weakly identifiable*.

**Strongly identifiable clients** can be identified by 3rd parties independently
from their user/controller. Only [=server-side applications=] are
strongly identifiable. As confidential clients, they can keep secrets
and can present attestations and third-party credentials
via DNS / domain certificates.

**Weakly identifiable clients** include in-browser JS apps and native desktop
or mobile applications. They are considered weakly identifiable because they
are not able to keep secrets on an instance level. They are often referred to
as public clients. Native apps should be strongly-identifiable in theory
(since they are able to keep secrets on an instance level), but not in
practice because the OS manufacturers do not make their trust
infrastructure available. **Weakly identifiable clients are only strongly
identifiable to the user controlling them**.

## Limiting access by client application ## {#client-limit}

In the case of a strongly identifiable [=server-side application=],
the [=authenticated agent=] and the client application are the same. The client
application has its own [=identity=] that can be strongly authenticated. Alice
chooses which data that client application's identity can access, in the same
way that she chooses which data Bob can access.

In the case of [=user-piloted applications=], the ability for a Solid pod to
limit access to data by the client application in use is only as strong as
the trustworthiness of the user piloting that application, and their ability
to avoid using malicious applications. The [=ApplicationID=] can be manipulated
by the user in control of the app. This means that Alice can strongly control
the applications that she uses to compartmentalize her own data, but has
limited ability to control the applications that Bob uses to access the data
she shares with him.

Trusted Agents {#trusted}
=====================

A [=trusted Agent=] is an application that a [=resource controller=] trusts
to perform actions for them with elevated privilege. They can be
trusted to help a resource controller to make smart decisions related to
their data.

There's no limit to what a trusted agent can
assist with, but [[#appreg|registering applications]] and authorizing access to
data are two critical operations covered in this proposal.

A trusted [=application registration agent=] helps the [=resource controller=]
make smart decisions about the applications they choose to utilize, and
ensure they get provisioned appropriately.

A trusted agent for data authorization is needed in cases where the resource
controller wishes to grant limited access to data in her Pod to another
[=authenticated agent=] or [=user-piloted application=], but needs
assistance to determine what access is needed, and help to provision
that access.

There are three typical patterns to interact with a trusted agent;
*Embedded*, *Synchronous*, and *Asynchronous*.

The **Embedded pattern** is employed when the application in question has full
control privileges, and the trusted agent capabilities can
be executed directly. An example of an application that could fall into
this category would be a Pod management application installed by default
by the user’s Pod provider.

The **Synchronous pattern** utilizes a web-based redirect flow much like an
OAuth2 grant flow. The user is redirected to the trusted agent URL, with
a callback parameter provided as part of the request. When the
trusted agent is finished, it sends the user back to the provided
callback URL. This is an excellent pattern for application registration
and data authorization.

The **Asynchronous pattern** utilizes an event based model, where a message is
sent to the Trusted Agent through some mechanism (direct, pubsub, etc).
This flow is most typical for server-side/bot applications or any piloted
clients that can make use of asynchronous notification processing.

A given trusted agent may employ one or more of these patterns.

Registrar {#reg}
=====================

A [=Registrar=] provides registries where an [=agent=] can register,
store, and lookup essential data needed to participate in the ecosystem.
It supports key functions like application registration,
organizing and tracking data, and more.

* [[#appreg]] uses [=application registries=] to manage
    [=application registrations=].
* Data Registration relies on [=data registries=] to organize,
    store, and find registered data.
* [=Access registries=] let agents track and communicate access grants to
    resources they control.
* Agents track and manage data that has been shared with them through
    [=remote registries=].


## Registrar Data Model ## {#reg-model}

<figure>
  <img src="registrar-model.svg" width=90%/>
  <figcaption align="center">Top level registrar data model</figcaption>
</figure>


Humans, software, or device [=agents=] participating in the Solid ecosystem
are represented by the class `ecosystem:Agent`. Each `ecosystem:Agent` has
a [=registrar=], represented by the class `ecosystem:Registrar`.

<figure>
  <figcaption>Agent at https://alice.pod.example/id#me linking to
  registrar</figcaption>
  <pre highlight="turtle">
  <#me>
    a ecosystem:Agent;
    ecosystem:hasRegistrar &lt;https://alice.pod.example/registries/#registrar&gt; .
  </pre>
</figure>

A registrar links to a number of [=Registry sets=]. Registry sets are
represented by the class `ecosystem:RegistrySet`. They are collections of
one or more linked [=registries=]. They are almost always focused on a single
registry type, through type-specific
subclasses (e.g. `ecosystem:ApplicationRegistrySet`).

A given `ecosystem:Registar` is linked to an `ecosystem:RegistrySet` via the
`ecosystem:hasRegistrySet` property, or through type-specific sub-properties
(e.g. `ecosystem:hasApplicationRegistrySet`).

<figure>
  <figcaption>Registrar at
  https://alice.pod.example/registries/#registrar linking to
  application and data registry sets</figcaption>
  <pre highlight="turtle">
  <#registrar>
    a ecosystem:Registrar;
    ecosystem:hasApplicationRegistrySet &lt;https://alice.pod.example/registries/application#set&gt; ;
    ecosystem:hasDataRegistrySet &lt;https://alice.pod.example/registries/data#set&gt; .
  </pre>
  </figure>
</figure>

An `ecosystem:RegistrySet`, or a type-specific subclass
(e.g. `ecosystem:DataRegistrySet`) links to any number of
`ecosystem:Registry` instances or type-specific subclasses
(e.g. `ecosystem:ApplicationRegistry`) via the
`ecosystem:hasRegistry` property.

<figure>
  <figcaption>ApplicationRegistrySet linking to two different
  ApplicationRegistry instances in two pods</figcaption>
  <pre highlight="turtle">
  <#set>
    a ecosystem:ApplicationRegistrySet;
    ecosystem:hasRegistry &lt;https://alice.pod.example/applications/#registry&gt; ,
                          &lt;https://alice.otherpod.example/applications/#registry&gt; .
  </pre>
</figure>

An `ecosystem:Registry`, or a type-specific subclass
(e.g. `ecosystem:ApplicationRegistry`) links to any number of
`ecosystem:Registration` instances or type-specific subclasses
(e.g. `ecosystem:ApplicationRegistration`) via the
`ecosystem:hasRegistration` property.

<figure>
  <figcaption>ApplicationRegistry linking to three
  ApplicationRegistration instances</figcaption>
  <pre highlight="turtle">
  <#registry>
    a ecosystem:ApplicationRegistry ;
    ecosystem:hasRegistration &lt;https://alice.pod.example/applications/02f9d4221d9e5c0ae/#registration&gt ,
                              &lt;https://alice.pod.example/applications/6fe4221d0589d7bde/#registration&gt ,
                              &lt;https://alice.pod.example/applications/543ab04333ba5bcc2/#registration&gt .
  </pre>
</figure>

The properties and associated data of a given `ecosystem:Registration`
may vary widely depending on the type of `ecosystem:Registry` it is
associated with. However, a number of general properties are inherited from
the base class `ecosystem:Registration`. In the following example, all
properties except for `ecosystem:registeredApplication` are inherited from
`ecosystem:Registration`.

<figure>
  <figcaption>Instance data for
  an ApplicationRegistration </figcaption>
  <pre highlight="turtle" line-highlight="5" line-numbers="true">
  <#registration>
    a ecosystem:ApplicationRegistration ;
    ecosystem:registeredBy &lt;https://alice.pod.example/id#me&gt; ;
    ecosystem:registeredWith &lt;https://trusted.example/ar&gt; ;
    ecosystem:registeredApplication &lt;https://nevernote.example/id#agent&gt; ;
    ecosystem:registeredAt "2020-04-04T20:15:47.000Z"^^xsd:dateTime .
  </pre>
</figure>

## Structure and Validation ## {#reg-structure}

Instances of the classes and properties in the [[#reg-model]]
are organized across different resources and containers in
a conformant pod hierarchy. The instance data in resources are
validated by shapes, which are associated with those resources
through [=shape trees=].

<figure>
  <figcaption>Example Registrar structure for an Agent.
  Excludes some registry types for clarity.</figcaption>
  <img src="registrar-tree.svg" width=100%/>
</figure>

The `ecosystem:Registrar` linked to an `ecosystem:Agent`
is discovered by dereferencing the agent's [=identity=]
(e.g. `https://alice.pod.example/id#me`) to access their
[=identity profile document=], represented in
the figure above as `/id`.

The `ecosystem:Registrar` instance is stored in the RDF graph of the
`/registeries` container at `https://alice.pod.example/registries/#registrar`.
The `ecosystem:Registrar` instance links to a collection of
`ecosystem:RegistrySet` instances stored in the `/registries` container.

The shape tree `<#registrar-tree>` associated with the `/registries` container
specifies this resource structure. It assigns the `#RegistrarShape` to validate
an `ecosystem:Registrar` instance in the container resource. It also
assigns `#ApplicationRegistrySetShape` and `#DataRegistrySetShape`
to validate the  `ecosystem:ApplicationRegistrySet` and
`ecosystem:DataRegistrySet` instances in the contained resources.

<figure>
  <figcaption>Shape trees, shapes, and RegistrySet resources
  associated with a Registrar container</figcaption>
  <img src="registrar-registries.svg" width=100%/>
</figure>

An `ecosystem:RegistrySet` resource of a specific type will link to one or more
`ecosystem:Registry` instances of the same type.

For example, the `ecosystem:ApplicationRegistrySet` at
`https://alice.pod.example/registries/application#set` links to two
`ecosystem:ApplicationRegistry` instances, one of them being
`https://alice.pod.example/applications/#registry`.

The `ecosystem:ApplicationRegistry` instance is stored in the RDF graph
of the `/applications` container at
`https://alice.pod.example/applications/#registry`. It links to a
collection of `ecosystem:ApplicationRegistration` instances stored in
the `/applications` container.

The shape tree `<#application-registry-tree>` associated with the
`/applications` container specifies this resource structure. It assigns
the `#ApplicationRegistryShape` to validate the
`ecosystem:ApplicationRegistry` instance in the
container resource. It also assigns a `ApplicationRegistrationShape`
to validate an `ecosystem:ApplicationRegistration` in every
contained resource.

<figure>
  <figcaption>Shape trees, shapes, and ApplicationRegistration
  resources associated with an ApplicationRegistry container</figcaption>
  <img src="registrar-applications.svg" width=100%/>
</figure>

## Permission Model ## {#reg-permissions}

The permission model for the registrar resources detailed in [[#reg-structure]]
are illustrated in the table below. That said, the following key points
are worth noting:

* The [=identity profile document=] at `/id` is the only resource that is
    publicly accessible (with read-only privileges).
* The only information exposed is a link to Alice's registrar at
    `/registries`, which is a protected document.
* Neither the types or locations of Alice's registries are
    ever publicly exposed.

<figure>
<figcaption>Permission model for registrar resources</figcaption>
  <table class="data permissions" align="left">
    <col>
    <colgroup span=2></colgroup>
    <colgroup span=2></colgroup>
    <colgroup span=2></colgroup>
    <thead>
      <tr>
        <th></th>
        <th colspan=2 scope="colgroup">Public</th>
        <th colspan=2 scope="colgroup">Selectively Trusted</th>
        <th colspan=2 scope="colgroup">Selectively Granted</th>
      </tr>
      <tr>
        <th scope="col">Resource</th>
        <th scope="col">Subject</th>
        <th scope="col">Access</th>
        <th scope="col">Subject</th>
        <th scope="col">Access</th>
        <th scope="col">Subject</th>
        <th scope="col">Access</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/id`</td>
        <td>Everyone</td>
        <td>Read</td>
        <td>Identity Agent</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`/registries/`</td>
        <td>Everyone</td>
        <td>Read</td>
        <td>Identity Agent</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`-- /registries/application`</td>
        <td>-</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`-- /registries/data`</td>
        <td>-</td>
        <td>-</td>
        <td>Data Authorization Agent</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`/applications/`</td>
        <td>-</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`-- /applications/registration-123/`</td>
        <td>-</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>Registered App.</td>
        <td>Read</td>
      </tr>
      <tr>
        <td>`-- /applications/registration-123/*`</td>
        <td>-</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>Registered App.</td>
        <td>Write</td>
      </tr>
      <tr>
        <td>`/data`</td>
        <td>-</td>
        <td>-</td>
        <td>Data Authorization Agent</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`-- /data/registration-456/`</td>
        <td>-</td>
        <td>-</td>
        <td>Data Authorization Agent</td>
        <td>Control</td>
        <td>Grantee</td>
        <td>Varies</td>
      </tr>
      <tr>
        <td>`-- /data/registration-456/*`</td>
        <td>-</td>
        <td>-</td>
        <td>Data Authorization Agent</td>
        <td>Control</td>
        <td>Grantee</td>
        <td>Varies</td>
      </tr>
    </tbody>
  </table>
</figure>

Application Registration {#appreg}
=====================

Application Registration gives [=agents=] participating in the Solid
ecosystem a way to register and track the applications they've elected
to use with their data. It also provides each application with a place
to store metadata, preferences, access grants, caches, and other internal
data specific to the function of each application.

An [=application registry=] for storing individual
[=application registrations=] is introduced, implemented through the [[#reg]].

For example, in our [[#usecase]], Alice wants to use NeverNote
(`https://nevernote.example`), an application
that she's never used before.

When Alice arrives at NeverNote (`https://nevernote.example`) in her
web browser, she is prompted to login with her [=WebID=] because NeverNote
doesn’t know who she is yet. She could be a completely new user of
NeverNote, or a returning user that has already registered.

Alice logs into her [=identity provider=] (`https://idp.example`) with her
WebID (`https://alice.pod.example/id#me`), and receives
a [=token=] that NeverNote can use to make requests to her pod.
The token identifies her as Alice (`https://alice.pod.example/id#me`),
using NeverNote (`https://nevernote.example/id#agent`).

NeverNote
[[#appreg-lookup|looks for an application registration]] for itself through
Alice's registrar. If no registration is found, NeverNote will go through
a quick [[#appreg-new|registration process]]. If there is already an
existing registration for NeverNote, no additional
steps are necessary.


## Data Model ## {#appreg-datamodel}

<figure>
  <img src="appreg-model.svg" width=100%/>
  <figcaption>Data model for application registration</figcaption>
</figure>

Application Registration extends the [[#reg-model]] with type-specific
subclasses and subproperties.

* An `ecosystem:Agent` has an `ecosystem:Registrar`, which links to
    `ecosystem:ApplicationRegistySet` instances.

* An `ecosystem:ApplicationRegistrySet` links to any number of
    `ecosystem:ApplicationRegistry` instances via the `ecosystem:hasRegistry`
    property.

* An `ecosystem:ApplicationRegistry` links to any number of
    `ecosystem:ApplicationRegistration` instances via the
    `ecosystem:hasRegistration` property.

* An `ecosystem:ApplicationRegistration` extends the `ecosystem:Registration`
    class.

The `ecosystem:ApplicationRegistration` subclass introduces the following
subproperties:

* **ecosystem:registeredApplication** - [=ApplicationID=] of the `ecosystem:Application`
    that is being registered.

<figure>
  <figcaption>Instance data for
  an ApplicationRegistration at
  https://alice.pod.example/applications/02f9d4221d9e5c0ae/#registration
  </figcaption>
  <pre highlight="turtle" line-highlight="5" line-numbers="true">
  <#registration>
    a ecosystem:ApplicationRegistration ;
    ecosystem:registeredBy &lt;https://alice.pod.example/id#me&gt; ;
    ecosystem:registeredWith &lt;https://trusted.example/ar&gt; ;
    ecosystem:registeredApplication &lt;https://nevernote.example/id#agent&gt; ;
    ecosystem:registeredAt "2020-04-04T20:15:47.000Z"^^xsd:dateTime .
  </pre>
</figure>

## Structure and Validation ## {#appreg-structure}

A given `ecosystem:Agent` will have one or more
`ecosystem:ApplicationRegistry` instances discoverable through the
[[#reg-model]], via resources that implement
[[#reg-structure|Registrar Structure and Validation]].

<figure>
  <figcaption>An ApplicationRegistry instance at
  https://alice.pod.example/applications/#registry</figcaption>
  <img src="registrar-applications.svg" width=100%/>
</figure>

The `ecosystem:ApplicationRegistry` instance is stored in the RDF graph
of the `/applications` container at
`https://alice.pod.example/applications/#registry`. It links to a
collection of `ecosystem:ApplicationRegistration` instances stored in
the `/applications` container.

The shape tree `<#application-registry-tree>` associated with the
`/applications` container specifies this resource structure. It assigns
the `#ApplicationRegistryShape` to validate the
`ecosystem:ApplicationRegistry` instance in the
container resource, and says that the container includes
instances of `<#application-registration-tree>`, which any
resources added to the `/applications` container must conform to.

Conforming to `<#application-registration-tree>` ensures that the
`ecosystem:ApplicationRegistry` at `/applications` only contains
valid `ecosystem:ApplicationRegistration` instances.

Specifically:

* Any resource added to the `/applications` container must be a
    container (`tree:expectedType ldp:Container`)
* An `ecosystem:ApplicationRegistration` instance must be stored in the
    RDF graph of that container, to successfully pass shape validation via
    `tree:shape <#ApplicationRegistrationShape>`.

<figure>
  <figcaption>An ApplicationRegistration instance at
  https://alice.pod.example/applications/02f9d4221d9e5c0ae/#registration
  </figcaption>
  <img src="appregistration-structure.svg" width=100%/>
</figure>

These `ecosystem:ApplicationRegistration` instances are defined as
containers so that the `ecosystem:Application` that has been registered
has dedicated space to store internal data that is very specific to the function
of that application. In the figure above, we can see an application-specific
configuration resource (`config.ttl`) and a summary index file (`summary.idx`).

### Naming application registration resources ### {#appreg-naming}

In this proposal resource names for ecosystem instances are almost always
randomly generated. However, when creating an `<#application-registration-tree>`
for the `ecosystem:ApplicationRegistration` instance, the container
must be named using a SHA-256 hash encoding of the [=ApplicationID=] for the
`ecosystem:Application`, which is linked through the
`ecosystem:registeredApplication` property.

:: <b>NeverNote ApplicationID:</b> `https://nevernote.example/id#agent`
:: <b>SHA-256 Hash:</b> `70e9249113f8aef095626980e82f13833f24a902571502ef726b4d7e69739ba3`

In our [[#usecase]], the name of the container for NeverNote's
`ecosystem:ApplicationRegistration` instance would be
`70e9249113f8aef095626980e82f13833f24a902571502ef726b4d7e69739ba3`.

### Use of internal application space ### {#appreg-internal}

There is a legitimate argument that giving applications their own
private data space in Solid is counterintuitive to Solid’s proposition to
decouple data and applications.

However, there are certain types of data that are very specific to
the function of a particular application, and have no value to other
applications. This may include but not be limited to application-specific
preferences, configurations, caches, or indexes. Forcing that data into
shape trees and shapes stored in the data registry that are supposed
to be consumable and interoperable by other applications can lead to
frankenstein-like shape trees and shapes that no one wants to use.
Giving applications a private space where they can store internal data
is therefore a key factor in broad interoperability,
because it protects interoperable data from pollution by narrowly
focused elements.

Ultimately, if applications don't want to be interoperable, there's
no reasonable convention that could prevent it. For example, they could
decide to use proprietary vocabularies, shapes, and shape trees.
However, there are motivating factors to
be interoperable, because in doing so they become compatible with a
slew of data that already exists in the ecosystem, including data within
their competitive landscape. Providing a private space allows applications
to separate some internals from true interoperable data so that the
interoperable data is cleaner and more usable. Our belief is that
this helps avoid the creation of application-specific silos.

Because this space is private to an application and not meant to
be interoperable, the application may or may not decide to utilize
data validation facilities like shape trees or shapes.

## Permission Model ## {#appreg-permissions}

<figure>
<figcaption>Permission model for application registry resources</figcaption>
  <table class="data permissions" align="left">
    <col>
    <colgroup span=2></colgroup>
    <colgroup span=2></colgroup>
    <colgroup span=2></colgroup>
    <thead>
      <tr>
        <th></th>
        <th colspan=2 scope="colgroup">Public</th>
        <th colspan=2 scope="colgroup">Selectively Trusted</th>
        <th colspan=2 scope="colgroup">Selectively Granted</th>
      </tr>
      <tr>
        <th scope="col">Resource</th>
        <th scope="col">Subject</th>
        <th scope="col">Access</th>
        <th scope="col">Subject</th>
        <th scope="col">Access</th>
        <th scope="col">Subject</th>
        <th scope="col">Access</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/applications/`</td>
        <td>-</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`-- /applications/registration-14a/`</td>
        <td>-</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>Registered App.</td>
        <td>Read</td>
      </tr>
      <tr>
        <td>`-- /applications/registration-c3b/*`</td>
        <td>-</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>Registered App.</td>
        <td>Write</td>
      </tr>
      <tr>
        <td>`-- /applications/registration-12e/*`</td>
        <td>-</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>Registered App.</td>
        <td>Write</td>
      </tr>
      <tr>
        <td>`-- /applications/registration-f8f/*`</td>
        <td>-</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>Registered App.</td>
        <td>Write</td>
      </tr>
    </tbody>
  </table>
</figure>

There is no public access to any data in an `ecosystem:ApplicationRegistry`.

Only `ecosystem:Agents` that have been selectively trusted to assist a
given agent with Application Registration have the ability to manage
contents and permissions across `ecosystem:ApplicationRegistry` instances,
including the creation and modification of `ecosystem:ApplicationRegistration`
instances.

A given registered `ecosystem:Application` has read access to its
`ecosystem:ApplicationRegistration` resource, and read/write access to
the data space inside that container. It does not get control privileges.

## Looking up an Application Registration ## {#appreg-lookup}

NeverNote needs to determine if it is already registered, so it needs to
see if there is an entry for itself at
`<https://alice.pod.example/applications/>`.

Only the [=resource controller=] (Alice) and her trusted agents should have
visibility and control
of her application registry sets and registries. Just because Alice
uses a given application like NeverNote doesn't mean that NeverNote should
be allowed to know every other application she uses.
Consequently, we do not give NeverNote read access to the
entire application registry. Nor do we allow it to directly access any
other application registration entries, or allow it to register itself.

We do allow NeverNote (as a [=user-piloted application=] used by Alice),
to directly access its own
application registration entry. However, Nevernote must know how
to find that entry using information it already has. We solve this by using
a SHA-256 hash of NeverNote's ApplicationID to name the container
of the application registration entry.

Since NeverNote knows its own ApplicationID, it looks for
a SHA-256 hash of `https://nevernote.example/id#agent` in
`https://alice.pod.example/applications/`.

<pre>
GET https://alice.pod.example/applications/70e9249113f8aef095626980e82f13833f24a902571502ef726b4d7e69739ba3
</pre>

If NeverNote is unable to access the registration entry, then it knows that it
needs to be registered. Inability to access would be for one of the following
reasons:

* **There is no application registration for NeverNote.** The server may return
    either a 403 or 404 depending on server or user privacy preference.
* **There is an application registration at the target URL, but NeverNote
    cannot access it because it is associated with another application's
    identity.** The server may return either a 403 or 404 depending on
    server or user privacy preference.

If NeverNote can read the
application registration entry, then it can confirm that it
is already a registered application in Alice’s Pod.

In the proposed use case, Alice hasn't registered NeverNote yet,
so it cannot access an application registration entry for itself. It needs to be
registered, and that must be facilitated through
Alice’s trusted [=application registration agent=].

## Registering an Application ## {#appreg-new}

NeverNote has determined that it needs to be registered in Alice’s
Pod. It cannot register itself, so it needs the help of Alice's
[=application registration agent=]. It must first dereference Alice's WebID to
access [[#alice-profile]]. It will then look for the
`ecosystem:trustsForApplicationRegistration` predicate in the contents
of her identity profile document to discover the
application registration agent she trusts.

<b>Excerpt from [[#alice-profile]]</b>
<pre highlight="turtle">
  <#me> ecosystem:trustsForApplicationRegistration &lt;https://trusted.example/ar/&gt; .
</pre>

NeverNote redirects Alice via the synchronous trusted agent pattern to
the `ecosystem:trustsForApplicationRegistration`
at `https://trusted.example/ar/`, supplying its [=ApplicationID=]
(`https://nevernote.example/id#agent`) as a parameter. The
ApplicationID uniquely identifies the application, and leads to
[[#nevernote-profile]], an RDF document containing data required to
complete the registration process.

Issue: Provide a sequence diagram for application registration, and incorporate
specific detail about the end user experience during that flow.

The application registration agent is now expected to dereference
(i.e. perform an HTTP GET on) the ApplicationID to retrieve
[[#nevernote-profile]]. The contents of an [=application profile document=]
help the agent determine whether that application is suitable for
approval.

For example, verification of a verifiable credential
stored in [[#nevernote-profile]], issued by a third party that Alice
trusts, is a good indicator of the application’s trustworthiness.
Similarly, an application, or the [=identity provider=] it uses, may
be listed on a trusted whitelist that the Application Registration
Agent consults. The Application Registration Agent is able to raise
issues related to these checks (or others) to Alice as part of
her decision making process.

Assuming suitability and confirmation from Alice, the
application registration agent will proceed in [[#appreg-creating]] for
NeverNote in Alice’s Pod. When it is finished, it will return her to
NeverNote at the `ecosystem:applicationRegistrationCallback` address in
[[#nevernote-profile]].

<b>Excerpt from [[#nevernote-profile]]:</b>

<pre highlight="turtle">
<#agent>
    ecosystem:applicationRegistrationCallback &lt;https://nevernote.example/app-registration&gt; ;
</pre>

### Creating the application registration entry ### {#appreg-creating}

[=Application registrations=] are instances of
application registration shape trees.
Each application registration is a container, which allows
important metadata about the application to be stored, and also gives
an application the [[#appreg-internal]] that it may need for certain
non-interoperable data important to its own internal operations, but not
pertinent to other applications'.

NeverNote’s ApplicationID: `https://nevernote.example/id#agent`

SHA-256 hash: `70e9249113f8aef095626980e82f13833f24a902571502ef726b4d7e69739ba3`

The hash of NeverNote’s ApplicationID will be used to name the
application registration container and uniquely identify it. Per the location
defined by `ecosystem:registryStorage` in [[#alice-appregset]],
the [=application registration=] will be provisioned at:

`https://alice.pod.example/applications/70e9249113f8aef095626980e82f13833f24a902571502ef726b4d7e69739ba3`.

NeverNote will always know where to find this, because it knows its
own ApplicationID.

The following resource contains the registration detail:
`https://alice.pod.example/applications/70e9249113f8aef095626980e82f13833f24a902571502ef726b4d7e69739ba3/application#registration`.

<b>Excerpt from [[#alice-appregnevernote]]</b>
<pre highlight="turtle">
<#registration>
  a ecosystem:applicationRegistration ;
  ecosystem:registeredBy &lt;https://alice.pod.example/id#me&gt; ;
  ecosystem:registeredWith &lt;https://trusted.example/ar&gt; ;
  ecosystem:registeredApplication &lt;https://nevernote.example/id#agent&gt; ;
  ecosystem:registeredAt "2020-04-04T20:15:47.000Z"^^xsd:dateTime .
</pre>


NeverNote is provided read access to the application registration,
and read/write access to the internal space. This gives NeverNote as
much freedom as it
likes to store data in its own internal space, but not the ability
to change permissions or alter the registration data maintained by
the [=application registration agent=].


Definitions {#definitions}
=====================

<b>All definitions as stated below should be considered in the context of
an [=interoperable ecosystem=] for [=Solid=], whether explicitly stated
or not.</b>

<dfn>Solid</dfn> is a protocol made up of a number of open web standards
aimed at decentralizing data on the web.

A Solid <dfn>pod</dfn> is a place for storing and accessing data via
the [=Solid=] protocol, with mechanisms for controlling who or what can
access that data.

An <dfn>interoperable ecosystem</dfn> is a collection of
[=Solid=] compatible [=applications=] developed by one or more entities,
used by a community of users, that can safely access and manipulate the same
kinds of data in [=pods=].

An <dfn>application</dfn> is a piece of software that interfaces with a
Solid pod, either as a [=server-side application=], or as a
[=user-piloted application=].

A <dfn>server-side application</dfn> runs on a dedicated server. They may
also act as autonomous [=authenticated agents=].

A <dfn>user-piloted application</dfn> runs on a user's device, with the user
as the [=authenticated agent=]. They include in-browser javascript
applications, native desktop applications, and mobile applications.

An <dfn>agent</dfn> is a distinct individual, group, organization, or piece
of software with an identity that can be strongly authenticated.

An <dfn>identity</dfn> in Solid is a unique URI that can be dereferenced to
return an [=identity profile document=]. Compatible identity systems
include [=WebID=] and [=DID=].

An <dfn>identity profile document</dfn> is a linked data document obtained
by dereferencing the URI for a given [=identity=]. It provides information
that can be used to prove that a given [=agent=] controls the document.

An <dfn>authenticated agent</dfn> is an [=agent=] that has strongly
authenticated their [=identity=] by proving control of the
[=identity profile document=] via an authentication protocol such as
[[WEBID-OIDC]].

A <dfn>WebID</dfn> is a web resource at an HTTP URI which refers to an
[=agent=]. An [=identity profile document=] can be accessed by
dereferencing the WebID. [[WEBID]]

A <dfn>DID</dfn> is a URI that associates a DID subject (e.g. an [=agent=],
thing, data model, abstract entity, etc.) with a DID document,
equivalent to an [=identity profile document=], to allow trustable
interactions with that subject. [[DID]]

An <dfn>identity provider</dfn> furnishes an [=agent=] with authenticated
credentials that prove agent is who it says it is, across the web.

A <dfn>token</dfn> is used to make authenticated requests to the [=Solid=]
server for a given [=authenticated agent=].

An <dfn>ApplicationID</dfn> is a web resource at an HTTP URI uniquely associated
with a given [=application=]. For [=server-side applications=], it may also
serve as an [=identity=]. An [=application profile document=] can be
accessed by dereferencing the ApplicationID.

An <dfn>application profile document</dfn> is a linked data document
obtained by dereferencing the URI for a given [=ApplicationID=]. It contains
useful information about an application that can be employed in
various workflows including application registration and data authorization.

A <dfn>resource controller</dfn> is an [=authenticated agent=] with full
privileges and control over a given resource or set of resources.

An <dfn>acl resource</dfn> as defined by [[WAC]] may be directly
associated with a resource or indirectly associated with a resource
through inheritance. It determines which [=agents=] can access a
resource, and the modes of access they have for it.

A <dfn>trusted agent</dfn> is any [=application=] that a
[=resource controller=] trusts to perform actions for them. These
actions typically require some level of escalated privileges.

A <dfn>shape</dfn> provides a schema that RDF data graphs must meet in order
to be considered conformant. A shape associated with a given resource in a
[=pod=] ensures that any data stored in that resource must conform to the
associated shape. Shape languages include [[SHEX]] and [[SHACL]].

A <dfn>shape tree</dfn> defines a prospective tree of related resources
which can be read and written by applications. The shape tree associates
each of these resources with a shape. This allows one to treat a set of
related resources as a single grouping, and apply that to a range of
operations including access control, data organization, data validation,
and data migration. [[SHAPETREES]]

A <dfn>shape tree instance</dfn> is one or more resources in a [=pod=]
that conform to a [=shape tree=] definition. Also referred to as a
*planted shape tree*.

A <dfn>registrar</dfn> is ...

A <dfn>registry set</dfn> is a collection of one or more registries of a
specific type, including [=application registries=], [=data registries=],
[=access registries=], and [=remote registries=].

A <dfn>registry</dfn> is ...

An <dfn>application registry</dfn> is a collection of
[=application registrations=] stored in a specific location in a [=pod=].
They are represented by the `ecosystem:ApplicationRegistry` class,
and validated by the #ApplicationRegistryShape, through the
<#application-registry-tree>.

An <dfn>application registration</dfn> provides the [=resource controller=]
of a [=pod=] with a place to maintain metadata, state, preferences, and
other application-specific data associated with a given [=application=] they
have elected to use. An application registration is a [=shape tree instance=]
of the `<#registration>` shape tree in the TODO - application registries shape tree.

An <dfn>application registration agent</dfn> is a type of [=trusted agent=]
that a [=resource controller=] uses to register and manage applications that
interface with their [=pod=].

A <dfn>data registry</dfn> is...

An <dfn>access registry</dfn> is...

A <dfn>remote registry</dfn> is...


Use Case Environment {#environment}
=====================

Issue: Add the contents of the ecosystem vocabulary

## People ## {#people}

### Alice ### {#alice}

<table>
  <tbody>
    <tr>
      <td><th>Alice's Pod URL</th></td>
      <td>https://alice.pod.example</td>
    </tr>
    <tr>
      <td><th>Alice's WebID</th></td>
      <td>https://alice.pod.example/id#me</td>
    </tr>
  </tbody>
</table>

#### Alice's Pod Hierarchy #### {#alice-pod}

**Resource hierarchy of Alice's pod at https://alice.pod.example:**

<div class="assertion">

* **id** - [[#alice-profile]]
* **registries/** - Container for registry sets.
    * **application** - [[#alice-appregset]]
    * **data** - Data Registry Set
    * **access** - Access Registry Set
    * **remote** - Remote Registry Set
* **applications/** - application registry - where application registration
    entries are stored.
    * **70e9249113f8aef095626980e82f13833f24a902571502ef726b4d7e69739ba3/** -
        [[#alice-appregnevernote]], validated by the `#registration` shape tree
        in the application registry shape tree.
* **data/** - Registry of data
    * **d9e11f42-cd85-4191-a272-c974a54ef602/** - Local UUID for Notebook Shape Tree
        * **58c851c1-ef76-4d4b-8868-7472b632bfff/** - Notebook Instance UUID
        * **9fdbd6cc-5994-436a-a0d7-aaa87d401e1e/** - Notebook Instance UUID
        * **45eb3ead-ceb7-4628-8cd3-e9c0b6555b7a/** - Notebook Instance UUID
    * **0d7a50e6-9fe8-4f43-8682-0c990ea46bca/** - Local UUID for Note Shape Tree
        * **b94ad7c1-7f15-496c-b36d-e23eb1ba2327/** - Note Instance UUID
        * **57c3c536-f997-41cf-95d1-a86a8d04311f/** - Note Instance UUID
        * **53fa2198-e88d-4b46-8afa-d975c0882eb3/** - Note Instance UUID
        * **a2f0e442-846d-4308-8eb5-5beea8f7f7e7/** - Note Instance UUID
        * **3d26e6e5-17b7-437c-bb2b-2998b03b4009/** - Note Instance UUID
    * **746dd0ad-9e6e-4e31-8fa3-843d38a9db86/** - Local UUID for Contact Shape Tree
        * **aca1c96f-ea89-4965-abec-d46504f75344/** - Contact Instance UUID
        * **5f330889-04a7-471f-9df8-f75b99453468/** - Contact Instance UUID
        * **e288fd77-ffc6-4747-a0ff-7ad3592abc54/** - Contact Instance UUID
        * **f2dcc56d-7ecd-4af5-94bd-c1fb0fc73b6c/** - Contact Instance UUID
        * **bfe3493b-d26b-473a-8bca-7884d79c8295/** - Contact Instance UUID
* **access/** - Alice’s access inbox
    * **9908fb51-e3e6-46ee-b124-86ddbc02bcef** - Access-related Message
    * **1e13e429-84fd-4a6f-8aad-ed68e638cc85** - Access-related Message
* **granted/** - Registry of Access Grants
    * **ce173414-efb5-4971-bb0b-142f94230e9d** - Access Grant Record
    * **13ccb76c-16e2-4c95-9309-430dd22a78bf** - Access Grant Record
    * **502869ad-8a0d-4833-9e47-d27365ec03a1** - Access Grant Record
* **remote/** - Registry of remote resources shared with Alice
    * **d9e11f42-cd85-4191-a272-c974a54ef602** - Local UUID for Notebook Shape Tree
    * **eb71f9ca-0177-4e19-b35a-0ad20c6ab112** - Reference to instance of Notebook Shape Tree on Tom’s Pod

</div>

#### Alice's Profile Document #### {#alice-profile}

Issue: Need to provide more detail around *how* applications, data, access,
remote registry items get organized into different registries with a set along
with use cases.

<figure>
  <figcaption>Alice’s identity profile document at
  https://alice.pod.example/id</figcaption>
  <pre highlight="turtle">
  @prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt; .
  @prefix ecosystem: &lt;http://www.w3.org/ns/solid/ecosystem#&gt; .

  <#me>
      a ecosystem:Agent;
      ecosystem:hasRegistrar &lt;https://alice.pod.example/registries/#registrar&gt; ;
      # Trusted Agents
      ecosystem:trustsForApplicationRegistration &lt;https://trusted.example/ar/&gt; ;
      # Notification Endpoints
      ecosystem:hasAccessInbox &lt;https://alice.pod.example/access/inbox&gt; .
      # Identity Provider
      solid:oidcIssuer &lt;https://idp.example&gt; ;
  </pre>
</figure>

#### Alice's Registrar #### {#alice-registrar}

<figure>
  <figcaption>Alice’s registrar instance at
  https://alice.pod.example/registries/application#set</figcaption>
  <pre highlight="turtle">
  <#registrar>
    a ecosystem:Registrar;
    ecosystem:hasApplicationRegistrySet &lt;https://alice.pod.example/registries/application#set&gt; ;
    ecosystem:hasDataRegistrySet &lt;https://alice.pod.example/registries/data#set&gt; .
  </pre>
</figure>

#### Alice's Application Registry Set #### {#alice-appregset}

<figure>
  <figcaption>Alice’s application registry set instance at
  https://alice.pod.example/registries/application#set</figcaption>
  <pre highlight="turtle">
  <#set>
    a ecosystem:ApplicationRegistrySet;
    ecosystem:hasApplicationRegistry &lt;https://alice.pod.example/applications/#registry&gt; ,
                                     &lt;https://alice.otherpod.example/applications/#registry&gt; .
  </pre>
</figure>

#### Alice's Application Registry #### {#alice-appregistry}

<figure>
  <figcaption>Alice's application registry instance at
  https://alice.pod.example/applications/#registry</figcaption>
  <pre highlight="turtle">
  <#registry>
    a ecosystem:ApplicationRegistry ;
    ecosystem:hasRegistration &lt;https://alice.pod.example/applications/70e9249113f8aef095626980e82f13833f24a902571502ef726b4d7e69739ba3/#registration&gt; .
  </pre>
</figure>

Note that `https://alice.pod.example/applications/` is a container,
and #registry is stored in the RDF graph of the container resource.

#### Alice's Application Registration for Nevernote #### {#alice-appregnevernote}

<figure>
  <figcaption>Alice’s application registration instance for NeverNote at
  https://alice.pod.example/applications/70e9249113f8aef095626980e82f13833f24a902571502ef726b4d7e69739ba3/#registration</figcaption>
  <pre highlight="turtle">
  <#registration>
    a ecosystem:ApplicationRegistration ;
    ecosystem:registeredBy &lt;https://alice.pod.example/id#me&gt; ;
    ecosystem:registeredWith &lt;https://trusted.example/ar&gt; ;
    ecosystem:registeredApplication &lt;https://nevernote.example/id#agent&gt; ;
    ecosystem:registeredAt "2020-04-04T20:15:47.000Z"^^xsd:dateTime .
  </pre>
</figure>

Note that
`https://alice.pod.example/applications/70e9249113f8aef095626980e82f13833f24a902571502ef726b4d7e69739ba3/`
is a container, and #registration is stored in the RDF graph of the
container resource.

## Applications ## {#applications}

### NeverNote ### {#nevernote}

<table>
  <tbody>
    <tr>
      <td><th>Application URL</th></td>
      <td>https://nevernote.example</td>
    </tr>
    <tr>
      <td><th>Application ID (AppID)</th></td>
      <td>https://nevernote.example/id#agent</td>
    </tr>
    <tr>
      <td><th>SHA-256 Hash of AppID</th></td>
      <td>70e9249113f8aef095626980e82f13833f24a902571502ef726b4d7e69739ba3</td>
    </tr>
  </tbody>
</table>

#### NeverNote's Profile Document #### {#nevernote-profile}

Issue: We may want a more robust description of application type than only
schema:softwareApplication, especially given the different types of client and
their associated security considerations.

<figure>
  <figcaption>Contents of NeverNote’s Profile Document at
  https://nevernote.example/id#agent</figcaption>
  <pre highlight="turtle">
  @prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt; .
  @prefix ecosystem: &lt;http://www.w3.org/ns/solid/ecosystem#&gt; .
  @prefix acl: &lt;http://www.w3.org/ns/auth/acl&gt; .
  @prefix schema: &lt;http://www.schema.org&gt; .

  <#agent>
      # this is an application, not a person
      a ecosystem:Application;
      # redirect to this URL after going through authorization agent workflow
      ecosystem:authorizationCallback &lt;https://nevernote.example/data-authorization&gt; ;
      # redirect to this URL after going through application registration
      # agent workflow
      ecosystem:applicationRegistrationCallback &lt;https://nevernote.example/app-registration&gt; ;

  # Declaration of the type of access this application needs
  # UUID randomly generated for subject value
  <#33116309-1667-4a7b-a91f-4dbf177e3f95>
      a ecosystem:accessNeed;
      # Access needs related to notebook shape trees
      ecosystem:shapetree &lt;https://shapetrees.example/commonnote#notebook&gt;
      # Request permission create new notebook shape trees
      ecosystem:shapetreeCreate true;
      # Request permission to read and write created notebook shape trees
      ecosystem:shapetreeCreateAccess [ acl:Read, acl:Write ];
      # Request access to any existing notebook shape trees
      ecosystem:shapetreeExistingAccess true;
      # Request permission to read and write existing notebook shape trees
      ecosystem:shapetreeExistingAccess [ acl:Read, acl:Write ].

  <#75054942-b8b4-4e3a-84e4-7b564ca1ae7a>
      a ecosystem:accessNeed;
      ecosystem:shapetree &lt;https://shapetrees.example/commonnote#note&gt;;
      ecosystem:shapetreeCreate true;
      ecosystem:shapetreeCreateAccess [ acl:Read, acl:Write ];
      ecosystem:shapetreeExistingAccess true;
      ecosystem:shapetreeExistingAccess [ acl:Read, acl:Write ].
  </pre>
</figure>

<pre class="biblio">
{
  "problems-and-goals": {
    "href": "https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md",
    "title": "Problems and Goals for Interoperability, Collaboration, and Security in a Solid Pod",
    "authors": [
      "Justin Bingham",
      "Eric Prud'hommeaux",
      "Jamie Fiedler",
      "Josh Collins"
    ]
  },
  "shapetrees": {
    "href": "https://shapetrees.org",
    "title": "Shape Trees",
    "authors": [
      "Justin Bingham",
      "Eric Prud'hommeaux",
      "Jamie Fiedler",
      "Josh Collins"
    ]
  },
  "wac": {
    "href": "https://solid.github.io/specification/wac/",
    "title": "Web Access Control"
  },
  "webid": {
    "href": "https://www.w3.org/2005/Incubator/webid/spec/identity/",
    "title": "WebID 1.0",
    "authors": [
      "Tim Berners-Lee",
      "Henry Story",
      "Andrei Sambra"
    ]
  },
  "did": {
    "href": "https://www.w3.org/TR/did-core/",
    "title": "Decentralized Identifiers (DIDs) v1.0",
    "authors": [
      "Drummond Reed",
      "Manu Sporney",
      "Dave Longley",
      "Christopher Allen",
      "Ryan Grant",
      "Markus Sabadello"
    ]
  },
  "shex": {
    "href": "http://shex.io/shex-semantics/index.html",
    "title": "Shape Expressions Language 2.1",
    "authors": [
      "Eric Prud'hommeaux",
      "Iovka Boneva",
      "Jose Emilio Labra Gayo",
      "Gregg Kellogg"
    ]
  },
  "shacl": {
    "href": "https://www.w3.org/TR/shacl/",
    "title": "Shapes Constraint Language (SHACL)",
    "authors": [
      "Holger Knublauch",
      "Dimitris Kontokostas"
    ]
  },
  "webid-oidc": {
    "href": "https://github.com/solid/webid-oidc-spec",
    "title": "WebID-OIDC Authentication Specification",
    "authors": [
      "Dmitri Zagidulin"
    ]
  }
}
</pre>
