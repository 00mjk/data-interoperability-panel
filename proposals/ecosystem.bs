<pre class='metadata'>
Title: Proposal for an Interoperable Solid Ecosystem
Shortname: your-spec
Level: 1
Max ToC Depth: 2
Status: w3c/ED
Group: w3c
URL: http://example.com/url-this-spec-will-live-at
Editor: Justin Bingham
Editor: Eric Prud'hommeaux
Editor: Josh Collins
Markup Shorthands: markdown yes
Abstract:
  A proposal for a Solid ecosystem that supports data interoperability across
  applications while enabling secure collaboration and query using intuitive
  data boundaries without changing the fundamentals of Solid, presented in the
  form of an end-to-end use case.
</pre>

Problems {#problems}
=====================

Solid affords us the opportunity to create a valuable and
powerful ecosystem where people and organizations retain control of their data,
but are also able to put it to work and use it to its full potential. The
fundamentals of Solid make this possible, but further definition of standard
methods and mechanisms must be established to make it practical, intuitive, and
secure.

* [Problem #1](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-1---disparate-applications-cannot-practically-interoperate-over-the-same-data-safely-and-effectively) -
    Disparate applications cannot practically interoperate over the same data
    safely and effectively.
* [Problem #2](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-2---people-must-be-able-to-understand-what-data-they-have-to-effectively-use-it-or-share-it-safely) -
    People must be able to understand what data they have to effectively use it
    or share it safely.
* [Problem #3](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-3---disparate-entities-using-different-applications-must-be-able-to-safely-and-effectively-interoperate-within-their-scope-of-authorization) -
    Disparate entities using different applications must be able to
    safely and effectively interoperate within their scope of authorization.
* [Problem #4](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-4---people-shouldnt-need-to-think-about-how-to-physically-organize-their-data-to-use-solid) -
    People shouldn’t need to think about how to physically organize
    their data to use Solid.
* [Problem #5](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-5---when-data-is-stored-and-secure-it-should-be-queryable-using-any-mechanism-and-able-to-be-requested-in-different-representations) -
    When data is stored and secure, it should be queryable using any
    mechanism, and able to be requested in different representations.
* [Problem #6](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-6---these-problems-must-be-solvable-using-the-fundamentals-of-solid-as-it-exists-today) -
    These problems must be solvable using the fundamentals of Solid
    as it exists today.

Note: See [[PROBLEMS-AND-GOALS]] for a detailed explanation of each discrete
problem.

Goals {#goals}
=====================

We must be able to support data interoperability across applications while
enabling secure collaboration and query using intuitive data boundaries.

Diversity in how the same data will be accessed and manipulated by different
entities and applications exacerbates the need for reliable mechanisms that
protect against data corruption, data leakage, or broken workflows

Standard methods and mechanisms for interoperability, collaboration, and
security of data in a Solid Pod must realize these needs, and it must be done
without changing the fundamentals of Solid.

* [Goal #1](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-1---seamless-data-interoperability-across-disparate-applications) -
    Seamless data interoperability across disparate applications.
* [Goal #2](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-2---use-intuitive-data-boundaries-to-provide-human-to-machine-interoperability) -
    Use intuitive data boundaries to provide human to machine interoperability.
* [Goal #3](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-3---secure-collaboration-over-intuitive-data-boundaries) -
    Secure collaboration over intuitive data boundaries.
* [Goal #4](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-4---standard-and-flexible-organizing-model-for-data) -
    Standard and flexible organizing model for data.
* [Goal #5](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-5---flexibility-and-support-for-different-and-evolving-query-mechanisms) -
    Flexibility and support for different and evolving query mechanisms.
* [Goal #6](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-6---optimize-and-extend-but-do-not-change-solid-fundamentals) -
    Optimize and extend, but do not change Solid fundamentals.

Note: See [[PROBLEMS-AND-GOALS]] for a detailed explanation of each discrete
goal.

Proposal {#proposal}
=====================

In this proposal, we aim to address the stated problems and associated goals
by providing straightforward patterns that can be used in concert to realize
an interoperable ecosystem for Solid. To ensure the proposal is as easy to
understand as possible, we structure it in the form of an end-to-end use case.

We introduce [[SHAPETREES]] as a fundamental means through which we model,
validate, organize, and authorize data stored in a Solid pod. Data becomes
durable, interoperable, and available to be discovered through any query
mechanism.

Data is accessed, shared, and communicated using intuitive data boundaries
provided by shape trees, making it easy for Alice, Bob, and their respective
applications to interoperate with each other in a way they all understand.
Nowhere in this proposal does a person or application need to worry about
where to store data, or where to find it.

Data is fully compartmentalized using rational authorization boundaries
provided by shape trees, which allows for compartmentalized access by any
combination of authorized entities and/or client applications. We adhere to
the principle of least privilege, originally defined by Jerome Saltzer:

> Every program and every privileged user of the system should operate
> using the least amount of privilege necessary to complete the job.

Alice is able to compartmentalize her data between different applications she
"pilots", in spite of using them with her own credentials which afford her full
access to her data. Alice also exposes much less data to the public through
the profile document associated with her WebID.

We introduce [=Trusted Agents=], which operate on behalf of Alice with escalated
privileges to help her securely manage her data and make informed, intuitive,
and secure decisions.

Authorization is performed using regular [[WAC]]. For added security,
and as the replacement for the current “trusted apps” mechanism, we
utilize a newly proposed predicate to a [[WAC]] authorization statement that can
identify authorized client applications in addition to authorized agents using
the application equivalent of a WebID.

Most importantly, this proposal can work with Solid as it exists today, on its
own or alongside other conventions, keeping in mind the following
considerations:

* Identifying the Application ID in WAC rules requires WAC extension and IdP
    support. The approach still works without that, but you would no longer be
    able to constrain access by application, which reduces the overall strength
    of the data boundaries.
* Requires on-pod shape validation for durable interoperability
* Doesn’t require the server to perform shape tree validation, though more
    reliable and durable interoperability would be achieved with server-side
    support.

<div class="note">

**Note: Compartmentalizing data between Client Applications**

Throughout this proposal, we see cases where Alice compartmentalizes access
to her data based on who is accessing it -
*the authenticated agent*, and in certain cases, the application they're
using to do so - *the client application*. Limiting access to data based on
the client application in use is only reliable in certain instances when
the client application can be identified with confidence.

**Identifying clients**

Clients applications in use across the world today fall into two buckets;
*strongly identifiable* and *weakly identifiable*.

**Strongly identifiable clients** can be identified by 3rd parties independently
from their user/controller. Only server-side web apps are strongly identifiable.
As confidential clients, they can keep secrets and can present attestations
and third-party credentials via DNS / domain certificates.

**Weakly identifiable clients** include in-browser JS apps and native desktop
or mobile applications. They are considered weakly identifiable because they
are not able to keep secrets on an instance level. They are often referred to
as public clients. Native apps should be strongly-identifiable in theory
(since they are able to keep secrets on an instance level), but not in
practice because the OS manufacturers do not make their trust
infrastructure available. *Weakly identifiable clients are only strongly
identifiable to the user controlling them*.

**Limiting access by client application**

In the case of a strongly identifiable server-side web application or bot,
the authenticated agent and the client application are the same. The client
application has its own identity that can be strongly authenticated. Alice
chooses which data that client application's identity can access, in the same
way that she chooses which data Bob can access.

In the case of piloted client applications, the ability for a Solid pod to
limit access to data by the client application in use is only as strong as
the trustworthiness of the user piloting that application, and their ability
to avoid using malicious applications. The client identifier can be manipulated
by the user in control of the app. This means that Alice can strongly control
the applications that she uses to compartmentalize her own data, but has
limited ability to control the applications that Bob uses to access the data
she shares with him.

</div>

Trusted Agents {#trusted}
=====================

Some of the most common use cases in Solid revolve around a given
individual using applications to access, utilize, and manage data in
their own pod. In these scenarios, the individual is typically the
*resource controller* of the entire pod, giving them "super-user"
permissions on all of the data within. By extension, the client applications
these individuals pilot operate unchecked with the same elevated privileges

In this proposal, we introduce a pattern that allows
a resource controller to compartmentalize their data between the
different client applications they pilot. As a complement, we also introduce
*Trusted Agents*. A Trusted Agent is an application that acts on someone's
behalf with full privilege, much like their Identity Provider. They can be
trusted to help a resource controller to make smart decisions related to
their data, and even operate or perform actions on the resource controller's
behalf.

There's no limit to what a Trusted Agent can
assist with, but registering applications and authorizing access to
data are two critical operations covered in this proposal.

An trusted agent for application registration helps the resource controller
make smart decisions about the applications they choose to utilize, and
ensure they get provisioned appropriately.

A trusted agent for data authorization is needed in cases where the resource
controller wishes to grant limited access to data in her Pod to another
individual, group, and/or application, but needs assistance to determine
what access is needed, and help to provision that access.

There are three typical patterns to interact with a Trusted Agent;
*Embedded*, *Synchronous*, and *Asynchronous*.

The **Embedded pattern** is employed when the application in question has full
control privileges, and the trusted agent capabilities can
be executed directly. An example of an application that could fall into
this category would be a Pod management application installed by default
by the user’s Pod provider.

The **Synchronous pattern** utilizes a web-based redirect flow much like an
OAuth2 grant flow. The user is redirected to the Trusted Agent URL, with
a callback parameter provided as part of the request. When the
Trusted Agent is finished, it sends the user back to the provided
callback URL. This is an excellent pattern for application registration
and data authorization.

The **Asynchronous pattern** utilizes an event based model, where a message is
sent to the Trusted Agent through some mechanism (direct, pubsub, etc).
This flow is most typical for server-side/bot applications or any piloted
clients that can make use of asynchronous notification processing.

A given Trusted Agent may employ one or more of these patterns.

Use Case Summary {#summary}
=====================

In our use case, Alice wants to use a new application to record and manage both
her personal and professional notes. She does a Web search and finds
NeverNote (https://nevernote.example), a web-based application that advertises
itself as Solid Enabled. Alice is excited about this because she recently
created a Solid Pod for herself at https://alice.pod.example.

We follow Alice (and then Bob) through the following sequence:

1. Alice decides to use a Solid-enabled web application called NeverNote
1. NeverNote checks to see if it has been registered with Alice’s Pod already
1. NeverNote is registered with Alice’s Pod through the help of Alice’s
    Authorization Agent
1. Through the help of her Authorization Agent, Alice grants NeverNote the
    following privileges:
1. Access to Notes that already existed in her Pod
1. Ability to create new Notes that NeverNote will have permission to manage
1. Ability to create new Notebooks that NeverNote will have permission to manage
1. Alice later expands NeverNote’s access to include her Contacts
1. Alice and Bob collaborate on a Notebook in Alice’s Pod. Bob is using a
    different application than NeverNote called OtherNote.

Application Registration {#appreg}
=====================

Issue: Consider incorporating a little bit of text here on *why* it is
important for an application to be registered.

## Checking registration status ## {#reg-status}

When Alice arrives at NeverNote (`https://nevernote.example`) in her
web browser, she is prompted to login with her WebID because NeverNote
doesn’t know who she is yet. She could be a completely new user of
NeverNote, or a returning user that has already registered NeverNote
and authorized it to access her Notebooks and Notes.

Alice logs into her Identity Provider (`https://idp.example`) with her
WebID (`https://alice.pod.example/id#me`) and ultimately ends up with
a bearer token that NeverNote can use to make requests to her Pod.
The token identifies her as Alice (`https://alice.pod.example/id#me`),
using the NeverNote application (`https://nevernote.example/id#agent`).

First NeverNote needs to check Alice’s application registries to see if
there is already an entry for it in one of them. If there is, than
Nevernote is already registered, and doesn't need to go through the process
again. If there is not, NeverNote will engage Alice's trusted application
registration agent to register itself.

### Discovering application registries ### {#reg-discovery}

To discover Alice’s application registry, NeverNote must first dereference
Alice's WebID to access [[#alice-profile]]. In the profile document,
NeverNote will look for a `solid:applicationRegistrySet`.
There are registry sets of varying types listed in [[#alice-profile]].
Each registry set of a given type lists one or more
registries of that type in different locations.

<b>Excerpt from [[#alice-profile]]</b>
<pre highlight="turtle">
  <#me>
    solid:applicationRegistrySet &lt;https://alice.pod.example/registries/application#set&gt;.
</pre>

Alice’s application registry set document is separate from her public profile
document. This allows it to have a separate set of permissions.
Registry set documents are not publicly accessible. They can be accessed
by Alice using any application she likes (such as NeverNote), or by an
autonomous trusted agent where applicable.

NeverNote sees that Alice has a `solid:applicationRegistry` at
`<https://alice.pod.example/applications/>` in [[#alice-appregset]]
document (depicted in the excerpt below).

<b>Excerpt from [[#alice-appregset]] Document</b>
<pre highlight="turtle">
<#set>
  a solid:applicationRegistrySet;
  # Alice only has one application registry. If she had more than one
  # there would be multiple members of the registry set
  solid:registrySetMember &lt;#1b6103ce-c8d7-4b88-b0d1-b9a44ad32f6e&gt;.

# Individual application registry
<#1b6103ce-c8d7-4b88-b0d1-b9a44ad32f6e>
  a solid:applicationRegistry;
  # Where to storage registry data
  solid:registryStorage &lt;https://alice.pod.example/applications/&gt;;
  # Index of applications in the registry
  solid:registryIndex &lt;https://alice.pod.example/applications/index&gt;.
</pre>

### Finding a specific registered application ### {#reg-findapp}

Every registered
application has a `solid:applicationRegistration` entry in a
`solid:applicationRegistry`. NeverNote needs to determine if it is
already registered, so it needs to
find an entry for itself in the `solid:applicationRegistry` at
`<https://alice.pod.example/applications/>`.

Only Alice and her trusted agents should have visibility and control
of her application registry sets and registries. Just because Alice
uses a given application like NeverNote doesn't mean that NeverNote should
be allowed to know every other application she uses.
Consequently, we do not
allow NeverNote to access the
`solid:RegistryIndex`, which links to every
`solid:ApplicationRegistration` entry in the application registry.
Nor do we allow NeverNote to directly access any of the
`solid:applicationRegistration` entries, or to register itself.

We do allow NeverNote (piloted by Alice), to directly access its own
`solid:ApplicationRegistration` entry. However, Nevernote must know how
to find it using information it already has. We solve this by naming
`solid:ApplicationRegistration` containers using a SHA3-256 hash
of the ApplicationID.

Since NeverNote knows its own ApplicationID, it looks for
a SHA3-256 hash of `https://nevernote.example/id#agent` in
`https://alice.pod.example/applications/`.

<pre>
GET https://alice.pod.example/applications/ec0edcd4f8ac00afed60f9929647f65bc87a2aeedf82e4d02f9d4221d9e5c0ae
</pre>

If NeverNote is unable to access that entry, then it knows that it
needs to be registered. If NeverNote can read the
`solid:ApplicationRegistration` entry, then it can confirm that it
is already a registered application in Alice’s Pod.

In this use case, NeverNote cannot access a `solid:ApplicationRegistration`
for itself, which means that it isn't registered. It needs to go through
an application registration workflow, and that must be facilitated through
Alice’s trusted agent for application registration.


## Registering the application ## {#appreg-registration}

NeverNote has determined that it needs to be registered in Alice’s
Pod. It cannot register itself, so it need the help of Alice's trusted
application registration agent. It must first dereference Alice's WebID to
access [[#alice-profile]]. It will then look for her
trusted application registration agent, identified by the
`solid:applicationRegistrationAgent` predicate in the contents
of her profile document.

<b>Excerpt from [[#alice-profile]]</b>
<pre highlight="turtle">
  <#me> solid:applicationRegistrationAgent &lt;https://trusted.example/ar/&gt;.
</pre>

NeverNote redirects Alice via the Synchronous flow to
the `solid:applicationRegistrationAgent` at `https://trusted.example/ar/`,
supplying its ApplicationID
(`https://nevernote.example/id#agent`) as a parameter. The
ApplicationID uniquely identifies the application, and leads to an
RDF document containing information required to complete the
registration process when it is dereferenced.

Issue: Provide a sequence diagram here, and a bit more about what
the end user experience is for Alice in this registration flow.

The trusted application registration agent is now expected to dereference
(i.e. perform an HTTP GET on) the ApplicationID IRI. The contents of
[[#nevernote-profile]]
helps the agent determine whether NeverNote is suitable for
approval.

For example, verification of a verifiable credential
stored in [[#nevernote-profile]], issued by a third party that Alice
trusts is a good indicator of the application’s trustworthiness.
Similarly, an application, or the identity provider it uses, may
be listed on a trusted whitelist that the application registration
agent consults. The application registration agent is able to raise
issues related to these checks (or others) to Alice as part of
her decision making process.

Assuming suitability, and after confirmation from Alice, the
Application Registration Agent will proceed in [[#appreg-creating]] for
NeverNote in Alice’s Pod. When it is finished, it will return her to
NeverNote at the `solid:applicationRegistrationCallback` address in
[[#nevernote-profile]].


<b>Excerpt from [[#nevernote-profile]]:</b>

<pre highlight="turtle">
@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.
@prefix schema: &lt;http://www.schema.org&gt;.

<#agent>
    a schema:softwareApplication;
    solid:applicationRegistrationCallback &lt;https://nevernote.example/app-registration&gt;;
</pre>

### Creating the application registration entry ### {#appreg-creating}

Creating the `solid:applicationRegistration` entry for NeverNote requires
the Application Registration agent to first create and populate
the resources, then update the `solid:registryIndex` to include NeverNote.

Each `solid:applicationRegistration` entry is a container, which allows
important metadata about the application to be stored, and also gives
NeverNote the [[#appreg-privateuse]] that it may need for certain
non-interoperable data important to its own internal functions, but isn’t
pertinent to others.

<b>Excerpt from [[#alice-appregset]] Document</b>
<pre highlight="turtle">
<#1b6103ce-c8d7-4b88-b0d1-b9a44ad32f6e>
  a solid:applicationRegistry;
  # Where to store registry data
  solid:registryStorage &lt;https://alice.pod.example/applications/&gt;;
  # Index of applications in the registry
  solid:registryIndex &lt;https://alice.pod.example/applications/index&gt;.
</pre>

Per the location defined by `solid:RegistryStorage`, NeverNote’s
application space will be provisioned at
`https://alice.pod.example/applications/ec0edcd4f8ac00afed60f9929647f65bc87a2aeedf82e4d02f9d4221d9e5c0ae`,
using the SHA3-256 hash of NeverNote’s ApplicationID
(`https://nevernote.example/id#agent`) to uniquely
identify the space. NeverNote will always know where to find this, because
it knows its own ApplicationID.

The `solid:applicationRegistration` is then created and populated at
`https://alice.pod.example/applications/ec0edcd4f8ac00afed60f9929647f65bc87a2aeedf82e4d02f9d4221d9e5c0ae/application#registration`.

<b>Excerpt from [[#alice-appregnevernote]]</b>
<pre highlight="turtle">
@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#>&gt;.

<#registration>
  a solid:applicationRegistration;
  solid:registeringAgent <https://alice.pod.example/id#me>;
  solid:registeringApplication <https://trusted.example/ar> ;
  solid:applicationID <https://nevernote.example/id#agent>;
  solid:applicationName "NeverNote";
  solid:applicationDescription "Decentralized note management"
  solid:registrationTime "2020-04-04T20:15:47.000Z"^^xsd:dateTime.
</pre>

NeverNote is provided read access to the registration resource
maintained by the registration agent, and read write access to the remainder
of the container. This gives NeverNote as much freedom as it
likes to store data in its own application space, but not the ability
to change permissions or alter the registration data maintained by
the Application Registration Agent.

Issue: Include a shape tree, shapes, and explicit detail on the
access control settings for every resource in the application
registration entry.


* **/applications** - Alice and trusted agents have full control.
    * **index** - Alice and trusted agents have have full control.
    * **ec0edcd4f8ac00afed60f9929647f65bc87a2aeedf82e4d02f9d4221d9e5c0ae** -
        SHA3-256 Hash of NeverNote AppID - NeverNote can read.
        Alice and trusted agents have full control.
          * **application** - application registration resource - NeverNote can read.
              Alice and trusted agents have full control.
          * **..internal application space..** - NeverNote can read and write.
              Alice and trusted agents have full control.


Using the information from the registries document, the Authorization
Agent updates [[#alice-appregindex]] to include NeverNote.

<b>Excerpt from [[#alice-appregnevernote]]</b>
<pre highlight="turtle">
<#f76a2c92-f687-4fd2-9498-83e1c057e35d>
  solid:applicationRegistryMember &lt;https://alice.pod.example/applications/ec0edcd4f8ac00afed60f9929647f65bc87a2aeedf82e4d02f9d4221d9e5c0ae/application#registration&gt;.
</pre>

#### Use of private application space #### {#appreg-privateuse}

There is a legitimate argument that giving applications their own
private data space in Solid is counterintuitive to Solid’s proposition to
decouple data and applications. This is a good argument, and is correct
in the vast majority of cases.

However, there exists certain slices of data that are very specific to
the function of a particular application, and have no value to other
applications. This may include but not be limited to preferences,
configurations, caches, or indexes that are absolutely specific to
that application. Forcing that data into shape trees and shapes meant
to be consumable and interoperable by other applications, stored in the
general data registry, can lead to
frankenstein-like shape trees and shapes that no one wants to use.
Giving applications a private space where they can store data that falls
into this category is therefore a key element in broader interoperability,
because it protects interoperable data from pollution by narrowly
focused elements.

Ultimately, if applications don't want to be interoperable, there's
no reasonable convention that could prevent it. For example, they could
work within the convention but decide to use proprietary vocabularies,
shapes, and shape trees. However, there are motivating factors to
be interoperable, because in doing so they become compatible with a
slew of data that already exists in the ecosystem, including data within
their competitive landscape. Providing a private space allows applications
to separate some internals from the interoperable data so that the
interoperable data is cleaner and more usable. Our belief is that
this helps avoid the creation of application-specific silos. In that
regard, it is a bit like a vaccination.

Because this space is private to an application and not meant to
be interoperable, the application may or may not decide to utilize
data validation facilities like shape trees or shapes.


Use Case Environment {#environment}
=====================

## People ## {#people}

### Alice ### {#alice}

<table>
  <tbody>
    <tr>
      <td><th>Alice's Pod URL</th></td>
      <td>https://alice.pod.example</td>
    </tr>
    <tr>
      <td><th>Alice's WebID</th></td>
      <td>https://alice.pod.example/id#me</td>
    </tr>
  </tbody>
</table>

#### Alice's Pod Hierarchy #### {#alice-pod}

**Resource hierarchy of Alice's pod at https://alice.pod.example:**

Issue: Work out a better style to represent resource trees

Issue: NeverNote's application registry entry should actually be a container
which is NeverNote's private space, with the application registry entry
inside of it. We should use a shape tree to define application registry and
shapes for the registry entries.

Issue: Add an example showing the contents of Alice's data registry resource

Issue: Add an example showing the contents of Alice's app registry resource

<div class = "note">
* **id** - Alice’s profile document
* **registries** - Container for registry listings of various types
    * **application** - Application registries document
    * **data** - Data registries document
    * **access** - Access registries document
    * **remote** - Remote registries document
* **applications** - Registry of application
    * **index** - index of applications in this registry
    * **ec0edcd4f8ac00afed60f9929647f65bc87a2aeedf82e4d02f9d4221d9e5c0ae** -
        application registry entry for NeverNote
* **data** - Registry of data
    * **index** - index of shape trees in this registry
    * **d9e11f42-cd85-4191-a272-c974a54ef602** - Local UUID for Notebook Shape Tree
        * **58c851c1-ef76-4d4b-8868-7472b632bfff** - Notebook Instance UUID
        * **9fdbd6cc-5994-436a-a0d7-aaa87d401e1e** - Notebook Instance UUID
        * **45eb3ead-ceb7-4628-8cd3-e9c0b6555b7a** - Notebook Instance UUID
    * **0d7a50e6-9fe8-4f43-8682-0c990ea46bca** - Local UUID for Note Shape Tree
        * **b94ad7c1-7f15-496c-b36d-e23eb1ba2327** - Note Instance UUID
        * **57c3c536-f997-41cf-95d1-a86a8d04311f** - Note Instance UUID
        * **53fa2198-e88d-4b46-8afa-d975c0882eb3** - Note Instance UUID
        * **a2f0e442-846d-4308-8eb5-5beea8f7f7e7** - Note Instance UUID
        * **3d26e6e5-17b7-437c-bb2b-2998b03b4009** - Note Instance UUID
    * **746dd0ad-9e6e-4e31-8fa3-843d38a9db86** - Local UUID for Contact Shape Tree
        * **aca1c96f-ea89-4965-abec-d46504f75344** - Contact Instance UUID
        * **5f330889-04a7-471f-9df8-f75b99453468** - Contact Instance UUID
        * **e288fd77-ffc6-4747-a0ff-7ad3592abc54** - Contact Instance UUID
        * **f2dcc56d-7ecd-4af5-94bd-c1fb0fc73b6c** - Contact Instance UUID
        * **bfe3493b-d26b-473a-8bca-7884d79c8295** - Contact Instance UUID
* **access** - Alice’s access inbox
    * **9908fb51-e3e6-46ee-b124-86ddbc02bcef** - Access-related Message
    * **1e13e429-84fd-4a6f-8aad-ed68e638cc85** - Access-related Message
* **granted** - Registry of Access Grants
    * **index** - index of access grants in this registry
    * **ce173414-efb5-4971-bb0b-142f94230e9d** - Access Grant Record
    * **13ccb76c-16e2-4c95-9309-430dd22a78bf** - Access Grant Record
    * **502869ad-8a0d-4833-9e47-d27365ec03a1** - Access Grant Record
* **remote** - Registry of remote resources shared with Alice
    * **index** - index of remote resources in this registry
    * **d9e11f42-cd85-4191-a272-c974a54ef602** - Local UUID for Notebook Shape Tree
    * **eb71f9ca-0177-4e19-b35a-0ad20c6ab112** - Reference to instance of Notebook Shape Tree on Tom’s Pod

</div>

#### Alice's Profile Document #### {#alice-profile}

**Contents of Alice’s profile document at
https://alice.pod.example/id#me:**

<pre highlight="turtle">
@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.

<#me>
    solid:oidcIssuer &lt;https://idp.example&gt;;
    solid:applicationRegistrySet &lt;https://alice.pod.example/registries/application#set&gt;;
    solid:dataRegistrySet &lt;https://alice.pod.example/registries/data#set&gt;;
    solid:accessRegistrySet &lt;https://alice.pod.example/registries/access#set&gt;;
    solid:remoteRegistrySet &lt;https://alice.pod.example/registries/remote#set&gt;;
    solid:applicationRegistrationAgent &lt;https://trusted.example/ar/&gt;;
    solid:hasAccessInbox &lt;https://alice.pod.example/access/inbox&gt;.
</pre>

#### Alice's Application Registry Set #### {#alice-appregset}

**Contents of Alice’s application registry set document at
https://alice.pod.example/registries/application:**

<pre highlight="turtle">
@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.

<#set>
  a solid:applicationRegistrySet;
  solid:registrySetMember <#1b6103ce-c8d7-4b88-b0d1-b9a44ad32f6e>.

<#1b6103ce-c8d7-4b88-b0d1-b9a44ad32f6e>
  a solid:applicationRegistry;
  solid:registryStorage &lt;https://alice.pod.example/applications/&gt;;
  solid:registryIndex &lt;https://alice.pod.example/applications/index&gt;.
</pre>

#### Alice's Application Registry Index #### {#alice-appregindex}

**Contents of Alice’s application registry index document at
https://alice.pod.example/applications/index:**

<pre highlight="turtle">
@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.

<#f76a2c92-f687-4fd2-9498-83e1c057e35d>
  solid:applicationRegistryMember &lt;https://alice.pod.example/applications/ec0edcd4f8ac00afed60f9929647f65bc87a2aeedf82e4d02f9d4221d9e5c0ae/application#registration&gt;.
</pre>

#### Alice's Application Registrion for Nevernote #### {#alice-appregnevernote}

**Contents of Alice’s application regitration for NeverNote at
https://alice.pod.example/applications/ec0edcd4f8ac00afed60f9929647f65bc87a2aeedf82e4d02f9d4221d9e5c0ae/application:**

<pre highlight="turtle">
@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#>&gt;.

<#registration>
  a solid:applicationRegistration;
  solid:registeringAgent <https://alice.pod.example/id#me>;
  solid:registeringApplication <https://trusted.example/ar> ;
  solid:applicationID <https://nevernote.example/id#agent>;
  solid:applicationName "NeverNote";
  solid:applicationDescription "Decentralized note management"
  solid:registrationTime "2020-04-04T20:15:47.000Z"^^xsd:dateTime.
</pre>

#### Alice's Data Registry Set #### {#alice-dataregset}

**Contents of Alice’s data registry set document at
https://alice.pod.example/registries/data:**

<pre highlight="turtle">
@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.

<#set>
  a solid:dataRegistrySet;
  solid:registrySetMember <#75139b60-f196-4f47-9ea1-91a21d19fd1e>.

<#75139b60-f196-4f47-9ea1-91a21d19fd1e>
  a solid:dataRegistry;
  solid:registryStorage &lt;https://alice.pod.example/data/&gt;;
  solid:registryIndex &lt;https://alice.pod.example/data/index&gt;.
</pre>

#### Alice's Access Registry Set #### {#alice-accessregset}

**Contents of Alice’s access registry set document at
https://alice.pod.example/registries/access:**

<pre highlight="turtle">
@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.

<#set>
  a solid:accessRegistrySet;
  solid:registrySetMember <#de553f35-232a-4834-ae7f-4b82ec442a42>.

<#de553f35-232a-4834-ae7f-4b82ec442a42>
  a solid:accessRegistry;
  solid:registryStorage &lt;https://alice.pod.example/access/&gt;;
  solid:registryIndex &lt;https://alice.pod.example/access/index&gt;.
</pre>

#### Alice's Remote Registry Set #### {#alice-remoteregset}

**Contents of Alice’s access registry set document at
https://alice.pod.example/registries/remote:**

<pre highlight="turtle">
@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.

<#set>
  a solid:remoteRegistrySet;
  solid:registrySetMember <#53cfc5a4-4854-4438-b0ec-82c7183013e3>.

<#53cfc5a4-4854-4438-b0ec-82c7183013e3>
  a solid:remoteRegistry;
  solid:registryStorage &lt;https://alice.pod.example/remote/&gt;;
  solid:registryIndex &lt;https://alice.pod.example/remote/index&gt;.
</pre>

### Bob ### {#bob}

<table>
  <tbody>
    <tr>
      <td><th>Bob's Pod URL</th></td>
      <td>https://bob.pod.example</td>
    </tr>
    <tr>
      <td><th>Bob's WebID</th></td>
      <td>https://bob.pod.example/id#me</td>
    </tr>
  </tbody>
</table>

#### Bob's Profile Document #### {#bob-profile}

**Contents of Bob’s profile document at
https://bob.pod.example/id#me:**

<pre highlight="turtle">
@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.

<#me>
    solid:oidcIssuer &lt;https://idp.example&gt;;
    solid:registrySet &lt;https://bob.pod.example/registries/application#set&gt;;
    solid:registrySet &lt;https://bob.pod.example/registries/data#set&gt;;
    solid:registrySet &lt;https://bob.pod.example/registries/access#set&gt;;
    solid:registrySet &lt;https://bob.pod.example/registries/remote#set&gt;;
    solid:applicationRegistrationAgent &lt;https://trusted.example/ar/&gt;;
    solid:hasAccessInbox &lt;https://bob.pod.example/access/inbox&gt;.
</pre>

## Applications ## {#applications}

### NeverNote ### {#nevernote}

<table>
  <tbody>
    <tr>
      <td><th>Application URL</th></td>
      <td>https://nevernote.example</td>
    </tr>
    <tr>
      <td><th>Application ID (AppID)</th></td>
      <td>https://nevernote.example/id#agent</td>
    </tr>
    <tr>
      <td><th>SHA3-256 Hash of AppID</th></td>
      <td>ec0edcd4f8ac00afed60f9929647f65bc87a2aeedf82e4d02f9d4221d9e5c0ae</td>
    </tr>
  </tbody>
</table>

#### NeverNote's Profile Document #### {#nevernote-profile}

**Contents of NeverNote’s Profile Document at
https://nevernote.example/id#agent:**

Issue: We may want a more robust description of application type than only
schema:softwareApplication, especially given the different types of client and
their associated security considerations.

<pre highlight="turtle">
@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.
@prefix acl: &lt;http://www.w3.org/ns/auth/acl&gt;.
@prefix schema: &lt;http://www.schema.org&gt;.

<#agent>
    # this is an application, not a person
    a schema:softwareApplication;
    # redirect to this URL after going through authorization agent workflow
    solid:authorizationCallback <https://nevernote.example/data-authorization>;
    # redirect to this URL after going through application registration
    # agent workflow
    solid:applicationRegistrationCallback <https://nevernote.example/app-registration>;

# Declaration of the type of access this application needs
# UUID randomly generated for subject value
<#33116309-1667-4a7b-a91f-4dbf177e3f95>
    a solid:accessNeed;
    # Access needs related to notebook shape trees
    solid:shapetree <https://shapetrees.example/notebook#shapetree>;
    # Request permission create new notebook shape trees
    solid:shapetreeCreate true;
    # Request permission to read and write created notebook shape trees
    solid:shapetreeCreateAccess [ acl:Read, acl:Write ];
    # Request access to any existing notebook shape trees
    solid:shapetreeExistingAccess true;
    # Request permission to read and write existing notebook shape trees
    solid:shapetreeExistingAccess [ acl:Read, acl:Write ].

<#75054942-b8b4-4e3a-84e4-7b564ca1ae7a>
    a solid:accessNeed;
    solid:shapetree <https://shapetrees.example/note>;
    solid:shapetreeCreate true;
    solid:shapetreeCreateAccess [ acl:Read, acl:Write ];
    solid:shapetreeExistingAccess true;
    solid:shapetreeExistingAccess [ acl:Read, acl:Write ].
</pre>

### OtherNote ### {#othernote}

#### OtherNote's Profile Document #### {#othernote-profile}

**Contents of OtherNote’s Profile Document at
https://othernote.example/id#agent:**

Issue: Might be worthwhile to make OtherNote's access needs slightly different
than NeverNote's to show more diversity.

<pre highlight="turtle">
@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.
@prefix acl: &lt;http://www.w3.org/ns/auth/acl&gt;.
@prefix schema: &lt;http://www.schema.org&gt;.

<#agent>
    # this is an application, not a person
    a schema:softwareApplication;
    # redirect to this URL after going through trusted agent workflows
    solid:authorizationCallback <https://othernote.example/callback>;

# Declaration of the type of access this application needs
# UUID randomly generated for subject value
<#df56606d-ce80-4c99-bf8f-88c87559f8b7>
    a solid:accessNeed;
    solid:shapetree <https://shapetrees.example/notebook#shapetree>;
    solid:shapetreeCreate true;
    solid:shapetreeCreateAccess [ acl:Read, acl:Write ];
    solid:shapetreeExistingAccess true;
    solid:shapetreeExistingAccess [ acl:Read, acl:Write ].

<#759a272e-05d9-415e-a460-20acbdcab9b8>
    a solid:accessNeed;
    solid:shapetree <https://shapetrees.example/note>;
    solid:shapetreeCreate true;
    solid:shapetreeCreateAccess [ acl:Read, acl:Write ];
    solid:shapetreeExistingAccess true;
    solid:shapetreeExistingAccess [ acl:Read, acl:Write ].
</pre>

## Shape Trees ## {#shapetrees}

Issue: Include the entire document for https://shapetrees.example/commonnote

### Notebook Shape Tree ### {#notebook}

<table>
  <tbody>
    <tr>
      <td><th>Notebook Shape Tree URL</th></td>
      <td>https://shapetrees.example/commonnote#notebook</td>
    </tr>
  </tbody>
</table>

<pre highlight="turtle">
<#notebook> tree:type ldp:Resource ;
  tree:uriTemplate "{notebookName}" ;
  tree:shape &lt;https://shapes.example/commonnote#notebook&gt;;
  tree:uses &lt;https://shapetrees.example/commonnote#note&gt;.
</pre>

### Note Shape Tree ### {#note}

<table>
  <tbody>
    <tr>
      <td><th>Note Shape Tree URL</th></td>
      <td>https://shapetrees.example/commonnote#note</td>
    </tr>
  </tbody>
</table>

<pre highlight="turtle">
<#note> tree:expectedType ldp:Container;
  tree:uriTemplate "{noteName}";
  tree:shape <https://shapes.example/commonnote#note>;
  tree:contents &lt;https://shapetrees.example/commonnote#citation&gt;,
                &lt;https://shapetrees.example/commonnote#image&gt;.
</pre>

### Contact Shape Tree ### {#contact}

Issue: Add definition for contact shape tree

<pre class=biblio>
{
  "problems-and-goals": {
    "href": "https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md",
    "title": "Problems and Goals for Interoperability, Collaboration, and Security in a Solid Pod",
    "authors": [
      "Justin Bingham",
      "Eric Prud'hommeaux",
      "Jamie Fiedler",
      "Josh Collins"
    ]
  },
  "shapetrees": {
    "href": "https://shapetrees.org",
    "title": "Shape Trees",
    "authors": [
      "Justin Bingham",
      "Eric Prud'hommeaux",
      "Jamie Fiedler",
      "Josh Collins"
    ]
  },
  "wac": {
    "href": "https://solid.github.io/specification/wac/",
    "title": "Web Access Control"
  }
}
</pre>
