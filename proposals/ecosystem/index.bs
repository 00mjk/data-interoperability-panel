<pre class="metadata">
Title: Solid Application Interoperability
Shortname: interop
Level: 1
Max ToC Depth: 2
Status: w3c/ED
Group: w3c
URL: https://solid.github.io/data-interoperability-panel/ecosystem/
Editor: Justin Bingham
Editor: Eric Prud'hommeaux
Editor: Josh Collins
Markup Shorthands: markdown yes
Abstract:
  A proposal for a Solid ecosystem that supports data interoperability across
  applications while enabling secure collaboration and query using intuitive
  data boundaries without changing the fundamentals of Solid, presented in the
  form of an end-to-end use case.
</pre>

<!-- For bikeshed style overrides -->
<style>
table.permissions thead tr {
  font-size: 12px;
}

table.permissions tbody tr:nth-child(even) {
  background-color: lightgray;
  font-size: 10px;
}

table.permissions tbody td {
  font-size: 10px;
}

table.classinfo thead tr th[colspan] {
  text-align: left;
  font-size: 15px;
}

table.classinfo thead tr th {
  text-align: left;
  font-size: 14px;
}

table.classinfo tbody tr:nth-child(odd) {
  background-color: lightgray;
  font-size: 12px;
}

table.classinfo tbody tr td {
  font-size: 12px;
}

table.tree thead tr {
  font-size: 14px;
}

table.tree tbody tr:nth-child(even) {
  background-color: lightgray;
  font-size: 14px;
}

table.tree tbody td {
  font-size: 12px;
}

pre {
  font-size: .8em;
}

figcaption {
  text-align: left;
}

a[data-link-type=dfn] {
  color: #000000;
}

a[href*=".ttl"] {
  color: #339966;
  border-bottom: 1px solid #339966;
}

a[href^="#class"] {
  color: #339966;
  border-bottom: 1px solid #339966;
}

a.vocab {
  color: #339966;
  border-bottom: 1px solid #339966;
}

a[href*=".shex"] {
  color: #cc2900;
  border-bottom: 1px solid #cc2900;
}

a[href^="#shex"] {
  color: #cc2900;
  border-bottom: 1px solid #cc2900;
}

a[href*=".tree"] {
  color: #e68a00;
  border-bottom: 1px solid #e68a00;
}

a[href^="#tree"] {
  color: #e68a00;
  border-bottom: 1px solid #e68a00;
}

em.rfc2119 {
  text-transform: lowercase;
  font-variant: small-caps;
  font-style: normal;
  font-size: 18px;
  color: #900;
}

</style>

<div boilerplate="copyright">
MIT License Copyright 2019 - 2020 W3C Solid Community Group
</div>

Problems and Goals {#problems-goals}
=====================

Solid affords us the opportunity to create a valuable and
powerful ecosystem where people and organizations retain control of their data,
but are also able to put it to work and use it to its full potential. The
fundamentals of Solid make this possible, but further definition of standard
methods and mechanisms must be established to make it practical, intuitive, and
secure.

<div class="assertion">

[Problem #1](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-1---disparate-applications-cannot-practically-interoperate-over-the-same-data-safely-and-effectively) -
    Disparate applications cannot practically interoperate over the same data
    safely and effectively.

* <b>[Goal](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-1---seamless-data-interoperability-across-disparate-applications) -
    Seamless data interoperability across disparate applications.</b>

[Problem #2](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-2---people-must-be-able-to-understand-what-data-they-have-to-effectively-use-it-or-share-it-safely) -
    People must be able to understand what data they have to effectively use it
    or share it safely.

* <b>[Goal](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-2---use-intuitive-data-boundaries-to-provide-human-to-machine-interoperability) -
    Use intuitive data boundaries to provide human to machine interoperability.</b>

[Problem #3](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-3---disparate-entities-using-different-applications-must-be-able-to-safely-and-effectively-interoperate-within-their-scope-of-authorization) -
    Disparate entities using different applications must be able to
    safely and effectively interoperate within their scope of authorization.

* <b>[Goal](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-3---secure-collaboration-over-intuitive-data-boundaries) -
    Secure collaboration over intuitive data boundaries.</b>

[Problem #4](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-4---people-shouldnt-need-to-think-about-how-to-physically-organize-their-data-to-use-solid) -
    People shouldn’t need to think about how to physically organize
    their data to use Solid.

* <b>[Goal](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-4---standard-and-flexible-organizing-model-for-data) -
    Standard and flexible organizing model for data.</b>

[Problem #5](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-5---when-data-is-stored-and-secure-it-should-be-queryable-using-any-mechanism-and-able-to-be-requested-in-different-representations) -
    When data is stored and secure, it should be queryable using any
    mechanism, and able to be requested in different representations.

* <b>[Goal](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-5---flexibility-and-support-for-different-and-evolving-query-mechanisms) -
    Flexibility and support for different and evolving query mechanisms.</b>

[Problem #6](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#problem-6---these-problems-must-be-solvable-using-the-fundamentals-of-solid-as-it-exists-today) -
    These problems must be solvable using the fundamentals of Solid
    as it exists today.

* <b>[Goal](https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md#goal-6---optimize-and-extend-but-do-not-change-solid-fundamentals) -
    Optimize and extend, but do not change Solid fundamentals.</b>

</div>

We must be able to support data interoperability across applications while
enabling secure collaboration and query using intuitive data boundaries.

Diversity in how the same data will be accessed and manipulated by different
entities and applications exacerbates the need for reliable mechanisms that
protect against data corruption, data leakage, or broken workflows

Standard methods and mechanisms for interoperability, collaboration, and
security of data in a Solid Pod must realize these needs, and it must be done
without changing the fundamentals of Solid.

Note: See [[PROBLEMS-AND-GOALS]] for a detailed explanation of each discrete
problem.

Proposal {#proposal}
=====================

In this proposal, we aim to address the stated problems and associated goals
by providing straightforward patterns that can be used in concert to realize
an interoperable [=ecosystem=] for [=Solid=]. To aid in understanding,
we include a reference use case that incorporates key elements of the proposal
in context for the reader.

We introduce [=shape trees=] as a fundamental means through which we model,
validate, organize, and authorize data stored in a Solid [=pod=]. Data becomes
durable, interoperable, and available to be retrieved in different
representations or discovered through any query mechanism.

Nowhere in this proposal does an [=agent=] or
[=application=] need to worry about where to store data, or where to find it.
Data is organized and shared using intuitive data boundaries
provided by [=shape trees=], making it easy for Alice, Bob, and their respective
applications to interoperate with each other in a way that they all understand.
In concert with [=acl resources=], this organization scheme facilitates
straightforward compartmentalized access by [=authenticated agents=] and
[=applications=], and allows them to operate using the least amount of
privilege necessary to complete their tasks.


We introduce patterns for [[#appreg|registering applications]], authorizing
access to data, keeping track of access grants, and of remote resources
for which access has been granted to the [=Agent=].
[=trusted agents|Trusted Agents=] perform important actions for the
[=Agent=] with escalated privileges to help her securely
manage her data and make informed, intuitive, and secure decisions.

Most importantly, this proposal can work with Solid as it exists today, on its
own or alongside other conventions, with some caveats.

<div class="assertion">

* Identifying the [=ApplicationID=] in an [=acl resource=] statement
    requires [[WAC]] extension and IdP support. This proposal still works
    without this, but you would no longer be able to compartmentalize
    access between [=user-piloted applications=] in use by the
    [=Agent=].
* This proposal assumes support for [=shape=] validation on the [=Solid=]
    server. It will still work without this support, but will significantly
    hamper data durability, integrity, and interoperability. Similarly,
    it doesn't require the server to perform [=shape tree=] validation,
    but more reliable and durable interoperability would be achieved with
    server-side support.

</div>

Agent {#ecoagent}
=====================

## Overview ## {#agent-overview}

An [=Agent=] is a distinct individual, group, or piece of
software with an identity that can be strongly authenticated. They are
the primary actors in the Solid [=ecosystem=].

Agents have [=identities=], and dereferencing those identities leads
to [=identity profile documents=] that let other agents and applications
participating in the ecosystem know how to interact with them.

Even the applications that the agent uses directly find their way to
the agent's data through the agent's identity.

Agents are represented by the `eco:Agent` class.

Issue: Expand this text further to demonstrate the association with the
traditional identity profile document when dereferencing a webid, with
data model, structure/validation, and perms.

Registrar {#reg}
=====================

## Overview ## {#registrar-overview}

A [=Registrar=] provides [=Registries=] where an [=Agent=] can register,
store, and lookup essential data needed to participate in the ecosystem.
It supports key functions like application registration,
organizing and tracking data, and more.

* [[#appreg]] uses [=Application Registries=] to manage
    [=Application Registrations=].
* Data Registration relies on data registries to organize,
    store, and find registered data.
* Access registries let agents track and communicate access grants to
    resources they control.
* Agents track and manage data that has been shared with them through
    remote registries.


## Registrar Data Model ## {#reg-model}

<figure>
  <img src="diagrams/registrar-model.svg" width=100%/>
  <figcaption align="center">Top level registrar data model</figcaption>
</figure>


Humans, software, or device [=Agents=] participating in the Solid ecosystem
are represented by the class [eco:Agent](ecosystem.ttl#Agent). Each
[=Agent=] has a [=Registrar=], represented by the class
[eco:Registrar](ecosystem.ttl#Registrar).

<figure>
  <figcaption>[=Agent=] at https://alice.pod.example/profile/id#me linking to
  [=Registrar=]</figcaption>
  <pre highlight="turtle">
  <#me>
    a eco:Agent;
    eco:hasRegistrar &lt;https://alice.pod.example/registries/#registrar&gt; .
  </pre>
</figure>

A [=Registrar=] links to a number of [=Registry Sets=]. [=Registry Sets=] are
represented by the class [eco:RegistrySet](ecosystem.ttl#RegistrySet).
They are collections of one or more linked [=Registries=]. They are almost
always focused on a single [=Registry=] type, through type-specific
subclasses like
[eco:ApplicationRegistrySet](ecosystem.ttl#ApplicationRegistySet).

A given [=Registrar=] is linked to a [=Registry Set=] via the
[eco:hasRegistrySet](ecosystem.ttl#hasRegistrySet) property, or through
type-specific sub-properties like
[eco:hasApplicationRegistrySet](ecosystem.ttl#hasApplicationRegistrySet).

<figure>
  <figcaption>[=Registrar=] at
  https://alice.pod.example/registries/#registrar linking to
  [=Registry Sets=]</figcaption>
  <pre highlight="turtle">
  <#registrar>
    a eco:Registrar;
    eco:hasApplicationRegistrySet &lt;https://alice.pod.example/registries/application#set&gt; ;
    eco:hasDataRegistrySet &lt;https://alice.pod.example/registries/data#set&gt; .
  </pre>
  </figure>
</figure>

A [=Registry=] is a place where an [=Agent=] can register, store, and lookup
essential data needed to participate in the [=ecosystem=]. It is represented
by the [eco:Registry](ecosystem.ttl#Registry) class.

A given [=Registry Set=] links to any number of [=Registries=] via the
[eco:hasRegistry](ecosystem.ttl#hasRegistry) property.

This applies to type-specific to subclasses as well. For example, an
[=Application Registry Set=] links to any number of [=Application Registries=]
via the same [eco:hasRegistry](ecosystem.ttl#hasRegistry) property.

<figure>
  <figcaption>[=Application Registry Set=] linking to two different
  [=Application Registries=]</figcaption>
  <pre highlight="turtle">
  <#set>
    a eco:ApplicationRegistrySet;
    eco:hasRegistry &lt;https://alice.pod.example/applications/#registry&gt; ,
                    &lt;https://alice.otherpod.example/applications/#registry&gt; .
  </pre>
</figure>

[=Registries=] exist to store and catalog [=Registrations=], each of which
represents an individual unit of information for a given [=Registry=].
[=Registrations=] are represented by the `eco:Registration` class.

A given [=Registry=] links to any number of [=Registrations=] via the
[eco:hasRegistration](ecosystem.ttl#hasRegistration) property.

This applies to type-specific to subclasses as well, which are the normal
mode of use. For example, an
[=Application Registry=] links to any number of [=Application Registrations=]
via the [eco:hasRegistration](ecosystem.ttl#hasRegistration) property.

<figure>
  <figcaption>[=Application Registry=] linking to three
  [=Application Registration=] instances</figcaption>
  <pre highlight="turtle">
  <#registry>
    a eco:ApplicationRegistry ;
    eco:hasRegistration &lt;https://alice.pod.example/applications/02f9d4221d9e5c0ae/#registration&gt ,
                        &lt;https://alice.pod.example/applications/6fe4221d0589d7bde/#registration&gt ,
                        &lt;https://alice.pod.example/applications/543ab04333ba5bcc2/#registration&gt .
  </pre>
</figure>

The properties and associated data of a given [=Registration=]
may vary widely depending on the type of [=Registry=] it is
associated with. However, a number of general properties are inherited from
the base [=Registration=] class
[eco:Registration](ecosystem.ttl#Registration). In the following
example, all properties except for
[eco:registeredApplication](ecosystem.ttl#registeredApplication)
are inherited from
[eco:Registration](ecosystem.ttl#Registration).

<figure>
  <figcaption>An [=Application Registration=] instance</figcaption>
  <pre highlight="turtle" line-highlight="5" line-numbers="true">
  <#registration>
    a eco:ApplicationRegistration ;
    eco:registeredBy &lt;https://alice.pod.example/profile/id#me&gt; ;
    eco:registeredWith &lt;https://trusted.example/ar&gt; ;
    eco:registeredApplication &lt;https://nevernote.example/id#agent&gt; ;
    eco:registeredAt "2020-04-04T20:15:47.000Z"^^xsd:dateTime .
  </pre>
</figure>

## Structure and Validation ## {#reg-structure}

Instances of the classes and properties in the [[#reg-model]]
are organized across different resources and pods for a given [=Agent=]
participating in the [=ecosystem=]. The instance data in resources are
validated by [=shapes=], which are associated with those resources
through [=shape trees=].

<figure>
  <figcaption>Example [=Registrar=] structure for an [=Agent=].
  Excludes some [=Registry=] types for clarity.</figcaption>
  <img src="diagrams/registrar-tree.svg" width=100%/>
</figure>

The [=Registrar=] linked to an [=Agent=]
is discovered by dereferencing their [=identity=]
(e.g. `https://alice.pod.example/profile/id#me`) to access their
[=identity profile document=], represented in
the figure above as `/id`.

The [=Registrar=] is stored in the RDF graph of the
`/registeries` container at `https://alice.pod.example/registries/#registrar`.
The [=Registrar=] instance links to a collection of type-specific
[=Registry Set=] instances stored in the `/registries` container.

The shape tree [ecot:registrar-tree](ecosystem.tree#registrar-tree)
associated with the `/registries` container
specifies this resource structure. It assigns the
[ecos:RegistrarShape](ecosystem.shex#RegistrarShape) to validate
a [=Registrar=] instance in the graph of the container resource. It also assigns [ecos:ApplicationRegistrySetShape](ecosystem.shex#ApplicationRegistrySetShape)
and [ecos:DataRegistrySetShape](ecosystem.shex#DataRegistrySetShape)
to validate the
[eco:ApplicationRegistrySet](ecosystem.ttl#ApplicationRegistrySet) and
[eco:DataRegistrySet](ecosystem.ttl#DataRegistrySet)
instances in the contained resources.

<figure>
  <figcaption>[=Shape trees=], [=shapes=], and [=Registry Set=] resources
  associated with a [=Registrar=] container</figcaption>
  <img src="diagrams/registrar-registries.svg" width=100%/>
</figure>

A [=Registry Set=] resource of a specific type will link to one or more
[=Registry=] instances of the same type.

For example, the [=Application Registry Set=] at
`https://alice.pod.example/registries/application#set` links to two
[=Application Registry=] instances, one of them being
`https://alice.pod.example/applications/#registry`.

The [=Application Registry=] instance is stored in the RDF graph
of the `/applications` container at
`https://alice.pod.example/applications/#registry`. It links to a
collection of [=Application Registration=] instances stored in
the `/applications` container.

The shape tree
[ecot:application-registry-tree](ecosystem.tree#application-registry-tree)
associated with the `/applications` container specifies this resource
structure. It assigns the
[ecos:ApplicationRegistryShape](ecosystem.shex#ApplicationRegistryShape)
to validate the [=Application Registry=] instance in the
container resource. It also assigns a
[ecos:ApplicationRegistrationShape](ecosystem.shex#ApplicationRegistrationShape)
to validate an [=Application Registration=] in every
contained resource.

<figure>
  <figcaption>[=Shape trees=], [=shapes=], and [=Application Registration=]
  resources associated with an [=Application Registry=] container</figcaption>
  <img src="diagrams/registrar-applications.svg" width=100%/>
</figure>

## Permission Model ## {#reg-permissions}

The permission model for the [=Registrar=] resources detailed in [[#reg-structure]]
are illustrated in the table below. That said, the following key points
are worth noting:

* The [=identity profile document=] at `/id` is the only resource that is
    publicly accessible (with read-only privileges).
* The only information exposed is a link to Alice's [=Registrar=] at
    `/registries`, which is a protected document.
* Neither the types or locations of Alice's [=Registries=] are
    ever publicly exposed.

The [=Agent=] should be assumed to
have control-level access across her entire data space.

<figure>
<figcaption>Permission model for [=Registrar=] resources</figcaption>
  <table class="data permissions" align="left">
    <col>
    <colgroup></colgroup>
    <colgroup></colgroup>
    <colgroup span=2></colgroup>
    <colgroup span=2></colgroup>
    <thead>
      <tr>
        <th></th>
        <th scope="colgroup">Controller</th>
        <th scope="colgroup">Public</th>
        <th colspan=2 scope="colgroup">Selectively Trusted</th>
        <th colspan=2 scope="colgroup">Selectively Granted</th>
      </tr>
      <tr>
        <th scope="col">Resource</th>
        <th scope="col">Access</th>
        <th scope="col">Access</th>
        <th scope="col">Subject</th>
        <th scope="col">Access</th>
        <th scope="col">Subject</th>
        <th scope="col">Access</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/id`</td>
        <td>Control</td>
        <td>Read</td>
        <td>Identity Agent</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`/registries/`</td>
        <td>Control</td>
        <td>-</td>
        <td>Trusted Agents</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`-- /registries/application`</td>
        <td>Control</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`-- /registries/data`</td>
        <td>Control</td>
        <td>-</td>
        <td>Data Authorization Agent</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`/applications/`</td>
        <td>Control</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`-- /applications/registration-123/`</td>
        <td>Control</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>Registered App.</td>
        <td>Read</td>
      </tr>
      <tr>
        <td>`-- /applications/registration-123/*`</td>
        <td>Control</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>Registered App.</td>
        <td>Write</td>
      </tr>
      <tr>
        <td>`/data/`</td>
        <td>Control</td>
        <td>-</td>
        <td>Data Authorization Agent</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`-- /data/registration-456/`</td>
        <td>Control</td>
        <td>-</td>
        <td>Data Authorization Agent</td>
        <td>Control</td>
        <td>Grantee</td>
        <td>Varies</td>
      </tr>
      <tr>
        <td>`-- /data/registration-456/*`</td>
        <td>Control</td>
        <td>-</td>
        <td>Data Authorization Agent</td>
        <td>Control</td>
        <td>Grantee</td>
        <td>Varies</td>
      </tr>
    </tbody>
  </table>
</figure>

Application Registration {#appreg}
=====================

## Overview ## {#appreg-overview}

Application Registration gives [=Agents=] participating in the Solid
[=ecosystem=] a way to register and track the [=Applications=] they've elected
to use with their data. It also provides each [=Application=] with a place
to store metadata, preferences, access grants, caches, and other internal
data specific to the function of a given [=Application=].

An [=Application Registry=] for storing individual
[=Application Registrations=] is introduced, implemented through the [[#reg]].

## Data Model ## {#appreg-datamodel}

<figure>
  <img src="diagrams/appreg-model.svg" width=100%/>
  <figcaption>Data model for application registration</figcaption>
</figure>

Application Registration extends the [[#reg-model]] with type-specific
subclasses and subproperties.

* An [=Agent=] has a [=Registrar=], which links to
    [=Application Registry Set=] instances.

* An [=Application Registry Set=] links to any number of
    [=Application Registry=] instances via the
    [eco:hasRegistry](ecosystem.ttl#hasRegistry) property.

* An [=Application Registry=] links to any number of
    [=Application Registrations=] via the
    [eco:hasRegistration](ecosystem.ttl#hasRegistration) property.

* An [=Application Registration=] extends the
    [eco:Registration](ecosystem.ttl#Registration)
    class with the
    [eco:ApplicationRegistration](ecosystem.ttl#ApplicationRegistration)
    subclass.

The [eco:ApplicationRegistration](ecosystem.ttl#ApplicationRegistration)
subclass also introduces the following properties:

* [eco:registeredApplication](ecosystem.ttl#registeredApplication) -
    [=ApplicationID=] of the [=Application=] that is being registered.

<figure>
  <figcaption>Instance data for
  an [=Application Registration=] at
  https://alice.pod.example/applications/02f9d4221d9e5c0ae/#registration
  </figcaption>
  <pre highlight="turtle" line-highlight="5" line-numbers="true">
  <#registration>
    a eco:ApplicationRegistration ;
    eco:registeredBy &lt;https://alice.pod.example/profile/id#me&gt; ;
    eco:registeredWith &lt;https://trusted.example/ar&gt; ;
    eco:registeredApplication &lt;https://nevernote.example/id#agent&gt; ;
    eco:registeredAt "2020-04-04T20:15:47.000Z"^^xsd:dateTime .
  </pre>
</figure>

## Structure and Validation ## {#appreg-structure}

A given [=Agent=] will have one or more
[=Application Registries=] discoverable through the
[[#reg-model]], via resources that implement
[[#reg-structure|Registrar Structure and Validation]].

<figure>
  <figcaption>An [=Application Registry=] at
  https://alice.pod.example/applications/#registry</figcaption>
  <img src="diagrams/registrar-applications.svg" width=100%/>
</figure>

The [=Application Registry=] instance data is stored in the RDF graph
of the `/applications` container at
`https://alice.pod.example/applications/#registry`. It links to a
collection of [=Application Registrations=] stored in
the `/applications` container.

The shape tree
[ecot:application-registry-tree](ecosystem.tree#application-registry-tree)
associated with the `/applications` container specifies this resource
structure. It assigns the
[ecos:ApplicationRegistryShape](ecosystem.shex#ApplicationRegistryShape)
to validate the [=Application Registry=] instance data in the
container resource, and says that the container includes instances of
[ecot:application-registration-tree](ecosystem.tree#application-registration-tree),
which any resources added to the `/applications` container must conform to.

Conforming to
[ecot:application-registration-tree](ecosystem.tree#application-registration-tree)
ensures that the container for the [=Application Registry=] at
`/applications#registry` only contains valid [=Application Registrations=].

Specifically:

* Any resource added to the `/applications` container must be a
    container (`st:expectsType st:ShapeTreeContainer`)
* An [=Application Registration=] must be stored in the
    RDF graph of that container, to successfully pass shape validation via
    `st:validatedBy <ecos#ApplicationRegistrationShape>`.

<figure>
  <figcaption>An [=Application Registration=] at
  https://alice.pod.example/applications/02f9d4221d9e5c0ae/#registration
  </figcaption>
  <img src="diagrams/appregistration-structure.svg" width=100%/>
</figure>

These [=Application Registrations=] are associated with container resources
so that the [=Application=] that has been registered
has dedicated space to store data that is very specific to its internal
functions. In the figure above, we can see an application-specific
configuration resource (`config.ttl`) and a summary index file (`summary.idx`).

### Naming application registration resources ### {#appreg-naming}

In this proposal, resource names for ecosystem instances are almost always
randomly generated. However, when creating an
[ecot:application-registration-tree](ecosystem.tree#application-registration-tree)
for an [=Application Registration=], the container
must be named using a SHA-256 hash encoding of the [=ApplicationID=] for the
[=Application=], which is linked through the
[eco:registeredApplication](ecosystem.ttl#registeredApplication) property.

:: <b>NeverNote ApplicationID:</b> `https://nevernote.example/id#agent`
:: <b>SHA-256 Hash:</b> `70e9249113f8aef095626980e82f13833f24a902571502ef726b4d7e69739ba3`

The name of the container for NeverNote's
[=Application Registration=] would be
`70e9249113f8aef095626980e82f13833f24a902571502ef726b4d7e69739ba3`.

There is a reasonable argument for whether or not a one-way hash alogorithm
like SHA-256 is appropriate, as we are primarily using it as a mechanism
for URL encoding to create uniform, opaque resource names,
and the ApplicationID for a given [=Application=]
is publicly shared. However, the use of one-way hash does add a modicum
of additional privacy at a miniscule expense.

Issue: Is it appropriate to use a one-way hash for application registration
resource names. [Github issue](https://github.com/solid/data-interoperability-panel/issues/48)

### Use of internal application space ### {#appreg-internal}

There is a legitimate argument that giving [=Applications=] their own
private data space in Solid is counterintuitive to Solid’s proposition to
decouple data and [=Applications=].

However, there are certain types of data that are very specific to
the function of a particular [=Application=], and have no value to other
[=Applications=]. This may include but not be limited to app-specific
preferences, configurations, caches, or indexes. Forcing that data into
[=shape trees=] and [=shapes=] stored in the data registry that are supposed
to be consumable and interoperable by other [=Applications=] can lead to
frankenstein-like [=shape trees=] and [=shapes=] that no one wants to use.
Giving [=Applications=] a private space where they can store internal data
is therefore a key factor in broad interoperability,
because it protects interoperable data from pollution by narrowly
focused elements.

Ultimately, if [=Applications=] don't want to be interoperable, there's
no reasonable convention that could prevent it. For example, they could
decide to use proprietary vocabularies, [=shapes=], and [=shape trees=].
However, there are motivating factors to
be interoperable, because in doing so they become compatible with a
slew of data that already exists in the [=ecosystem=], including data within
their competitive landscape. Providing a private space allows [=Applications=]
to separate some internals from true interoperable data so that the
interoperable data is cleaner and more usable. Our belief is that
this helps avoid the creation of far-reaching app-specific silos.

Because this space is private to an [=Application=] and not meant to
be interoperable, the [=Application=] may or may not decide to utilize
data validation facilities like [=shape trees=] or [=shapes=].

## Permission Model ## {#appreg-permissions}

There is no public access to any data in an [=Application Registry=].

Only [=Agents=] that have been selectively trusted to assist a
given agent with managing application registration have the ability to manage
contents and permissions across [=Application Registries=],
including the creation and modification of [=Application Registrations=].

A given registered [=Application=] has read access to its
[=Application Registration=], and read/write access to
the data space inside its container. It does not get control privileges.

<figure>
<figcaption>Permission model for [=Application Registry=] resources</figcaption>
  <table class="data permissions" align="left">
    <col>
    <colgroup></colgroup>
    <colgroup></colgroup>
    <colgroup span=2></colgroup>
    <colgroup span=2></colgroup>
    <thead>
      <tr>
        <th></th>
        <th scope="colgroup">Controller</th>
        <th scope="colgroup">Public</th>
        <th colspan=2 scope="colgroup">Selectively Trusted</th>
        <th colspan=2 scope="colgroup">Selectively Granted</th>
      </tr>
      <tr>
        <th scope="col">Resource</th>
        <th scope="col">Access</th>
        <th scope="col">Access</th>
        <th scope="col">Subject</th>
        <th scope="col">Access</th>
        <th scope="col">Subject</th>
        <th scope="col">Access</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/applications/`</td>
        <td>Control</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`-- /applications/02f9d4221d9e5c0ae/`</td>
        <td>Control</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>Registered App.</td>
        <td>Read</td>
      </tr>
      <tr>
        <td>`-- /applications/02f9d4221d9e5c0ae/*`</td>
        <td>Control</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>Registered App.</td>
        <td>Write</td>
      </tr>
      <tr>
        <td>`-- /applications/6fe4221d0589d7bde/`</td>
        <td>Control</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>Registered App.</td>
        <td>Read</td>
      </tr>
      <tr>
        <td>`-- /applications/6fe4221d0589d7bde/*`</td>
        <td>Control</td>
        <td>-</td>
        <td>App. Registration Agent</td>
        <td>Control</td>
        <td>Registered App.</td>
        <td>Write</td>
      </tr>
    </tbody>
  </table>
</figure>

## Looking up an Application Registration ## {#appreg-lookup}

There are a few reasons that different actors might lookup
an [=Application Registration=]:

* The [=Agent=] may want to view or manage their collection of registered
    [=Applications=].
* Another [=trusted agent=] may assist the [=Agent=] with management
    and registration of [=Applications=].
* An [=Application=] may want to see if it has been registered,
    and access its [=Application Registration=]
    if it exists. *This is the most frequently occuring scenario.*

Per the [[#appreg-permissions]], the [=Agent=] and
any [=trusted agents=] for application registration will have access and
visibility across [=Application Registries=] and
[=Application Registrations=]. An
[=Application=] will only have access to its own [=Application Registration=],
in which case it would be linked to that [=Application Registration=] via the
[eco:registeredApplication](ecosystem.ttl#registeredApplication) property.

Since [=Applications=] do not have access to the list of [=Applications=]
in [=Application Registries=], the only way they can check to see if they
are registered is to perform a direct lookup in the addressable space
of each [=Application Registry=] in the [=Application Registry Set=],
using the SHA-256 hash of its [=applicationID=].

<pre>
GET https://alice.pod.example/applications/70e9249113f8aef095626980e82f13833f24a902571502ef726b4d7e69739ba3
</pre>

Inability to access the [=Application Registration=] would be a result of:

* There is no [=Application Registration=] for that
    [=Application=] in the [=Application Registry=].
* There is an [=Application Registration=] at the target URL, but
    it cannot be accessed because it associated with a
    different [=Application=].

In either case, the server may return either a 403 or 404 depending on
server or user privacy preference.

If an [=Application=] can access the
[=Application Registration=], then it can confirm that it
is already a registered [=Application=] for the [=Agent=].

If an [=Application=] is not registered, and would like to be,
it will need to go through the process of [[#appreg-new]].

## Registering an Application ## {#appreg-new}

In almost every case, an [=Application=] will not be permitted
to register itself, and will need the
assistance of a [=trusted agent=] that has been authorized to assist
with application registration for a given [=Agent=].

Issue: Agents that can perform these capabilities will be discoverable
through the registrar. Until that section is written, we'll use a
hard-coded properties associated with the Agent for discovery.

The [=Application=] will look for another
[=Application=] that is linked with the [=Agent=] through the
[eco:trustsForApplicationRegistration](ecosystem.ttl#trustsForApplicationRegistration)
property.

<figure>
  <figcaption>[=Agent=] at https://alice.pod.example/profile/id#me linking to Application
  Registration Agent</figcaption>
  <pre highlight="turtle">
    <#me>
      a eco:Agent;
      eco:trustsForApplicationRegistration &lt;https://trusted.example/ar/&gt; .
  </pre>
</figure>

The [=Application=] will redirect the [=Agent=] via the
synchronous [[#trusted|trusted agent]] pattern to the [=Application=] linked by
[eco:trustsForApplicationRegistration](ecosystem.ttl#trustsForApplicationRegistration),
supplying its [=ApplicationID=] as a parameter.

The [=application registration agent=] is now expected to dereference
(i.e. perform an HTTP GET on) the [=ApplicationID=] to retrieve an
[=application profile document=]. The contents of that document
help the [=Agent=] determine whether that [=Application=] is suitable for
approval.

For example, verification of a verifiable credential
stored in the [=application profile document=], issued by a trusted third party,
is a good indicator of the [=Application’s=] trustworthiness.
Similarly, an [=Application=], or the [=identity provider=] it uses, may
be listed on a trusted whitelist that the [=trusted agent=]
consults. It is able to raise issues related to these checks (or others)
to the [=Agent=] as part of her decision making process.

Assuming suitability and confirmation from the [=Agent=], the
[=application registration agent=] will proceed to create the
[=Application Registration=] for
the [=Application=] in the appropriate [=Application Registry=].
When it is finished, it will return her to
the [=Application=] at the
[eco:applicationRegistrationCallback](ecosystem.ttl#applicationRegistrationCallback)
provided in the application profile document.

### Creating the application registration entry ### {#appreg-creating}

The [=application registration agent=] is responsible for creating
the [=Application Registration=] in conformance with the
documented [[#appreg-structure]] pattern.

Specifically, the
[ecot:application-registration-tree](ecosystem.tree#application-registration-tree)
stipulates that the [=Application Registration=] be a container via
`st:expectsType st:ShapeTreeContainer`.

The [=Application Registration=] must be added to the RDF
graph of that container with a `<#registration>` subject, and pass validation
against the
[ecos:ApplicationRegistrationShape](ecosystem.shex#ApplicationRegistrationShape).

The [=Application Registration's=] properties must be set as follows:

* [eco:registeredBy](ecosystem.ttl#registeredBy): linked to the [=identity=]
    of the [=authenticated agent=] that invoked the registration
    (i.e. the [=webid=] of the [=Agent=])
* [eco:registeredWith](ecosystem.ttl#registeredWith): linked to the
    [=ApplicationID=] of the [=trusted agent=] that facilitated the
    registration, typically the [=application registration agent=].
* [eco:registeredApplication](ecosystem.ttl#registeredApplication): linked to
    the [=ApplicationID=] of the [=Application=] that is being registered.
* [eco:registeredAt](ecosystem.ttl#registeredAt): the `xsd:dateTime` of
    the registration.

<figure>
  <figcaption>Example [=Application Registration=]</figcaption>
  <pre highlight="turtle">
  <#registration>
    a eco:applicationRegistration ;
    eco:registeredBy &lt;https://alice.pod.example/profile/id#me&gt; ;
    eco:registeredWith &lt;https://trusted.example/ar&gt; ;
    eco:registeredApplication &lt;https://nevernote.example/id#agent&gt; ;
    eco:registeredAt "2020-04-04T20:15:47.000Z"^^xsd:dateTime .
  </pre>
</figure>

The [=Application Registration=] container must be named in
accordance with the instructions in [[#appreg-naming]].

The [=Application Registration=] container must be added as a child
member of the [=Application Registry=] container.

Access to the [=Application Registration=] must be set per the
instructions in [[#appreg-permissions]].

The [=Application Registration=] must be associated with the
[=Application Registry=] through the
[eco:hasRegistry](ecosystem.ttl#hasRegistry) property in
the graph of the [=Application Registry=].

Data Registration {#datareg}
=====================

## Overview ## {#datareg-overview}

Data Registration gives [=Agents=] participating in the Solid [=ecosystem=]
a way to register, organize, and subsequently manage the data they control.

A [=Data Registry=] for storing individual [=Data Registrations=] is
introduced, implemented through the [[#reg]].

A given [=Data Registry=] provides a specific location in a Solid [=pod=] where
data of various types is organized and stored in a uniform way to aid
authorization, interoperability, discovery, and more. It avoids complex
hierarchies of data that hinder flexibility and interoperability by
employing a relatively flat hierarchy. This creates natural data boundaries
that make data authorization, amongst other things, extremely intuitive.

A [=Data Registry=] can be used for basic discovery, but it is not
designed nor intended to be an efficient means to query or index data.
However, it is *intended* to be used as reliable source data for different
query engines or indexing schemes.

## Data Model ## {#datareg-model}

<figure id="fig-datareg-model">
  <img src="diagrams/datareg-model.svg" width=100%/>
  <figcaption>Data model for data registration</figcaption>
</figure>

Data Registration extends the [[#reg-model]] with type-specific subclasses
and subproperties.

An [=Agent=] has a [=Registrar=] that links to [=Data Registry Sets=]
via the [eco:hasDataRegistrySet](ecosystem.ttl#hasDataRegistrySet) property.

A [=Data Registry Set=] links to any number of [=Data Registries=] via
the [eco:hasRegistry](ecosystem.ttl#hasRegistry) property.

A [=Data Registry=] links to any number of [=Data Registrations=]
via the [eco:hasRegistration](ecosystem.ttl#hasRegistration) property.

<figure id="fig-datareg-registrar">
  <figcaption>A [=Registrar=] at https://alice.pod.example/registries/#registrar
  linking to a [=Data Registry Set=]</figcaption>
  <pre highlight="turtle">
  <#registrar>
    a eco:Registrar;
    eco:hasDataRegistrySet &lt;https://alice.pod.example/registries/data#set&gt; .
  </pre>
  </figure>
</figure>


<figure id ="fig-datareg-registry-set">
   <figcaption>A [=Data Registry Set=] at
   https://alice.pod.example/registries/data#set linking to two different
  [=Data Registries=]</figcaption>
  <pre highlight="turtle">
  <#set>
    a eco:DataRegistrySet;
    eco:hasRegistry &lt;https://alice.pod.example/data/#registry&gt; ,
                    &lt;https://alice.otherpod.example/data/#registry&gt; .
  </pre>
</figure>

<figure id="fig-datareg-registry">
  <figcaption>A [=Data Registry=] at https://alice.pod.example/data/#registry
  linking to several [=Data Registrations=]</figcaption>
  <pre highlight="turtle">
  <#registry>
    a eco:DataRegistry ;
    eco:hasRegistration &lt;49a4057a-6ade-4a9d-9869-085a00925259/#registration&gt ,
                        &lt;cf2d40d3-858e-42f7-8b11-d021b5989ed2/#registration&gt ,
                        &lt;628a7371-3a9b-49f9-a7aa-2e9c93e0150b/#registration&gt .
  </pre>
</figure>

A [=Data Registration=] extends the
[eco:Registration](ecosystem.ttl#Registration) class with the
[eco:DataRegistration](ecosystem.ttl#DataRegistration) subclass.

A [=Data Registration=] includes any number of [=Registered Data Instances=]
via the
[eco:hasRegisteredDataInstance](ecosystem.ttl#hasRegisteredDataInstance)
property.

The [eco:DataRegistration](ecosystem.ttl#DataRegistration) subclass
extends the [eco:Registration](ecosystem.ttl#Registration) class with
the following properties:

* [eco:registeredShapeTree](ecosystem.ttl#registeredShapeTree) - URI of the
    [=shape tree=] that is being registered.
* [eco:hasRegisteredDataInstance](ecosystem.ttl#hasRegisteredDataInstance) -
    Any number of [=Registered Data Instances=] of the
    [=shape tree=] associated via
    [eco:registeredShapeTree](ecosystem.ttl#registeredShapeTree).


<figure id="fig-datareg-registration">
  <figcaption>A [=Data Registration=] at
  https://alice.pod.example/data/49a4057a-6ade-4a9d-9869-085a00925259/#registration
  linking to several [=Registered Data Instances=]</figcaption>
  <pre highlight="turtle" line-highlight="5" line-numbers="true">
  <#registration>
    a eco:DataRegistration ;
    eco:registeredBy &lt;https://alice.pod.example/profile/id#me&gt; ;
    eco:registeredWith &lt;https://app.example/id#agent&gt; ;
    eco:registeredAt "2020-04-04T20:15:47.000Z"^^xsd:dateTime .
    eco:registeredShapeTree &lt;https://tree.example/commonnote#notebook-tree&gt; ;
    eco:hasRegisteredDataInstance &lt;3f56c32e-96c6-4b0c-b941-eadc2bf98b18/#notebook&gt; ,
                                  &lt;16e1eae9-20a5-489d-8380-8c07ca3805c4/#notebook&gt; ,
                                  &lt;886785d2-6c23-46ee-9e19-5ac36b7bcd71/#notebook&gt; ,
                                  &lt;dae5015c-d5f9-4ede-b9eb-7ca7a19854a9/#notebook&gt; .
    </pre>
</figure>

## Structure and Validation ## {#datareg-structure}

The resources associated with an [=Agent's=] [=Data Registries=] conform
to and extend the general patterns detailed in Registrar [[#reg-structure]].

Consequently, this section focuses on the unique composition and validation of
[=Data Registrations=] in a [=Data Registry=], and the
[=Registered Data Instances=] contained in each [=Data Registration=].

### Structure of Data Registrations in a Data Registry ### {#datareg-registrations-structure}

<figure id="fig-datareg-registry-structure">
  <figcaption>A [=Data Registry=] at
  https://alice.pod.example/data/#registry</figcaption>
  <img src="diagrams/datareg-structure.svg" width=100%/>
</figure>

In the figure above, a [=Data Registry=] instance is stored in the RDF graph
of the `https://alice.pod.example/data/` container at `https://alice.pod.example/data/#registry`. This
[=Data Registry=] contains a set of [=Data Registrations=] (all stored in
the `https://alice.pod.example/data/` container), [as shown](#fig-datareg-registry) in the
previous section.

Each individual [=Data Registration=] is associated with one
[=shape tree=], indicated by the
[eco:registeredShapeTree](ecosystem.ttl#registeredShapeTree) property.

<figure id="fig-datareg-registry-tree">
  <figcaption>Definition of an
  [ecot:data-registry-tree](ecosystem.tree#data-registry-tree)</figcaption>
  <pre highlight="turtle">
  <#data-registry-tree>
    a st:ShapeTree ;
    st:expectsType st:ShapeTreeContainer ;
    st:validatedBy &lt;ecos#DataRegistryShape&gt; ;
    st:contains &lt;#data-registration-tree&gt; ,
                  st:AllowNone .
  </pre>
</figure>

The [ecot:data-registry-tree](ecosystem.tree#data-registry-tree)
defines the resource structure for the [=Data Registry=], and the data
validation rules for the resources inside it.

* It assigns the
    [ecos:DataRegistryShape](ecosystem.shex#DataRegistryShape)
    to validate the [=Data Registry=] instance itself, stored in the
    graph of the container resource, [as shown](#fig-datareg-registry) in the
    previous section
* It says that the container includes instances of
    [ecot:data-registration-tree](ecosystem.tree#data-registration-tree)
* It says through `st:AllowNone` that any resources that do not conform to
    [ecot:data-registration-tree](ecosystem.tree#data-registration-tree) are
    not allowed. This container can *only* contain resources that conform to
    [ecot:data-registration-tree](ecosystem.tree#data-registration-tree).

<figure id="fig-datareg-registration-tree">
  <figcaption>Definition of an
  [ecot:data-registration-tree](ecosystem.tree#data-registration-tree)
  </figcaption>
  <pre highlight="turtle">
  <#data-registration-tree>
    a st:ShapeTree ;
    st:expectsType st:ShapeTreeContainer ;
    st:validatedBy &lt;ecos#DataRegistrationShape&gt; ;
    st:matchesUriTemplate "{id}" .
  </pre>
</figure>

Conforming to
[ecot:data-registration-tree](ecosystem.tree#data-registration-tree)
ensures that the [=Data Registry=] container at
`https://alice.pod.example/data/#registry` only contains valid
[=Data Registrations=].

* Any resource added to the `https://alice.pod.example/data/` container must be
    a container per `st:expectsType st:ShapeTreeContainer`.
* It assigns the
    [ecos:DataRegistrationShape](ecosystem.shex#DataRegistrationShape)
    to ensure there is a valid [=Data Registration=] instance in the
    container resource graph.

### Structure of Registered Data Instances in a Data Registration ### {#datareg-instances-structure}

A given [=Data Registration=] will contain any number of
[=Registered Data Instances=] of the [=shape tree=] associated
via [eco:registeredShapeTree](ecosystem.ttl#registeredShapeTree).

Two complementary [=shape trees=] must be assigned to the same
[=Data Registration=] to ensure:

1. It is a well-formed [=Data Registration=]
2. The [=Data Registration=] only contains [=Registered Data Instances=]
    of [eco:registeredShapeTree](ecosystem.ttl#registeredShapeTree).

<figure>
  <figcaption>A [=Data Registration=] at
  https://alice.pod.example/data/49a4057a-6ade-4a9d-9869-085a00925259/#registration
  </figcaption>
  <img src="diagrams/dataregistration-structure.svg" width=100%/>
</figure>

In the figure above, we can observe the combination of the
[ecot:data-registration-tree](ecosystem.tree#data-registration-tree)
and the [note:note-container-tree](note.tree#note-container-tree) on the
same [=Data Registration=] at
`https://alice.pod.example/data/49a4057a-6ade-4a9d-9869-085a00925259/#registration`.

A [=Data Registration=] can't know which specific
[=shape tree=] will be registered in advance, so the
[ecot:data-registration-tree](ecosystem.tree#data-registration-tree)
can't specify the expected contents of the container with `st:contains`.

However, it is crucial that the contents of the [=Data Registration=] container
be conformant instances of the [=shape tree=] specified in the
[eco:registeredShapeTree](ecosystem.ttl#registeredShapeTree)
property of the [=Data Registration=].

A second [=shape tree=]
([note:note-container-tree](note.tree#note-container-tree) in the example above)
is associated with the [=Data Registration=] to ensure that what is stored
in the container are conformant instances of the
[eco:registeredShapeTree](ecosystem.ttl#registeredShapeTree).

### Naming Registrations and Registered Data Instances ### {#datareg-naming}

The name of the [=Data Registration=] container resource MUST be a
generated \[UUID](https://www.ietf.org/rfc/rfc4122.txt).

The name of a [=Registered Data Instance=] resource linked to a
[=Data Registration=] through
[eco:hasRegisteredDataInstance](ecosystem.ttl#hasRegisteredDataInstance)
MUST be a generated \[UUID](https://www.ietf.org/rfc/rfc4122.txt).

## Permission Model ## {#datareg-permissions}

Almost all of the collaborative use cases between [=Agents=]
in the [=ecosystem=] are based on data furnished through the
[=Data Registry=].

[=Agents=] grant different levels of access to other [=Agents=] on a
case-by-case basis through [[#authz]]. Consequently, a signficant amount
of flexibility is needed in permissioning [=Data Registrations=] and
[=Registered Data Instances=], while at the same time avoiding permission
swamps that become unwieldy to manage.

<figure>
<figcaption>Permission model for [=Data Registry=] resources</figcaption>
  <table class="data permissions" align="left">
    <col>
    <col>
    <colgroup></colgroup>
    <colgroup></colgroup>
    <colgroup span=2></colgroup>
    <colgroup span=2></colgroup>
    <thead>
      <tr>
        <th></th>
        <th></th>
        <th scope="colgroup">Controller</th>
        <th scope="colgroup">Public</th>
        <th colspan=2 scope="colgroup">Selectively Trusted</th>
        <th colspan=2 scope="colgroup">Selectively Granted</th>
      </tr>
      <tr>
        <th scope="col">Resource</th>
        <th scope="col">Type</th>
        <th scope="col">Access</th>
        <th scope="col">Access</th>
        <th scope="col">Subject</th>
        <th scope="col">Access</th>
        <th scope="col">Subject</th>
        <th scope="col">Access</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/data/`</td>
        <td>[=Data Registry=]</td>
        <td>Control</td>
        <td>-</td>
        <td>Authorization Agent</td>
        <td>Control</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr>
        <td>`-- /49a4057a...5259/`</td>
        <td>[=Data Registration=]</td>
        <td>Control</td>
        <td>Varies</td>
        <td>Authorization Agent</td>
        <td>Control</td>
        <td>Grantee</td>
        <td>Varies</td>
      </tr>
      <tr>
        <td>`---- /168997f0...276a/`</td>
        <td>[=Registered Data Instance=]</td>
        <td>Control</td>
        <td>Varies</td>
        <td>Authorization Agent</td>
        <td>Control</td>
        <td>Grantee</td>
        <td>Varies</td>
      </tr>
    </tbody>
  </table>
</figure>

### Access Scopes for Data Registrations ### {#datareg-scopes}

An [=Agent=] specifies the [=Data Registrations=] and
[=Registered Data Instances=] within them that other
[=Agents=] and/or [=Applications=] can access, as well as what that mode
of access will be.

It is imperative that the permission model enable patterns that
allow the [=Agent=] to make intuitive decisions, without
having to directly manipulate [=acl resources=] for individual documents
and containers throughout the [=Data Registry=].

There are two levels of access that must be considered for a given
[=Data Registration=]:

* **All Instances** - Applies to all existing and yet to be created
      [=Registered Data Instances=] within that [=Data Registration=].
* **Specific Instance** - Applies only to specific
      [=Registered Data Instances=] within that [=Data Registration=].

#### Permissions for All Registered Data Instances #### {#datareg-all}

The [=access modes=] listed in the table below can be combined as needed and
granted to a given [=Authorization Subject=].

Issue: WAC doesn't have any mechanism to extend inherited permissions. The
presence of a specific ACL on a resource negates all inherited permissions,
making it impossible to “slightly adjust” or “modify” a resource
while maintaining the permissions inherited for it.

<figure>
<figcaption>Modes of access for a [=Data Registration=]</figcaption>
  <table class="data" align="left">
    <col>
    <col>
    <thead>
      <tr>
        <th scope="col">Mode</th>
        <th scope="col">Resultant Access</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th scope="row">Read</th>
        <td>Can read all existing and yet to be created
            [=Registered Data Instances=]. Includes being able to see the full
            list of [=Registered Data Instances=] in the registration.</td>
      </tr>
      <tr>
        <th scope="row">Write</th>
        <td>Can modify the [=Data Registration=], and all existing
            [=Registered Data Instances=] within it.
            Can create new [=Registered Data Instances=],
            and can delete them.</td>
      </tr>
      <tr>
        <th scope="row">Control</th>
        <td>Can change permissions on the [=Data Registration=], as well
            as any [=Registered Data Instances=] within it.</td>
      </tr>
      <tr>
        <th scope="row">Append</th>
        <td>Can only create new [=Registered Data Instances=] within the
            [=Data Registration=].</td>
      </tr>
      <tr>
        <th scope="row">Created Resource Permissions</th>
        <td>These determine the permissions assigned to
        [=Registered Data Instances=] created by the [=Authorization Subject=],
        when that [=Authorization Subject=] has been granted Write or Append
        [=access modes=].</td>
      </tr>
    </tbody>
  </table>
</figure>

Issue: Identify the scheme through which created resource permissions are
derived if they are not specified explicitly.

Note: Given the current limitations of [[WAC]], specifically the inability
to extend inherited permissions, it is likely that managing permissions
across all [=Registered Data Instances=] of a [=Data Registrations=] will need
to be managed directly in [[#datareg-specific]], rather than inheriting
from the [=Data Registration=].

#### Permissions for a Specific Registered Data Instance #### {#datareg-specific}

The [=access modes=] listed in the table below can be combined as needed and
granted to a given [=Authorization Subject=] for a specific
[=Registered Data Instance=].

<figure>
<figcaption>Modes of access for a Specific
[=Registered Data Instance=]</figcaption>
  <table class="data" align="left">
    <col>
    <col>
    <thead>
      <tr>
        <th scope="col">Mode</th>
        <th scope="col">Resultant Access</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th scope="row">Read</th>
        <td>Can list and read all resources within the
        [=Registered Data Instance=].</td>
      </tr>
      <tr>
        <th scope="row">Write</th>
        <td>Can modify the [=Registered Data Instance=] and any resources
            within it, including creating and deleting resources.</td>
      </tr>
      <tr>
        <th scope="row">Control</th>
        <td>Can change permissions on the [=Registered Data Instance=]
            and any resources within it.</td>
      </tr>
      <tr>
        <th scope="row">Append</th>
        <td>Can create resources within the [=Registered Data Instance=].
            Can add to a resource in the [=Registered Data Instance=] but cannot
            remove anything from it, or delete it.</td>
      </tr>
      <tr>
        <th scope="row">Created Resource Permissions</th>
        <td>These determine the permissions assigned to
        resources within the [=Registered Data Instance=] created by the
        [=Authorization Subject=], when that [=Authorization Subject=] has
        been granted Write or Append [=access modes=].</td>
      </tr>
    </tbody>
  </table>
</figure>

## Registering Data ## {#datareg-registrations}

Registering data in a [=Data Registry=] is primarily concerned with the
following two operations:

* Registering new *data types* as [=Data Registrations=]
* Storing and registering new *instances of those data types* as
    [=Registered Data Instances=]

This section explains the mechanics of those operations.

Note: Managing [=Data Registrations=] and the [=Registered Data Instances=]
contained within them is inextricably linked to permissioning the data
for effective use and secure collaboration. This is covered at length
in [[#authz]].

### Enlisting the help of a trusted agent ### {#datareg-trustedagent}

In almost every case, an [=Application=] will not be trusted to manage
[=Data Registries=], and will need the assistance of a [=trusted agent=]
that has been authorized to assist with data registration for a given [=Agent=].

Untrusted [=Applications=] can enlist the help of the
[=Data Authorization Agent=]
to assist with privileged operations like registering new
[=Data Registrations=] and changing permissions.

The [=Data Authorization Agent=] trusted by a given [=Agent=] is linked
with them through the
[eco:trustsForDataAuthorization](ecosystem.ttl#trustsForDataAuthorization)
property.

<figure>
  <figcaption>[=Agent=] at https://alice.pod.example/profile/id#me linking to Data
  Authorization Agent</figcaption>
  <pre highlight="turtle">
    <#me>
      a eco:Agent;
      eco:trustsForDataAuthorization &lt;https://trusted.example/da/&gt; .
  </pre>
</figure>

An untrusted [=Application=] must work through the trusted
[=Data Authorization Agent=] anytime that [=Data Registrations=] need to be
managed or additional access is needed to the [=Agent's=] data.

Issue: Patterns to interface with Trusted Agents will be detailed
in the Trusted Agents section.

### Creating the data registration entry ### {#datareg-creating}

[=Data Registrations=] must be created in conformance with the
documented [[#datareg-structure]] pattern.

The [ecot:data-registration-tree](ecosystem.tree#data-registration-tree)
must be assigned to the [=Data Registration=] resource.

<figure id="fig-datareg-create-registration-tree">
  <figcaption>Definition of an
  [ecot:data-registration-tree](ecosystem.tree#data-registration-tree)
  </figcaption>
  <pre highlight="turtle">
  <#data-registration-tree>
    a st:ShapeTree ;
    st:expectsType st:ShapeTreeContainer ;
    st:validatedBy &lt;ecos#DataRegistrationShape&gt; ;
    st:matchesUriTemplate "{id}" .
  </pre>
</figure>

The [ecot:data-registration-tree](ecosystem.tree#data-registration-tree)
stipulates the following:

1. The [=Data Registration=] resource must be a container per
    `st:expectsType st:ShapeTreeContainer`.
1. The [=Data Registration=] instance data must be added to the RDF
    graph of that container, and validate successfully
    against the
    [ecos:DataRegistrationShape](ecosystem.shex#DataRegistrationShape).
1.  The [=Data Registration's=] properties must be set as follows:
    * [eco:registeredBy](ecosystem.ttl#registeredBy): linked to the [=identity=]
        of the [=authenticated agent=] that invoked the registration
        (i.e. the [=webid=] of the [=Agent=])
    * [eco:registeredWith](ecosystem.ttl#registeredWith): linked to the
        [=ApplicationID=] of the [=trusted agent=] that facilitated the
        registration, typically the [=data authorization agent=].
    * [eco:registeredAt](ecosystem.ttl#registeredAt): the `xsd:dateTime` of
        the registration.
    * [eco:registeredShapeTree](ecosystem.ttl#registeredShapeTree): URI of the
        [=shape tree=] that is being registered.

The [=shape tree=] associated with the [=Data Registration=] via
[eco:registeredShapeTree](ecosystem.ttl#registeredShapeTree)
must also be assigned to [=Data Registration=] resource,
per the instructions in [[#datareg-structure]]. This ensures that only
instances of that particular shape tree are added to the container.

The [eco:hasRegisteredDataInstance](ecosystem.ttl#hasRegisteredDataInstance)
property is not populated until the first [=Registered Data Instance=] is
added to the [=Data Registration=].

The [=Data Registration=] container must be named in
accordance with the instructions in [[#datareg-naming]].

The [=Data Registration=] container must be added as a child
member of the [=Data Registry=] container.

Access to the [=Data Registration=] must be set per the
instructions in [[#datareg-permissions]].

The [=Data Registration=] must be associated with the
[=Data Registry=] through the
[eco:hasRegistry](ecosystem.ttl#hasRegistry) property in
the graph of the [=Data Registry=].


### Creating registered data instances ### {#datareg-instances}

Creation of [=Registered Data Instances=] is a matter of storing instance
resources in conformance with the
[eco:registeredShapeTree](ecosystem.ttl#registeredShapeTree).

Each new [=Registered Data Instance=] must be linked to the
[=Data Registration=] via
[eco:hasRegisteredDataInstance](ecosystem.ttl#hasRegisteredDataInstance).

Data Authorization {#authz}
=====================

## Overview ## {#authz-overview}

The ability for one [=Agent=] to grant others access to data in their control
is a fundamental element of a collaborative interoperable ecosystem.

Data Authorization represents several key elements that
work together to grant, adjust, and rescind access to data controlled
by an ecosystem participant.

* A common way to express [[#needs]] allows [=ecosystem=] participants to
    convey the types or specific instances of data they require.

* [[#access]] record access decisions made by an [=Agent=] on the data in their
    control.

* [[#receipts]] reflect [=Access Grants=] that one [=Agent=] has provided
    to another [=Agent=]

## Workflows ## {#authz-workflows}

The following workflows represent the authorization patterns
enabled by this specification.

### Application Requests Access ### {#authz-apprequest}

Let `CONTROLLER` be an [=Agent=] that wants to give an
    [=Application=] `APP` access to data in their control.

Let `APP` be the [=Application=] that `CONTROLLER` wishes to use, and must
    grant access to. `APP` may be an [=Application=] that is piloted by the
    [=Agent=], or it may be an autonomous service that operates independently.
    The following workflow applies to both cases.

Let `AUTHZ` be an [=Application=] trusted by the [=Agent=] for
    authorization and access control.

1. `CONTROLLER` decides they'd like to use `APP`
1. `CONTROLLER` provides their [=identity=] to `APP`
1. `APP` dereferences the [=identity=] to
    get `CONTROLLER`'s [=identity profile document=].
1. `APP` discovers that `AUTHZ` is the [=Authorization Agent=] for
    `CONTROLLER` via the [[#trusted-load]] operation.
1. `APP` redirects `CONTROLLER` to `AUTHZ` via the [[#trusted-redirect]]
    operation.
    1. `AUTHZ` looks in `APP`'s [=application profile document=] for
        [=Access Need Groups=] with an `eco:accessScenario` of
        `eco:PersonalAccess`
    1. Any [=Access Need Groups=] found are passed to the [[#access-present]]
        operation, which presents them to `CONTROLLER`.
    1. `CONTROLLER` decides whether to grant `APP` the access requested.
    1. `CONTROLLER` authorizes the requested [=Access Need Groups=]
        and [=Access Needs=]:
        1. The [[#appreg-new|Register Application]] operation is called
            to register `APP` in `CONTROLLER`'s [=Application Registry=].
        1. The [[#access-recordgrant]] operation is invoked
            1. An [=Access Grant=] is stored in `CONTROLLER`'s
                [=Access Registry=].
            1. [[#access-applyperms]] is called to apply permissions based
                on the [=Access Grant=].
            1. [[#receipts-provide]] is called to store the
                [=Access Receipt=]. The Application has set
                `eco:receivesAccessReceipt` to
                `ReceiptInRegistration`, so the [=Access Receipt=] is
                stored in the [=Application Registration=] for `APP`.
    1. `AUTHZ` redirects `CONTROLLER` back to `APP` via the
        [[#trusted-return]] operation.

### Another Agent Requests Access ### {#authz-agentrequest}

Let `REQUESTER` be an [=Agent=] requesting data from another
    [=Agent=] `CONTROLLER` with a known [=identity=].

Let `REQAPP` be an [=Application=] piloted by `REQUESTER`

Let `RAUTHZ` be an [=Application=] trusted by `REQUESTER` for
    authorization and access control.

Let `CONTROLLER` be an [=Agent=] in control of data that
    `REQUESTER` would like to access.

Let `CAUTHZ` be an [=Application=] trusted by `CONTROLLER` for
    authorization and access control.

1. `REQUESTER` would like access to `CONTROLLER`'s data.
1. `REQUESTER` provides `CONTROLLER`'s [=identity=] to `REQAPP`.
1. `REQAPP` dereferences `CONTROLLER`'s [=identity=] to get `CONTROLLER`'s
    [=identity profile document=].
1. `REQAPP` uses [=Access Need Groups=] from its
    [=application profile document=] with an `eco:accessScenario` of
    `eco:SharedAccess` to identify [=Access Need Groups=] to request
    from `CONTROLLER`.
1. `CONTROLLER` has an `eco:receivesAccessReceipt` value of `ReceiptInMessage`
    in their [=identity profile document=].
1. `REQAPP` puts the [=Access Need Groups=] into an [=Access Request=]
    and posts it to the [=Access Inbox=] identified by `eco:hasAccessInbox`
    in the `CONTROLLER`'s [=identity profile document=].
1. `CAUTHZ` monitors `CONTROLLER`'s access inbox autonomously. It notifies
    `CONTROLLER` when a new [=Access Request=] is received.
    1. `CONTROLLER` clicks a link in the notification from `CAUTHZ`,
        opening the `CAUTHZ` user interface and invoking the
        [[#access-present]] operation using the [=Access Need Groups=] from
        the [=Access Request=].
    1. `CONTROLLER` determines whether they wish to grant the access requested.
    1. Assuming `CONTROLLER` authorizes a minimum of the
        required [=Access Need Groups=] and [=Access Needs=],
        the [[#access-recordgrant]] operation is invoked.
    1. [[#access-recordgrant]] stores an [=Access Grant=] in `CONTROLLER`'s
        [=Access Registry=].
        1. [[#access-applyperms]] is called to apply permissions based on the
            [=Access Grant=].
        1. [[#receipts-provide]] is called to deliver the [=Access Receipt=].
            1. `CAUTHZ` dereferences `REQUESTER`'s [=identity=] to get
                `REQUESTER`'s [=identity profile document=].
            1. `REQUESTER` has set `eco:receivesAccessReceipt` to
                `ReceiptInMessage`, so the [=Access Receipt=] is posted
                to the access inbox identified via `hasAccessInbox` in
                `REQUESTER`'s '[=identity profile document=].
1. `RAUTHZ` monitors `REQUESTER`'s access inbox autonomously. It notifies
    `REQUESTER` when a new [=Access Receipt=] is received.
    1. `REQUESTER` clicks the link in the notification, opening the
        `RAUTHZ` user interface and invoking the [[#receipts-present]]
        operation to approve the [=Access Receipt=].
    1. `REQUESTER` accepts the [=Access Receipt=], and `RAUTHZ`
        invokes the [[#receipts-record]] operation.
        1. [[#receipts-record]] is called to store the [=Access Receipt=]
            in `REQUESTER`'s [=Access Receipt Registry=].
        1. [[#remote-update]] is called to update `REQUESTER`'s
            [=Remote Data Registry=] to reflect what is in the
            [=Access Receipt=].

### Controller Shares Access ### {#authz-controllershare}

Let `CONTROLLER` be an [=Agent=] in control of data that
    they would like to authorize `RECEIVER` to access.

Let `CAPP` be an [=Application=] piloted by `CONTROLLER`

Let `CAUTHZ` be an [=Application=] trusted by `CONTROLLER` for
    authorization and access control.

Let `RECEIVER` be an [=Agent=] receiving access to data from another
    [=Agent=] `CONTROLLER`.

Let `RAUTHZ` be an [=Application=] trusted by `RECEIVER` for
    authorization and access control.

1. `CONTROLLER` would like to give `RECEIVER` access to their data.
1. `CONTROLLER` provides `RECEIVER`'s [=identity=] to `CAPP`.
1. `CAPP` dereferences `RECEIVER`'s [=identity=] to get `RECEIVER`'s
    [=identity profile document=].
1. `CAPP` discovers that `CAUTHZ` is the [=Authorization Agent=] for
    `CONTROLLER` via the [[#trusted-load]] operation.
1. `CAPP` redirects `CONTROLLER` to `CAUTHZ` via the [[#trusted-redirect]]
    operation.
    1. `CAUTHZ` looks in `CAPP`'s [=application profile document=] for
        [=Access Need Groups=] with an `eco:accessScenario` of
        `eco:SharedAccess`
    1. Any [=Access Need Groups=] found are passed to the [[#access-present]]
        operation, which presents them to `CONTROLLER`.
    1. `CONTROLLER` authorizes the data to share with `RECEIVER` based on
        the provided [=Access Need Groups=].
        1. The [[#access-recordgrant]] operation is invoked
            1. An [=Access Grant=] is stored in `CONTROLLER`'s
                [=Access Registry=].
            1. [[#access-applyperms]] is called to apply permissions based
                on the [=Access Grant=].
            1. [[#receipts-provide]] is called to store the
                [=Access Receipt=]. `RECEIVER` has set
                `eco:receivesAccessReceipt` to
                `ReceiptInMessage`, so the [=Access Receipt=] is posted
                to the access inbox identified via `hasAccessInbox` in
                `RECEIVER`'s '[=identity profile document=].
    1. `CAUTHZ` redirects `CONTROLLER` back to `CAPP` via the
        [[#trusted-return]] operation.
1. `RAUTHZ` monitors `RECEIVER`'s access inbox autonomously. It notifies
    `RECEIVER` when a new [=Access Receipt=] is received.
    1. `RECEIVER` clicks the link in the notification, opening the
        `RAUTHZ` user interface and invoking the [[#receipts-present]]
        operation to approve the [=Access Receipt=].
    1. `RECEIVER` accepts the [=Access Receipt=], and `RAUTHZ`
        invokes the [[#receipts-record]] operation.
        1. [[#receipts-record]] is called to store the [=Access Receipt=]
            in `RECEIVER`'s [=Access Receipt Registry=].
        1. [[#remote-update]] is called to update `RECEIVER`'s
            [=Remote Data Registry=] to reflect what is in the
            [=Access Receipt=].

### Controller Shares Access with Invited Agent ### {#authz-controllerinvite}

Controlling Agent initiates sharing their data with an Agent that doesn't
have an identity or a pod.

Let `CONTROLLER` be an [=Agent=] in control of data that
    they would like to authorize `INVITEE` to access.

Let `CAPP` be an [=Application=] piloted by `CONTROLLER`

Let `CAUTHZ` be an [=Application=] trusted by `CONTROLLER` for
    authorization and access control.

Let `CISERVICE` be an [=Application=] trusted by `CONTROLLER` to validate
    invitations made to `INVITEE`s.

Let `INVITEE` be a person without an [=identity=] or [=pod=] that `CONTROLLER`
    would like to authorize to access their data. `CONTROLLER` knows their
    e-mail address and mobile phone number.

LET `PROVIDER` be a service that hosts [=identities=] and [=pods=] who
    provisions the same for `INVITEE`

Let `PAUTHZ` be an [=Application=] offered by `PROVIDER` and trusted by
    `INVITEE` for authorization and access control.

1. `CONTROLLER` would like to give `INVITEE` access to their data.
1. `CONTROLLER` provides `INVITEE`'s e-mail address and mobile number to `CAPP`.
1. `CAPP` discovers that `CAUTHZ` is the [=Authorization Agent=] for
    `CONTROLLER` via the [[#trusted-load]] operation.
1. `CAPP` redirects `CONTROLLER` to `CAUTHZ` via the [[#trusted-redirect]]
    operation.
    1. `CAUTHZ` looks in `CAPP`'s [=application profile document=] for
        [=Access Need Groups=] with an `eco:accessScenario` of
        `eco:SharedAccess`
    1. Any [=Access Need Groups=] found are passed to the [[#access-present]]
        operation, which presents them to `CONTROLLER`.
    1. `CONTROLLER` authorizes the data to share with `INVITEE` based on
        the provided [=Access Need Groups=].
        1. The [[#access-recordinvitation]] operation is invoked
            1. An [=Access Invitation=] is stored in `CONTROLLER`'s
                [=Access Registry=].
            1. [[#access-deliverinvitation]] is called to create an
                invitation entry for each [=Access Invitation Channel=] in
                the [=Access Invitation=] with `CISERVICE`
            1. For each [=Access Invitation Channel=] in the
                [=Access Invitation=]
                1. `CISERVICE` sends a notification to `INIVITEE` using the
                    medium associated with the [=Access Invitation Channel=]
                    type
    1. `CAUTHZ` redirects `CONTROLLER` back to `CAPP` via the
        [[#trusted-return]] operation.
1. `INVITEE` receives a notification associated with one of the
    [=Access Invitation Channels=].
    1. `INVITEE` clicks a link in the notification to register an
        identity and pod with `PROVIDER`.
    1. `INVITEE` clicks a link in the notification bringing them to the
        `CISERVICE` user interface to validate the invitation by
        invoking [[#access-validateinvitation]].
        1. If validation is successful, but there are other
            [=Access Invitation Channels=] left to validate, the `INVITEE` will
            be prompted to validate them. Continue until failure or
            validation of all [=Access Invitation Channels=] are succesful.
        1. `CISERVICE` initializes a new [=Access Grant=] via
            [[#access-initialize]], using the contents of
            the [=Access Invitation=], and the new registered
            [=identity=] for `INVITEE`.
        1. `CISERVICE` calls [[#access-recordgrant]] using the
            [=Access Grant=] initialized from the [=Access Invitation=]
            1. An [=Access Grant=] is stored in `CONTROLLER`'s
                [=Access Registry=].
            1. [[#access-applyperms]] is called to apply permissions
                based on the [=Access Grant=].
            1. [[#receipts-provide]] is called to store the
                [=Access Receipt=]. `INVITEE` has set
                `eco:receivesAccessReceipt` to
                `ReceiptInMessage`, so the [=Access Receipt=] is posted
                to the access inbox identified via `hasAccessInbox` in
                `INVITEE`'s '[=identity profile document=].


Issue: Should we assume that CISERVICE is able to manage grants, or should
it need to redirect through the authorization agent? Perhaps the recommendation
should be that they are combined? Bad separation of concerns?

Issue: This doesn't take account a sequencing of validation steps from
one channel to another.

Issue: Should the API for the invitation service be standardized?

Issue: Should the interface for registering and returning from an
    identity provider and/or pod provider be standardized?

Access Needs {#needs}
=====================

## Overview ## {#needs-overview}

[=Agents=] or [=Applications=] in the [=ecosystem=] often require access to
data controlled by some other [=Agent=]. Consequently, a common way to explain
and communicate data needs between participants in the [=ecosystem=] is
required.

A given [=Agent=] or [=Application=] expresses their access needs by
providing one or more [=Access Need Groups=] to the [=Agent=] controlling
the data they require access to. The channels through which these may be
communicated are detailed in [[#authz-workflows]].

The [[#prepare-group]] operation processes each [=Access Need Group=]
received by the controlling [=Agent=]. A [=Prepared Access Need Group=] is
generated for each [=Access Need Group=] that was received.

[=Prepared Access Need Groups=] and the [=Prepared Access Needs=] associated
with them are used as input to the [[#access-present]] operation,
and are stored as part of the [=Access Grant=] by the [[#access-recordgrant]]
operation.

## Data Model ## {#needs-datamodel}

### Summary ### {#needs-datamodel-summary}

An [=Access Need Group=] links to one or more [=Root Access Needs=] via the
[hasAccessNeed](#classAccessNeedGroup) property. When the [[#prepare-group]]
operation follows a [=Root Access Need=], it looks for [=Access Need Overrides=]
linked to the [=Access Need Group=] via
[hasAccessNeedOverride](#classAccessNeedGroup) to change the defaults
inherited from the [=Root Access Need=], or the most recent
[=Access Need Override=].

An [=Access Need=] is associated with one [=shape tree=] via
[eco:registeredShapeTree](#classAccessNeed).

A [=Prepared Access Need Group=] is linked to the [=Access Need Group=] it
was generated from via [fromAccessNeedGroup](#classPreparedAccessNeedGroup).
It links to an [=Access Need Group Decorator=] via
[hasAccessNeedGroupDecorator](#classPreparedAccessNeedGroup).

It links to one or more [=Root Prepared Access Needs=] via
[hasPreparedAccessNeed](#classPreparedAccessNeed). Each
[=Root Prepared Access Need=] represents
a hierarchy of [=Prepared Access Needs=] corresponding with the associated
[=shape tree=].

Each [=Prepared Access Need=] links to child
[=Prepared Access Needs=] via
[referencesPreparedAccessNeed](#classPreparedAccessNeed) or
[skos:narrower](#classPreparedAccessNeed).

An [=Access Need Group=] links to an [=Access Decorator Index=] of
different [=Access Decorator Series=] that explain the [=Access Need Group=]
and [=Access Needs=] in different languages. Each [=Access Decorator Series=]
has one or more [=Access Decorator Versions=] pointing to an
[=Access Decorator Resource=], which contains the actual language-specific
content mappings.



<figure id="fig-access-need-group">
  <figcaption>An [=Access Need Group=] linking to [=Access Needs=]</figcaption>
  <pre highlight="turtle">
  <#notebook-collaboration-group>
    a eco:AccessNeedGroup ;
    eco:accessNecessity eco:AccessRequired ;
    eco:accessScenario eco:PersonalAccess, eco:SharedAccess ;
    eco:authenticatesAs eco:Pilot ;
    eco:hasAccessNeed &lt;#notebook&gt; ;
    eco:hasAccessNeedOverride &lt;#note&gt; ;
    eco:hasAccessDecoratorIndex &lt;notebook-access-decorator-index.ttl&gt; .

  <#notebook>
      a eco:AccessNeed ;
      eco:inAccessNeedGroup &lt;#notebook-collaboration-group&gt; ;
      eco:registeredShapeTree &lt;note:notebook-tree&gt; ;
      eco:recursivelyAuthorize true ;
      eco:accessNecessity eco:AccessRequired ;
      eco:accessMode acl:Read, acl:Write .

  <#note> # Override to stop recursion
      a eco:AccessNeed ;
      eco:inAccessNeedGroup &lt;#notebook-collaboration-group&gt; ;
      eco:registeredShapeTree &lt;note:notebook-tree&gt; ;
      eco:recursivelyAuthorize false ;
      eco:accessNecessity eco:AccessRequired ;
      eco:accessMode acl:Read, acl:Write .
  </pre>
</figure>

<figure id="fig-prepared-access-need-group">
  <figcaption>A [=Prepared Access Need Group=] linking to
  [=Prepared Access Needs=]</figcaption>
  <pre highlight="turtle">
  <#prepared-notebook-collaboration-group>
    a eco:PreparedAccessNeedGroup ;
    eco:fromAccessNeedGroup <#notebook-collaboration-group> ;
    eco:hasAccessNeedGroupDecorator ex:notebook-collaboration-decorator ;
    eco:authenticatesAs eco:Pilot ;
    eco:accessNecessity eco:AccessRequired ;
    eco:accessScenario eco:PersonalAccess, eco:SharedAccess ;
    eco:hasPreparedAccessNeed &lt;#notebook&gt; .

  <#prepared-notebook>
    a eco:PreparedAccessNeed ;
    eco:inPreparedAccessNeedGroup &lt;#prepared-notebook-collaboration-group&gt; ;
    eco:registeredShapeTree note:notebook-tree ;
    eco:hasShapeTreeDecorator note:notebook-decorator&gt; ;
    eco:hasAccessNeedDecorator ex:notebook-need-decorator ;
    eco:accessNecessity eco:AccessRequired ;
    eco:accessMode acl:Read, acl:Write ;
    eco:referencesPreparedAccessNeed <#prepared-note> .

  <#prepared-note>
    a eco:PreparedAccessNeed ;
    eco:inPreparedAccessNeedGroup &lt;#prepared-notebook-collaboration-group&gt; ;
    eco:registeredShapeTree &lt;note:note-tree&gt; ;
    eco:hasShapeTreeDecorator note:note-decorator&gt; ;
    eco:hasAccessNeedDecorator ex:note-need-decorator ;
    eco:accessNecessity eco:AccessRequired ;
    eco:accessMode acl:Read, acl:Write .
  </pre>
</figure>

<figure id="fig-access-need-decorator-index">
  <figcaption>[=Access Decorator Index=] document linked by the
  [#notebook-collaboration-group](#fig-access-need-group)</figcaption>
  <pre highlight="turtle">
  @prefix eco: &lt;http://www.w3.org/ns/solid/ecosystem#&gt; .
  @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

  <>
    a eco:AccessDecoratorIndex ;
    eco:defaultLanguage "en"^^xsd:language ;
    eco:hasSeries &lt;#series-en&gt; .

  <#series-en>
      a eco:AccessDecoratorSeries ;
      eco:usesLanguage "en"^^xsd:language ;
      eco:hasVersion &lt;#en-v10&gt;, &lt;#en-v11&gt; .

  <#en-v10>
      a eco:AccessDecoratorVersion ;
      eco:isVersion "1.0.0" ;
      eco:hasSHA256 "98198123981273981273918273912738" ;
      eco:hasAccessDecoratorResource &lt;notebook-decorator-en-1.0&gt; .

  <#en-v11>
      a eco:AccessDecoratorVersion ;
      eco:isVersion "1.1.0" ;
      eco:hasSHA256 "12312312371273712731872371273712" ;
      eco:hasAccessDecoratorResource &lt;notebook-decorator-en-1.1&gt; .
  </pre>
</figure>

<figure id="fig-access-decorator-resource">
  <figcaption>An [=Access Decorator Resource=] referenced
  by the [Access Need Decorator Index](#fig-access-need-decorator-index)
  </figcaption>
  <pre highlight="turtle">
  @prefix skos: &lt;http://www.w3.org/2004/02/skos/core#&gt; .
  @prefix eco: &lt;http://www.w3.org/ns/solid/ecosystem#&gt; .
  @prefix note: &lt;http://shapetrees.pub/ns/note#&gt; .

  <> a eco:AccessDecoratorResource .

  <#notebook-collaboration-decorator>
    a eco:AccessNeedGroupDecorator ;
    eco:hasAccessNeedGroup &lt;#notebook-collaboration-group&gt; ;
    skos:prefLabel "Collaborate on notes"@en .
    skos:definition "Allowing for full reading and writing of notebooks and notes"@en .

  <#notebook-decorator>
    a eco:AccessNeedDecorator ;
    eco:hasAccessNeedGroup &lt;#notebook-collaboration-group&gt; ;
    eco:registeredShapeTree &lt;note:notebook-tree&gt; ;
    skos:prefLabel "Notebooks can be presented along with a list of their contents and read / written"@en .

  <#note-decorator>
    a eco:AccessNeedDecorator ;
    eco:hasAccessNeedGroup &lt;#notebook-collaboration-group&gt; ;
    eco:registeredShapeTree &lt;note:note-tree&gt; ;
    skos:prefLabel "Notes can be accessed and written"@en .
  </pre>
</figure>

<figure id="fig-access-request">
  <figcaption>An [=Access Request=] sent from one agent to another</figcaption>
  <pre highlight="turtle">
  @prefix eco: &lt;http://www.w3.org/ns/solid/ecosystem#&gt; .
  @prefix note: &lt;http://shapetrees.pub/ns/note#&gt; .

  <> a eco:AccessRequest ;
    eco:fromAgent https://alice.pod.example/profile/id#me ;
    eco:toAgent https://bob.pod.example/profile/id#me ;
    eco:hasAccessNeedGroup <#notebook-collaboration-group> .

  <#notebook-collaboration-group>
    a eco:AccessNeedGroup ;
    eco:accessNecessity eco:AccessRequired ;
    eco:accessScenario eco:PersonalAccess, eco:SharedAccess ;
    eco:authenticatesAs eco:Pilot ;
    eco:hasAccessNeed &lt;#notebook&gt; ;
    eco:hasAccessNeedOverride &lt;#note&gt; ;
    eco:hasAccessDecoratorIndex &lt;notebook-access-decorator-index.ttl&gt; .

  <#notebook>
      a eco:AccessNeed ;
      eco:inAccessNeedGroup &lt;#notebook-collaboration-group&gt; ;
      eco:registeredShapeTree &lt;note:notebook-tree&gt; ;
      eco:recursivelyAuthorize true ;
      eco:accessNecessity eco:AccessRequired ;
      eco:accessMode acl:Read, acl:Write .

  <#note> # Override to stop recursion
      a eco:AccessNeed ;
      eco:inAccessNeedGroup &lt;#notebook-collaboration-group&gt; ;
      eco:registeredShapeTree &lt;note:notebook-tree&gt; ;
      eco:recursivelyAuthorize false ;
      eco:accessNecessity eco:AccessRequired ;
      eco:accessMode acl:Read, acl:Write .
  </pre>
</figure>

### Access Need Group ### {#needs-access-need-group}

An <dfn>Access Need Group</dfn> is a collection of [=Access Needs=]
that a given [=Agent=] and/or [=Application=] uses to communicate a data
access request to other [=Agents=].

Each [=Access Need=] is associated with a specific [=shape tree=],
and [=shape trees=] provide both physical and/or virtual hierarchies.
The [[#prepare-group]] operation starts with each <dfn>Root Access Need</dfn>
linked via `hasAccessNeed`, and traverses the shape tree hierarchy,
creating a [=Prepared Access Need=] at each new [=shape tree=] and
linking them in a tree via `referencesPreparedAccessNeed` or `skos:narrower`.
Each <dfn>Access Need Override</dfn> that it encounters when traversing the
hierarchy applies new inherited defaults, or stops the recursion before
it continues through the remainder of the tree.

<table class="classinfo data" align="left" id="classAccessNeedGroup">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessNeedGroup](ecosystem.ttl#AccessNeedGroup)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>accessNecessity</td>
      <td>`eco:AccessRequired`, `eco:AccessOptional`</td>
      <td>Necessity of the access to the requesting party</td>
    </tr>
    <tr>
      <td>accessScenario</td>
      <td>`eco:PersonalAccess`, `eco:SharedAccess`</td>
      <td>Context in which the access group should be presented</td>
    </tr>
    <tr>
      <td>hasAccessNeed</td>
      <td>[AccessNeed](#classAccessNeed)</td>
      <td>Link to a [=Root Access Need=]</td>
    </tr>
    <tr>
      <td>hasAccessNeedOverride</td>
      <td>[AccessNeed](#classAccessNeed)</td>
      <td>Link to an [=Access Need Override=]</td>
    </tr>
    <tr>
      <td>authenticatesAs</td>
      <td>[=Agent=] or `eco:Pilot`</td>
      <td>[=Agent=] or mode the [=Application=] authenticates as</td>
    </tr>
    <tr>
      <td>hasAccessNeedDecoratorIndex</td>
      <td>-</td>
      <td>Index of [=Acccess Decorator Resources=] to describe
      [=Access Need Group=] and [=Access Needs=]</td>
    </tr>
  </tbody>
</table>

The [AccessNeedGroupShape](#shexAccessNeedGroup) is used to validate an
instance of the [AccessNeedGroup](#classAccessNeedGroup) class.

<pre highlight="turtle" id="shexAccessNeedGroup">
<#AccessNeedGroupShape> {
  a [ eco:AccessNeedGroup ] ;
  eco:accessNecessity [ eco:AccessRequired eco:AccessOptional ] ;
  eco:accessScenario [ eco:PersonalAccess eco:SharedAccess ] ;
  eco:authenticatesAs IRI ;
  eco:hasAccessNeed IRI+ ;
  eco:hasAccessNeedOverride IRI* ;
  eco:hasAccessDecoratorIndex IRI
}
</pre>

### Access Need ### {#needs-access-need}

An <dfn>Access Need</dfn> represents the requirement of one specific type
of data represented by a [=shape tree=], as part of an [=Access Need Group=].

Each [=Access Need=] represents a request to access, create, or manage
all or a subset of [=Registered Data Instances=] associated with a single
[=Data Registration=] for a given [=shape tree=].

Specific [=Registered Data Instances=] may be requested by explicitly
associating them with the [=Access Need=] via
[hasRegisteredDataInstance](#classAccessNeed).

Each [=Access Need=] has one or more [=access modes=], and a property that
indicates the necessity of the [=Access Need=]; *required* or
*optional*. For example, an [=Access Need=] for read access to
[=shape tree=] `N` can be identified as a required item in the
[=Access Need Group=].

[=Access Needs=] are described using language-specific
[=Access Need Decorators=].

<table class="classinfo data" align="left" id="classAccessNeed">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessNeed](ecosystem.ttl#AccessNeed)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>inAccessNeedGroup</td>
      <td>[AccessNeedGroup](#classAccessNeedGroup)</td>
      <td>[=Access Need Group=] that the [=Access Need=] is part of</td>
    </tr>
    <tr>
      <td>registeredShapeTree</td>
      <td>`st:ShapeTree`</td>
      <td>The [=shape tree=] requested by the [=Access Need=]</td>
    </tr>
    <tr>
      <td>hasRegisteredDataInstance</td>
      <td>-</td>
      <td>Request specific [=Registered Data Instances=] of the registered
      [=shape tree=]</td>
    </tr>
    <tr>
      <td>recursivelyAuthorize</td>
      <td>`xsd:boolean`</td>
      <td>
        <ul>
          <li><b>true</b> - continue traversing shape tree hierarchy for
          authorization when true</li>
          <li><b>false</b> - stop traversal</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>accessMode</td>
      <td>`acl:Read, acl:Write, acl:Control, acl:Append`</td>
      <td>Requested modes of access for the [=Access Need=]</td>
    </tr>
    <tr>
      <td>accessNecessity</td>
      <td>`eco:AccessRequired`, `eco:AccessOptional`</td>
      <td>Necessity of the access to the requesting party</td>
    </tr>
  </tbody>
</table>

The [AccessNeedShape](#shexAccessNeed) is used to validate an
instance of the [AccessNeed](#classAccessNeed) class.

<pre highlight="turtle" id="shexAccessNeed">
<#AccessNeedShape> {
  a [ eco:AccessNeed ] ;
  eco:inAccessNeedGroup IRI+ ;
  eco:registeredShapeTree IRI ;
  eco:hasRegisteredDataInstance IRI* ;
  eco:recursivelyAuthorize [ true false ] ;
  eco:accessMode [ acl:Read acl:Write acl:Append acl:Control ]+ ;
  eco:accessNecessity [ eco:AccessRequired eco:AccessOptional ] ;
}
</pre>

### Prepared Access Need Group ### {#needs-prepared-access-need-group}

A <dfn>Prepared Access Need Group</dfn> is output by the [[#prepare-group]]
operation when given an [=Access Need Group=] as input.

Preparing an [=Access Need Group=] includes:

* Getting an [=Access Need Group Decorator=] via [[#get-group-dec]]
* Recursing through the [=shape tree=] hierarchy of each [=Root Access Need=]
    in the [=Access Need Group=], and creating a [=Prepared Access Need=] for
    every [=shape tree=] encountered, applying [=Access Need Overrides=] when
    available.

A <dfn>Root Prepared Access Need</dfn> is the prepared version of the
corresponding [=Root Access Need=] in the source [=Access Need Group=].

<table class="classinfo data" align="left" id="classPreparedAccessNeedGroup">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [PreparedAccessNeedGroup](ecosystem.ttl#PreparedAccessNeedGroup)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>fromAccessNeedGroup</td>
      <td>[AccessNeedGroup](#classAccessNeedGroup)</td>
      <td>The [=Access Need Group=] used to generate the
      [=Prepared Access Need Group=]</td>
    </tr>
    <tr>
      <td>hasAccessNeedGroupDecorator</td>
      <td>[AccessNeedGroupDecorator](#classAccessNeedGroupDecorator)</td>
      <td>An [=Access Need Group Decorator=] that describes this
      [=Prepared Access Need Group=]</td>
    </tr>
    <tr>
      <td>authenticatesAs</td>
      <td>[=Agent=] or `eco:Pilot`</td>
      <td>[=Agent=] or mode the [=Application=] authenticates as</td>
    </tr>
    <tr>
      <td>accessScenario</td>
      <td>`eco:PersonalAccess`, `eco:SharedAccess`</td>
      <td>Context in which the access group should be presented</td>
    </tr>
    <tr>
      <td>accessNecessity</td>
      <td>`eco:AccessRequired`, `eco:AccessOptional`</td>
      <td>Necessity of the access to the requesting party</td>
    </tr>
    <tr>
      <td>hasPreparedAccessNeed</td>
      <td>[PreparedAccessNeed](#classPreparedAccessNeed)</td>
      <td>Link to a [=Root Prepared Access Need=]</td>
    </tr>
  </tbody>
</table>

The [PreparedAccessNeedGroupShape](#shexPreparedAccessNeedGroup) is used to
validate an instance of the
[PreparedAccessNeedGroup](#classPreparedAccessNeedGroup) class.

<pre highlight="turtle" id="shexPreparedAccessNeedGroup">
<#PreparedAccessNeedGroupShape> {
  a [ eco:PreparedAccessNeedGroup ] ;
  eco:fromAccessNeedGroup IRI ;
  eco:hasAccessNeedGroupDecorator IRI ;
  eco:authenticatesAs IRI ;
  eco:accessNecessity [ eco:AccessRequired eco:AccessOptional ] ;
  eco:accessScenario [ eco:PersonalAccess eco:SharedAccess ] ;
  eco:hasPreparedAccessNeed IRI+ ;
}
</pre>

### Prepared Access Need ### {#needs-prepared-access-need}

A <dfn>Prepared Access Need</dfn> is generated by the [[#prepare-group]]
operation as it processes an input [=Access Need Group=]. A
[=Prepared Access Need=] is added to the [=Prepared Access Need Group=]
for every unique [=shape tree=] encountered as the operation traverses the
[=shape tree=] hierarchy.

<table class="classinfo data" align="left" id="classPreparedAccessNeed">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [PreparedAccessNeed](ecosystem.ttl#PreparedAccessNeed)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>inPreparedAccessNeedGroup</td>
      <td>[PreparedAccessNeedGroup](#classPreparedAccessNeedGroup)</td>
      <td>[=Prepared Access Need Group=] the [=Prepared Access Need=] belongs to</td>
    </tr>
    <tr>
      <td>hasShapeTreeDecorator</td>
      <td>`st:ShapeTreeDecorator`</td>
      <td>Decorator associated with the [=shape tree=] that describes the
      name of the shape-tree and what data it represents in the preferred
      language of the [=Agent=]</td>
    </tr>
    <tr>
      <td>hasAccessNeedDecorator</td>
      <td>[AccessNeedDecorator](#classAccessNeedDecorator)</td>
      <td>Decorator that explains the reason for the access need in the
      preferred language of the [=Agent=]</td>
    </tr>
    <tr>
      <td>hasDataGrant</td>
      <td>[DataGrant](#classDataGrant)</td>
      <td>[=Data Grant=] associated with the [=Prepared Access Need=],
      established when the [=Access Grant=] is created</td>
    </tr>
    <tr>
      <td>hasRegisteredDataInstance</td>
      <td>[RegisteredDataInstance](#)</td>
      <td>Links to any specific [=Registered Data Instances=] that were
      included in the original request</td>
    </tr>
    <tr>
      <td>registeredShapeTree</td>
      <td>`st:ShapeTree`</td>
      <td>[=Shape tree=] associated with the [=Prepared Access Need=]</td>
    </tr>
    <tr>
      <td>accessMode</td>
      <td>`acl:Read, acl:Write, acl:Control, acl:Append`</td>
      <td>Requested modes of access for the [=Prepared Access Need=]</td>
    </tr>
    <tr>
      <td>accessNecessity</td>
      <td>`eco:AccessRequired`, `eco:AccessOptional`</td>
      <td>Necessity of the access to the requesting party</td>
    </tr>
    <tr>
      <td>supportedBy</td>
      <td>[PreparedAccessNeed](#classPreparedAccessNeed)</td>
      <td>A [=Prepared Access Need=] whose [=shape tree=] `st:supports` the
      [=shape tree=] of this [=Prepared Access Need=]</td>
    </tr>
    <tr>
      <td>supports</td>
      <td>[PreparedAccessNeed](#classPreparedAccessNeed)</td>
      <td>A [=Prepared Access Need=] that [=shape tree=] of this
      [=Prepared Access Need=] `st:supports`</td>
    </tr>
    <tr>
      <td>referencesPreparedAccessNeed</td>
      <td>[PreparedAccessNeed](#classPreparedAccessNeed)</td>
      <td>The next [=Prepared Access Need=] in a virtual hierarchy</td>
    </tr>
    <tr>
      <td>skos:narrower</td>
      <td>[PreparedAccessNeed](#classPreparedAccessNeed)</td>
      <td>The next [=Prepared Access Need=] in a virtual hierarchy where
      the regular [=shape tree=] hierarchy has been extended to include
      a skos hierarchy.</td>
    </tr>
  </tbody>
</table>

The [PreparedAccessNeedShape](#shexPreparedAccessNeed) is used to
validate an instance of the
[PreparedAccessNeed](#classPreparedAccessNeed) class.

<pre highlight="turtle" id="shexPreparedAccessNeed">
<#PreparedAccessNeedShape> {
  a [ eco:PreparedAccessNeed ] ;
  eco:inPreparedAccessNeedGroup IRI+ ;
  eco:hasShapeTreeDecorator IRI ;
  eco:hasAccessNeedDecorator IRI? ;
  eco:hasDataGrant IRI? ;
  eco:hasRegisteredDataInstance IRI* ;
  eco:registeredShapeTree IRI ;
  eco:accessMode [ acl:Read acl:Write acl:Append acl:Control ]+ ;
  eco:accessNecessity [ eco:AccessRequired eco:AccessOptional ] ;
  eco:supportedBy IRI* ;
  eco:supports IRI
  eco:referencesPreparedAccessNeed IRI* ;
  skos:narrower IRI* ;
}
</pre>

### Access Request ### {#needs-access-request}

An <dfn>Access Request</dfn> is used to send [=Access Need Groups=] from
one [=Agent=] to another.

<table class="classinfo data" align="left" id="classAccessRequest">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessRequest](ecosystem.ttl#AccessRequest)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>fromAgent</td>
      <td>Agent</td>
      <td>The [=Agent=] who sent the [=Access Request=]</td>
    </tr>
    <tr>
      <td>toAgent</td>
      <td>Agent</td>
      <td>The [=Agent=] the [=Access Request=] is meant for</td>
    </tr>
  </tbody>
  <tr>
    <td>hasAccessNeedGroup</td>
    <td>[AccessNeedGroup](#classAccessNeedGroup)</td>
    <td>One or more [=Access Need Groups=] detailing the access requested</td>
  </tr>
</tbody>
</table>

The [AccessRequestShape](#shexAccessRequest) is used to
validate an instance of the
[AccessRequest](#classAccessRequest) class.

<pre highlight="turtle" id="shexAccessRequest">
<#AccessRequestShape> {
  a [eco:AccessRequest] ;
  eco:fromAgent IRI ;             # Agent who sent the receipt
  eco:toAgent IRI ;               # Recipient of the receipt
  eco:hasAccessNeedGroup @<#:AccessNeedGroupShape>+
}
</pre>

### Access Decorator Index ### {#needs-access-decorator-index}

An <dfn>Access Decorator Index</dfn> is a listing of one or more
[=Access Decorator Series=].

<table class="classinfo data" align="left" id="classAccessDecoratorIndex">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessDecoratorIndex](ecosystem.ttl#AccessDecoratorIndex)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>defaultLanguage</td>
      <td>`xsd:language`</td>
      <td>Default language to select if not provided as input</td>
    </tr>
    <tr>
      <td>hasSeries</td>
      <td>[AccessDecoratorSeries](#classAccessDecoratorSeries)</td>
      <td>Link to an [=Access Decorator Series=]</td>
    </tr>
  </tbody>
</table>

The [AccessDecoratorIndexShape](#shexAccessDecoratorIndex) is used to
validate an instance of the [AccessDecoratorIndex](#classAccessDecoratorIndex)
class.

<pre highlight="turtle" id="shexAccessDecoratorIndex">
<#AccessDecoratorIndexShape> {
  a [ eco:AccessDecoratorIndex ] ;
  eco:defaultLanguage xsd:language ;
  eco:hasSeries @AccessDecoratorSeries+ ;
}
</pre>

#### Access Decorator Series #### {#needs-access-decorator-series}

An <dfn>Access Decorator Series</dfn> has one or
more [=Access Decorator Versions=] in a given language.

<table class="classinfo data" align="left" id="classAccessDecoratorSeries">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessDecoratorSeries](ecosystem.ttl#AccessDecoratorSeries)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>usesLanguage</td>
      <td>xsd:language</td>
      <td>Language code associated with the [=Access Decorator Series=]</td>
    </tr>
    <tr>
      <td>hasVersion</td>
      <td>[AccessDecoratorVersion](#classAccessDecoratorVersion)</td>
      <td>Links to an [=Access Decorator Version=] in the series</td>
    </tr>
  </tbody>
</table>

The [AccessDecoratorSeriesShape](#shexAccessDecoratorSeries) is used to
validate an instance of the [AccessDecoratorSeries](#classAccessDecoratorSeries)
class.

<pre highlight="turtle" id="shexAccessDecoratorSeries">
<#AccessDecoratorSeriesShape> {
  a [ eco:AccessDecoratorSeries ] ;
  eco:usesLanguage xsd:language ;
  eco:hasVersion @AccessDecoratorVersion+ ;
}
</pre>

#### Access Decorator Version #### {#needs-access-decorator-version}

An <dfn>Access Decorator Version</dfn> is a versioned instance of
a given [=Access Decorator Resource=].

<table class="classinfo data" align="left" id="classAccessDecoratorVersion">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [PreparedAccessNeedGroup](ecosystem.ttl#PreparedAccessNeedGroup)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>isVersion</td>
      <td>xsd:string</td>
      <td>Semantic version of the [=Access Decorator Resource=] (e.g. "1.1.0")</td>
    </tr>
    <tr>
      <td>hasSHA256</td>
      <td>xsd:string</td>
      <td>SHA-256 hash of the linked [=Access Decorator Resource=]</td>
    </tr>
    <tr>
      <td>hasAccessDecoratorResource</td>
      <td>[AccessDecoratorResource](#classAccessDecoratorResource)</td>
      <td>Links to the actual [=Access Decorator Resource=] document</td>
    </tr>
  </tbody>
</table>

The [AccessDecoratorVersionShape](#shexAccessDecoratorVersion) is used to
validate an instance of the
[AccessDecoratorVersion](#classAccessDecoratorVersion) class.

<pre highlight="turtle" id="shexAccessDecoratorVersion">
<#AccessDecoratorVersionShape> {
  a [ eco:AccessDecoratorVersion ] ;
  eco:isVersion xsd:string ;
  eco:hasSHA256 xsd:string ;
  eco:hasAccessDecoratorResource IRI ;
}
</pre>

### Access Decorator Resource ### {#needs-access-decorator-resource}

An <dfn>Access Decorator Resource</dfn> is a document that contains
[=Access Need Group Decorators=] and [=Access Need Decorators=] in a
given language.

<table class="classinfo data" align="left" id="classAccessDecoratorResource">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessDecoratorResource](ecosystem.ttl#AccessDecoratorResource)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><i>No properties</i></td>
      <td>-</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

#### Access Need Group Decorator #### {#needs-access-need-group-decorator}

An <dfn>Access Need Group Decorator</dfn> provides a subject name and
more in depth description that explains why a given [=Access Need Group=]
is being requested of an [=Agent=].

<table class="classinfo data" align="left" id="classAccessNeedGroupDecorator">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessNeedGroupDecorator](ecosystem.ttl#AccessNeedGroupDecorator)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>hasAccessNeedGroup</td>
      <td>[AccessNeedGroup](#classAccessNeedGroup)</td>
      <td>[=Access Need Group=] the decorator applies to</td>
    </tr>
    <tr>
      <td>skos:preflabel</td>
      <td>`xsd:string`</td>
      <td>Short label (title) for the [=Access Need Group=]</td>
    </tr>
    <tr>
      <td>skos:definition</td>
      <td>`xsd:string`</td>
      <td>Description of why the [=Access Need Group=] requires the
      access it is requesting.</td>
    </tr>
  </tbody>
</table>

The [AccessNeedGroupDecoratorShape](#shexAccessNeedGroupDecorator) is used to
validate an instance of the
[AccessNeedGroupDecorator](#classAccessNeedGroupDecorator) class.

<pre highlight="turtle" id="shexAccessNeedGroupDecorator">
<#AccessNeedGroupDecoratorShape> {
  a [ eco:AccessNeedGroupDecorator ] ;
  eco:hasAccessNeedGroup IRI ;
  skos:prefLabel xsd:string ;
  skos:definition xsd:string
}
</pre>

#### Access Need Decorator #### {#needs-access-need-decorator}

An <dfn>Access Need Decorator</dfn> provides a specific
explanation of why that data type is being requested.

<table class="classinfo data" align="left" id="classAccessNeedDecorator">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessNeedDecorator](ecosystem.ttl#AccessNeedDecorator)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>hasAccessNeedGroup</td>
      <td>[AccessNeedGroup](#classAccessNeedGroup)</td>
      <td>[=Access Need Group=] the decorator applies to</td>
    </tr>
    <tr>
      <td>registeredShapeTree</td>
      <td>`st:ShapeTree`</td>
      <td>[=Shape tree=] associated with the [=Access Need=] the decorator
      should apply to</td>
    </tr>
    <tr>
      <td>skos:prefLabel</td>
      <td>`xsd:string`</td>
      <td>Specific explanation of why that data type is being requested</td>
    </tr>
  </tbody>
</table>

The [AccessNeedDecoratorShape](#shexAccessNeedDecorator) is used to
validate an instance of the
[AccessNeedDecorator](#classAccessNeedDecorator) class.

<pre highlight="turtle" id="shexAccessNeedDecorator">
<#AccessNeedDecoratorShape> {
  a [ eco:AccessNeedDecorator ] ;
  eco:hasAccessNeedGroup IRI ;
  eco:registeredShapeTree IRI ;
  skos:prefLabel xsd:string
}
</pre>

## Operations ## {#needs-operations}

The following operations explain how to process [=Access Need Groups=]
so they can be presented to an [=Agent=] in
[[#access-operations|Access Grant Operations]]

* [[#prepare-group]]
* [[#prepare-need]]
* [[#get-group-dec]]
* [[#get-need-dec]]

### Prepare Access Need Group ### {#prepare-group}

This operation takes a given [=Access Need Group=] with a number of associated
[=Access Needs=] and processes them to produce a [=Prepared Access Need Group=]
that is ready to present to a given [=Agent=]
via the [[#access-present]] operation.

1. The [=shape tree=] associated with each [=Root Access Need=] is
    traversed to the desired level of recursion, including across references.
    A [=Prepared Access Need=] is added in a linked hierarchy
    starting with the [=Root Access Need=], representing every unique
    [=shape tree=] that was traversed.
2. Decorators are looked up and linked to the
    [=Prepared Access Need Group=] and where available for every
    [=Prepared Access Need=]
3. Any [=Supporting Access Needs=] are associated with [=Prepared Access Needs=].

#### Inputs #### {#prepare-group-inputs}

* Let `GROUP` be an [=Access Need Group=]
* Let `LANG` be the [=Agent's=] preferred language

#### Outputs #### {#prepare-group-outputs}

* A [=Prepared Access Need Group=] generated from the input `GROUP`, with
    an associated set of [=Prepared Access Needs=].

#### Operation Details #### {#prepare-group-details}

1. Perform a validation of the RDF graph of `GROUP` against
    [eco:AccessNeedGroupShape](ecosystem.shex#AccessNeedGroupShape).
    <em class="rfc2119">MUST</em> return a status code of 400 if
    validation fails.
1. Let `ALLNEEDS` be the combined set of [=Access Needs=] linked via
    `GROUP hasAccessNeed` and `GROUP hasAccessNeedOverride`
1. Let `OVERRIDES` be the [=Access Needs=] linked via `GROUP hasAccessNeedOverride`
1. Let `TREEDECS` represent all [=Shape Tree Decorators=] associated with `ALLNEEDS`
1. Let `ALLDECS` represent all [=Access Need Decorators=] associated with `ALLNEEDS`
1. Let `PGROUP` be a [=Prepared Access Need Group=]
1. Let `PGROUP hasAccessNeedDecorator` be the [=Access Need Group Decorator=]
    returned from [[#get-group-dec]] with inputs: `GROUP`, `LANG`
1. Let `PGROUP fromAccessNeedGroup` be `GROUP`
1. Let `PGROUP accessNecessity` be `GROUP accessNecessity`
1. Let `PGROUP authenticatesAs` be `GROUP authenticatesAs`
1. For each [=Root Access Need=] `ROOT` linked via `GROUP hasAccessNeed`
    1. Let `PGROUP hasPreparedAccessNeed` be linked to the
        [=Root Prepared Access Need=] returned by
        [[#prepare-need]] with inputs: `ROOT registeredShapeTree`, `ROOT`,
        `ALLNEEDS`, `OVERRIDES`, `TREEDECS`, `ALLDECS`, `LANG`
1. Let `ALLPREPARED` represent all [=Prepared Access Needs=] linked via
    `PGROUP hasPreparedAccessNeed`, as well as all [=Prepared Access Needs=]
    linked to them via `referencesPreparedAccessNeed` or `skos:narrower`.
1. For each [=Root Prepared Access Need=] `PROOT` linked via `PGROUP hasPreparedAccessNeed`
    1. Call [[#link-supported]] with inputs: `PROOT`, `ALLPREPARED`

### Prepare Access Need ### {#prepare-need}

This operation is called recursively to build up a linked hierarchy of
[=Prepared Access Needs=] in concert with the [[#prepare-need-walk]] operation.

#### Inputs #### {#prepare-need-inputs}

* Let `TREE` be the current [=shape tree=] in context
* Let `LASTNEED` be the [=Access Need=] in context
* Let `ALLNEEDS` be the combined set of [=Access Needs=] linked via
    `GROUP hasAccessNeed` and `GROUP hasAccessNeedOverride`
* Let `OVERRIDES` be the [=Access Needs=] linked via `GROUP hasAccessNeedOverride`
* Let `TREEDECS` represent all [=Shape Tree Decorators=] associated with `ALLNEEDS`
* Let `ALLDECS` represent all [=Access Need Decorators=] associated with `ALLNEEDS`
* Let `LANG` be the [=Agent's=] preferred language

#### Outputs #### {#prepare-need-outputs}

* A [=Prepared Access Need=] with a linked hierarchy of
    [=Prepared Access Needs=] associated with it

#### Operation Details #### {#prepare-need-details}

1. Let `TOPTREEDEC` be the [=Shape Tree Decorator=]
    returned from the [Get Shape Tree Decorator](#) operation with
    inputs: `TREE`, `LANG`
1. Let `SPECIFICNEED` be the [=Access Need=] returned from the
    [[#prepare-need-getspecific]] operation with inputs:
    `TREE`, `OVERRIDES`, `LASTNEED`
1. return the [=Prepared Access Need=] returned by calling
    [[#prepare-need-walk]] with inputs:
    `TREE`, `TOPTREEDEC`, `SPECIFICNEED`, `ALLDECS`, `ALLNEEDS`,
    `OVERRIDES`, `TREEDECS`, `LANG`

#### _walkDecorators #### {#prepare-need-walk}

This operation is called recursively to build up a linked hierarchy of
[=Prepared Access Needs=] in concert with the [[#prepare-need]] operation.

##### Inputs ##### {#walk-inputs}

* Let `TREE` be the current [=shape tree=] in context
* Let `TREEDEC` be the current [=Shape Tree Decorator=] in context
* Let `NEED` be the [=Access Need=] in context
* Let `ALLDECS` represent all [=Access Need Decorators=] associated with `ALLNEEDS`
* Let `ALLNEEDS` be the combined set of [=Access Needs=] linked via
    `GROUP hasAccessNeed` and `GROUP hasAccessNeedOverride`
* Let `OVERRIDES` be the [=Access Needs=] linked via `GROUP hasAccessNeedOverride`
* Let `TREEDECS` represent all [=Shape Tree Decorators=] associated with `ALLNEEDS`
* Let `LANG` be the [=Agent's=] preferred language

##### Outputs ##### {#walk-outputs}

* A [=Prepared Access Need=] with a linked hierarchy of
    [=Prepared Access Needs=] associated with it

##### Operation Details ##### {#walk-details}

1. Let `PREPARED` be a new [=Prepared Access Need=]
1. Let `PREPARED registeredShapeTree` be `TREE`
1. Let `PREPARED accessNecessity` be set to `NEED`'s `accessNecessity`
1. Let `PREPARED accessMode` be all of `NEED`'s `accessMode`s
1. Let `PREPARED hasAccessNeedDecorator` be the [=Access Need Decorator=]
    returned from [[#get-need-dec]] with inputs: `NEED`, `LANG`
1. Let `PREPARED hasShapeTreeDecorator` be `TREEDEC`
1. If `TREEDEC skos:narrower`
    1. Let `NARROWERDEC` be `TREEDEC skos:narrower`
    1. Let `NARROWERTREE` be `NARROWERDEC hasShapeTree`
    1. Let `NARROWERNEED` be the [=Access Need=] returned from the
        [[#prepare-need-getspecific]] operation with inputs:
        `NARROWERTREE`, `OVERRIDES`, `NEED`
    1. Let `PREPARED skos:narrower` be the [=Prepared Access Need=] returned
        from calling [[#prepare-need-walk]] with inputs:
        `NARROWERTREE`, `NARROWERDEC`, `NARROWERNEED`, `ALLDECS`, `ALLNEEDS`,
        `OVERRIDES`, `TREEDECS`, `LANG`
1. For each [=shape tree=] `REFTREE` linked via `TREE st:references`
    1. Call [[#prepare-need]] with inputs `REFTREE`, `NEED`,
        `ALLNEEDS`, `OVERRIDES`, `TREEDECS`, `ALLDECS`, `LANG`

#### _getSpecificAccessNeed #### {#prepare-need-getspecific}

This operation looks through all of the [=Access Need Overrides=] associated
with a given [=Access Need Group=] to see if there is an
[=Access Need Override=] for the input [=shape tree=]. If there is not,
it will effective inherit its defaults from the last [=Access Need=] instead.

##### Inputs ##### {#getspecific-inputs}

* Let `TREE` be the current [=shape tree=] in context
* Let `DEFAULTNEED` be the default [=Access Need=] to return
* Let `OVERRIDES` be the [=Access Needs=] linked via `GROUP hasAccessNeedOverride`

##### Outputs ##### {#getspecific-outputs}

* An [=Access Need=]

##### Operation Details ##### {#getspecific-details}

1. For each [=Access Need=] `NEED` in `OVERRIDES`
    1.  return `NEED` if `NEED registeredShapeTree` is `TREE`
1. return `DEFAULTNEED`

### Link Supported Prepared Access Needs ### {#link-supported}

This is a recursive operation that iterates through all of the
[=Prepared Access Needs=] associated with a [=Prepared Access Need Group=]
and links together any that have a support relationship.

A support relationship exists when the [=shape tree=] associated with one
[=Prepared Access Need=] has an `st:supports` predicate that links
to the [=shape tree=] of another [=Prepared Access Need=]. They are
linked bi-directionally through the `eco:supports` and
`eco:supportedBy` properties.

#### Inputs #### {#link-supported-inputs}

* Let `PNEED` be a [=Prepared Access Need=]
* Let `ALLPREPARED` be all [=Prepared Access Needs=] associated with a
    given [=Prepared Access Need Group=]

#### Outputs #### {#link-supported-outputs}

* None

#### Operation Details #### {#link-supported-details}

1. Let `TREE` be `PNEED registeredShapeTree`
1. If `TREE st:supports`
    1. Let `SUPPORTEDTREE` be the [=shape tree=] linked by `TREE st:supports`
    1. For each [=Prepared Access Need=] `PREPARED` in `ALLPREPARED`
        1. Let `SUPPORTEDNEED` be the return of [[#iterate-supported]] with
            inputs: `ALLPREPARED`, `TREE`
        1. Let `PNEED supports` be `SUPPORTEDNEED`
        1. Let `SUPPORTEDNEED supportedBy` be `PNEED`
1. For each [=Prepared Access Need=] `REFNEED` linked by
    `PNEED referencesPreparedAccessNeed`
    1. Call [[#link-supported]] with inputs: `REFNEED`, `ALLPREPARED`
1. For each [=Prepared Access Need=] `NARROWERNEED` linked by
    `PNEED skos:narrower`
    1. Call [[#link-supported]] with inputs: `NARROWERNEED`, `ALLPREPARED`

#### Iterate for Supported Prepared Access Needs #### {#iterate-supported}

This is a recursive function that iterates through a linked hierarchy of
[=Prepared Access Needs=] looking for a [=Prepared Access Need=] with a
matching [=shape tree=].

##### Inputs ##### {#iterate-inputs}

* Let `PNEED` be a [=Prepared Acecss Need=]
* Let `TREE` be a [=shape tree]

##### Outputs ##### {#iterate-outputs}

* Returns a [=Prepared Access Need=]

##### Operation Details ##### {#iterate-details}

1. Return `PNEED` if `PNEED registeredShapeTree` is `TREE`
1. For each [=Prepared Access Need=] `REFNEED` linked by
    `PNEED referencesPreparedAccessNeed`
    1. Call [[#iterate-supported]] with inputs: `REFNEED`, `TREE`
1. For each [=Prepared Access Need=] `NARROWERNEED` linked by
    `PNEED skos:narrower`
    1. Call [[#iterate-supported]] with inputs: `NARROWERNEED`, `TREE`
1. Return `NULL`

### Get Access Decorator Resource ### {#get-access-dec}

This operation returns the appropriate [=Access Decorator Resource=]
from an input [=Access Decorator Index=] for the provided language.
If the provided language is not available, a default language is used instead.

#### Inputs #### {#get-access-dec-inputs}

* Let `INDEX` be an [=Access Decorator Index=]
* Let `LANG` be the [=Agent's=] preferred language

#### Outputs #### {#get-access-dec-outputs}

* Let `DECR` be an [=Access Decorator Resource=] from `INDEX`

#### Operation Details #### {#get-access-dec-details}

1. Let `USESERIES` be `INDEX defaultSeries`
1. Let `USEVERSION` be an unassigned [=Access Decorator Version=]
1. For each [=Access Decorator Series=] `SERIES` in `INDEX`
    1. Let `USESERIES` be `SERIES` if `SERIES usesLanguage` == `LANG`
1. <em class="rfc2119">MUST</em> return a status code
    of 404 if no [=Access Decorator Series=] are found.
1. For each [=Access Decorator Version=] `VERSION` in `USESERIES hasVersion`
    1. Let `USEVERSION` be `VERSION` if `VERSION` is a more recent
        [semantic version](https://semver.org/) than `USEVERSION` or if
        `USEVERSION` is unassigned.
1. <em class="rfc2119">MUST</em> return a status code
    of 404 if no [=Access Decorator Versions=] are found.
1. Let `DECR` be the [=Access Decorator Resource=] linked
    from `USEVERSION hasAccessDecoratorResource`
1. <em class="rfc2119">MUST</em> return a status code
    of 404 if `DECR` is unassigned.
1. return `DECR`

### Get Access Need Group Decorator ### {#get-group-dec}

This operation returns the appropriate [=Access Need Group Decorator=]
for an input [=Access Need Group=] in the provided language. If the
provided language is not available, a default language is used instead.

#### Inputs #### {#get-group-dec-inputs}

* Let `GROUP` be an [=Access Need Group=]
* Let `LANG` be the [=Agent's=] preferred language

#### Outputs #### {#get-group-dec-outputs}

* Let `GDEC` be an [=Access Need Group Decorator=] associated with `GROUP`

#### Operation Details #### {#get-group-dec-details}

1. Let `DECR` be the [=Access Decorator Resource=] returned by [[#get-group-dec]]
    with inputs: `GROUP hasAccessDecoratorIndex`, `LANG`
1. Let `USEGDEC` be an unassigned [=Access Need Group Decorator=]
1. Let `GDECS` be all [=Acess Need Group Decorators=] in `DECR`
1. For each [=Acces Need Group Decorator] `GDEC` in `GDECS`
  1. Let `USEGDEC` be `GDEC` if `GDEC hasAccessNeedGroup` is `GROUP`
1. <em class="rfc2119">MUST</em> return a status code
    of 404 if `USEGDEC` is unassigned
1. return `USEGDEC`

### Get Access Need Decorator ### {#get-need-dec}

This operation returns the appropriate [=Access Need Decorator=]
for an input [=Access Need=] in the provided language. If the
provided language is not available, a default language is used instead.

#### Inputs #### {#get-need-dec-inputs}

* Let `NEED` be an [=Access Need=]
* Let `LANG` be the [=Agent's=] preferred language

#### Outputs #### {#get-need-dec-outputs}

* Let `NDEC` be an [=Access Need Decorator=] associated with `NEED`

#### Operation Details #### {#get-need-dec-details}

1. Let `GROUP` be `NEED inAccessNeedGroup`
1. Let `DECR` be the [=Access Decorator Resource=] returned by [[#get-group-dec]]
    with inputs: `GROUP hasAccessDecoratorIndex`, `LANG`
1. Let `USENDEC` be an unassigned [=Access Need Decorator=]
1. Let `NDECS` be all [=Acess Need Decorators=] in `DECR`
1. For each [=Acces Need Decorator] `NDEC` in `NDECS`
  1. Let `USENDEC` be `NDEC` if `NDEC hasAccessNeedGroup` is `GROUP` and
      `NDEC registeredShapeTree` is `NEED registeredShapeTree`
1. <em class="rfc2119">MUST</em> return a status code
    of 404 if `USENDEC` is unassigned
1. return `USENDEC`

Access Grants {#access}
=====================

## Overview ## {#access-overview}

## Data Model ## {#access-datamodel}

### Summary ### {#access-datamodel-summary}

<figure id="fig-access-model">
  <img src="diagrams/access-model.svg" width=100%/>
  <figcaption>Data model for the access registry</figcaption>
</figure>

The [=Access Registry=] extends the [[#reg-model]] with type-specific
subclasses and subproperties.

An [=Agent=] has a [=Registrar=] that links to [=Access Registry Sets=]
via the [eco:hasAccessRegistrySet](ecosystem.ttl#hasAccessRegistrySet) property.

A [=Access Registry Set=] links to any number of [=Access Registries=] via
the [eco:hasRegistry](ecosystem.ttl#hasRegistry) property.

An [=Access Registry=] links to any number of registered [=Access Grants=]
and [=Access Invitations=] via the
[eco:hasRegistration](ecosystem.ttl#hasRegistration) property.

<figure id="fig-access-registrar">
  <figcaption>A [=Registrar=] at https://alice.pod.example/registries/#registrar
  linking to an [=Access Registry Set=]</figcaption>
  <pre highlight="turtle">
  <#registrar>
    a eco:Registrar;
    eco:hasAccessRegistrySet &lt;https://alice.pod.example/registries/access#set&gt; .
  </pre>
  </figure>
</figure>

<figure id ="fig-access-registry-set">
   <figcaption>An [=Access Registry Set=] at
   https://alice.pod.example/registries/access#set linking to two different
  [=Access Registries=]</figcaption>
  <pre highlight="turtle">
  <#set>
    a eco:AccessRegistrySet;
    eco:hasRegistry &lt;https://alice.pod.example/access/#registry&gt; ,
                    &lt;https://alice.otherpod.example/access/#registry&gt; .
  </pre>
</figure>

<figure id="fig-access-registry">
  <figcaption>An [=Access Registry=] at https://alice.pod.example/access/#registry
  linking to several registered [=Access Grants=] or
  [=Access Invitations=]</figcaption>
  <pre highlight="turtle">
  <#registry>
    a eco:AccessRegistry ;
    eco:hasRegistration &lt;ab3d0023-3860-4358-ae33-8d3af1097b9d#grant&gt; ,
                        &lt;ad7b935f-ced9-4ce6-835f-5c6abc046228#grant&gt; ,
                        &lt;5ed73c65-ce77-4c8a-8f7e-9715b90307e6#grant&gt; ,
                        &lt;2d575cba-3f6c-4c58-bccd-0e6266ba56cf#invitation&gt; .
  </pre>
</figure>

<figure id="fig-access-grant">
  <figcaption>An [=Access Grant=] at
  https://alice.pod.example/access/ab3d0023-3860-4358-ae33-8d3af1097b9d#grant
  </figcaption>
  <pre highlight="turtle">
  <#grant>
    a eco:AccessGrant ;
    eco:registeredBy https://alice.pod.example/profile/id#me ;
    eco:registeredWith https://trusted.example/id#agent ;
    eco:registeredAt "2020-09-05T06:15:01Z"^^xsd:dateTime ;
    eco:updatedAt "2020-09-05T06:15:01Z"^^xsd:dateTime ;
    eco:hasAccessGrantSubject <#grant-subject> ;
    eco:hasPreparedAccessNeedGroup <#pag-notebook-group> ;
    eco:hasDataGrant <#notebook-grant>, <#note-grant> .

  <#grant-subject>
    a eco:AccessGrantSubject ;
    eco:accessByAgent https://alice.pod.example/profile/id#me ;
    eco:accessByApplication https://nevernote.example/id#agent .

  <#notebook-grant>
    a eco:DataGrant ;
    eco:hasRegistration data:notebook-tree ;
    eco:registeredShapeTree note:notebook-tree ;
    eco:satisfiesPreparedAccessNeed <#pan-notebook> ;
    eco:accessMode acl:Read, acl:Write ;
    eco:scopeOfDataGrant eco:AllInstances ;

  <#note-grant>
    a eco:DataGrant ;
    eco:hasRegistration data:note-tree ;
    eco:registeredShapeTree note:note-tree ;
    eco:satisfiesPreparedAccessNeed <#pan-note> ;
    eco:accessMode acl:Read, acl:Write ;
    eco:scopeOfDataGrant eco:AllInstances ;

  <#pag-notebook-group>
    a eco:PreparedAccessNeedGroup ;
    eco:fromAccessNeedGroup ex:accessNotebookGroup ;
    eco:hasAccessNeedGroupDecorator ex:accessNotebookGroupDecorator ;
    eco:accessNecessity eco:AccessRequired ;
    eco:authenticatesAs eco:Pilot ;
    eco:hasPreparedAccessNeed <#pan-notebook> .

  <#pan-notebook>
      a eco:PreparedAccessNeed ;
      eco:registeredShapeTree note:notebook-tree ;
      eco:accessMode acl:Read, acl:Write ;
      eco:accessNecessity eco:AccessRequired ;
      eco:hasAccessNeedDecorator ex:notebookAccessDecorator ;
      eco:hasShapeTreeDecorator note:notebookDecorator ;
      eco:referencesPreparedAccessNeed <#pan-notes> ;
      eco:hasDataGrant <#notebook-grant> .

  <#pan-note>
      a eco:PreparedAccessNeed ;
      eco:registeredShapeTree note:note-tree ;
      eco:accessMode acl:Read, acl:Write ;
      eco:accessNecessity eco:AccessRequired ;
      eco:hasAccessNeedDecorator ex:noteAccessDecorator ;
      eco:hasShapeTreeDecorator note:noteDecorator ;
      eco:hasDataGrant <#note-grant> .
  </pre>
</figure>

<figure id="fig-access-invitation">
  <figcaption>An [=Access Invitation=] at
  https://alice.pod.example/access/2d575cba-3f6c-4c58-bccd-0e6266ba56cf/#invitation
  </figcaption>
  <pre highlight="turtle">
  <#invitation>
    a eco:AccessInvitation ;
    eco:registeredBy https://alice.pod.example/profile/id#me ;
    eco:registeredWith https://trusted.example/id#agent ;
    eco:registeredAt "2020-09-13T19:32:52Z"^^xsd:dateTime ;
    eco:updatedAt "2020-09-13T19:32:52Z"^^xsd:dateTime ;
    eco:expiresAt "2020-09-20T19:32:52Z"^^xsd:dateTime ;
    eco:hasPreparedAccessNeedGroup <#pag-notebook-group> ;
    eco:hasDataGrant <#notebook-grant>, <#note-grant> ;
    eco:hasAccessInvitationChannel <#phone-channel>, <#email-channel> .

  <#phone-channel>
    a eco:PhoneInvitationChannel ;
    eco:channelTarget "(555) 555-1212" ;
    eco:channelCode "654345" ;
    eco:isValidated false ;
    eco:remainingAttempts 3 .

  <#email-channel>
    a eco:EmailInvitationChannel ;
    eco:channelTarget "bob@example.com" ;
    eco:channelCode "434567" ;
    eco:isValidated true ;
    eco:remainingAttempts 3 .

  <#notebook-grant>
    a eco:DataGrant ;
    eco:hasRegistration data:notebook-tree ;
    eco:registeredShapeTree note:notebook-tree ;
    eco:satisfiesPreparedAccessNeed <#pan-notebook> ;
    eco:accessMode acl:Read, acl:Write ;
    eco:scopeOfDataGrant eco:AllInstances ;

  <#note-grant>
    a eco:DataGrant ;
    eco:hasRegistration data:note-tree ;
    eco:registeredShapeTree note:note-tree ;
    eco:satisfiesPreparedAccessNeed <#pan-note> ;
    eco:accessMode acl:Read, acl:Write ;
    eco:scopeOfDataGrant eco:AllInstances ;

  <#pag-notebook-group>
    a eco:PreparedAccessNeedGroup ;
    eco:fromAccessNeedGroup ex:accessNotebookGroup ;
    eco:hasAccessNeedGroupDecorator ex:accessNotebookGroupDecorator ;
    eco:accessNecessity eco:AccessRequired ;
    eco:authenticatesAs eco:Pilot ;
    eco:hasPreparedAccessNeed <#pan-notebook> .

  <#pan-notebook>
      a eco:PreparedAccessNeed ;
      eco:registeredShapeTree note:notebook-tree ;
      eco:accessMode acl:Read, acl:Write ;
      eco:accessNecessity eco:AccessRequired ;
      eco:hasAccessNeedDecorator ex:notebookAccessDecorator ;
      eco:hasShapeTreeDecorator note:notebookDecorator ;
      eco:referencesPreparedAccessNeed <#pan-notes> ;
      eco:hasDataGrant <#notebook-grant> .

  <#pan-note>
      a eco:PreparedAccessNeed ;
      eco:registeredShapeTree note:note-tree ;
      eco:accessMode acl:Read, acl:Write ;
      eco:accessNecessity eco:AccessRequired ;
      eco:hasAccessNeedDecorator ex:noteAccessDecorator ;
      eco:hasShapeTreeDecorator note:noteDecorator ;
      eco:hasDataGrant <#note-grant> .
  </pre>
</figure>

### Access Registry Set ### {#datamodel-access-registry-set}

An <dfn>Access Registry Set</dfn> is a [=Registry Set=] specifically
made up of [=Access Registries=].

<table class="classinfo data" align="left" id="classAccessRegistrySet">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3 text-align=left>
        [AccessRegistrySet](ecosystem.ttl#AccessRegistrySet)
        a rdfs:subClassOf [[#reg-model|RegistrySet]]
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>hasRegistry</td>
      <td>Registry</td>
      <td>Link to associated [=Access Registries=]</td>
    </tr>
  </tbody>
</table>

The [AccessRegistrySetShape](#shexAccessRegistrySet) is used to validate
an instance of the [AccessRegistrySet](#classAccessRegistrySet) class.

<pre highlight="turtle" id="shexAccessRegistrySet">
<#AccessRegistrySetShape> {
  a [ eco:AccessRegistrySet ] ;
  eco:hasRegistry IRI+
}
</pre>

The [AccessRegistrySetTree](ecosystem.tree#access-registry-set-tree)
is assigned to a resource to ensure it will validate against the
[AccessRegistrySetShape](#shexAccessRegistrySet).

<pre highlight="turtle" id="treeAccessRegistrySet">
<#access-registry-set-tree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeResource ;
  st:validatedBy &lt;ecos#AccessRegistrySetShape&gt; ;
  st:matchesUriTemplate "access" .
</pre>

### Access Registry ### {#datamodel-access-registry}

An <dfn>Access Registry</dfn> is a collection of
[=Access Grants=] stored in a specific location in a [=pod=].

<table class="classinfo data" align="left" id="classAccessRegistry">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessRegistry](ecosystem.ttl#AccessRegistry)
        a rdfs:subClassOf [[#reg-model|Registry]]
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>hasRegistration</td>
      <td>Registration</td>
      <td>Link to associated [=Access Grants=]</td>
    </tr>
  </tbody>
</table>

The [AccessRegistryShape](#shexAccessRegistry) is used to validate an
instance of the [AccessRegistry](#classAccessRegistry) class.

<pre highlight="turtle" id="shexAccessRegistry">
<#AccessRegistryShape> {
  a [ eco:AccessRegistry ] ;
  eco:hasRegistration IRI*
}
</pre>

The [AccessRegistryTree](ecosystem.tree#access-registry-tree) is assigned
to a container resource to ensure that it will validate against the
[AccessRegistryShape](#shexAccessRegistry), and contain only
conformant instances of the [AccessGrantTree](#treeAccessGrant).

<pre highlight="turtle" id="treeAccessRegistry">
<#access-registry-tree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeContainer ;
  st:validatedBy &lt;ecos#AccessRegistryShape&gt; ;
  st:contains <#access-grant-tree> ,
              <#access-invitation-tree> ,
              st:AllowNone .
</pre>

### Access Grant ### {#datamodel-access-grant}

Each <dfn>Access Grant</dfn> represents access granted to one recipient; the
[=Access Grant Subject=], based on access criteria detailed in one or more
[=Prepared Access Need Groups=]. Access is granted to registered data in
[=Data Registries=], identified by [=Data Grants=] linked to the
[=Access Grant=].

<table class="classinfo data" align="left" id="classAccessGrant">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessGrant](ecosystem.ttl#AccessGrant)
        a rdfs:subClassOf [[#reg-model|Registration]]
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>registeredBy</td>
      <td>Agent</td>
      <td>[=Agent=] that registered the [=Access Grant=]</td>
    </tr>
    <tr>
      <td>registeredWith</td>
      <td>Application</td>
      <td>[=Application=] used to create the [=Access Grant=]</td>
    </tr>
    <tr>
      <td>registeredAt</td>
      <td>xsd:dateTime</td>
      <td>Date and time the [=Access Grant=] was created</td>
    </tr>
    <tr>
      <td>updatedAt</td>
      <td>xsd:dateTime</td>
      <td>Date and time the [=Access Grant=] was updated</td>
    </tr>
    <tr>
      <td>hasAccessGrantSubject</td>
      <td>AccessGrantSubject</td>
      <td>Links to one [=Access Grant Subject=] who was granted access.</td>
    </tr>
    <tr>
      <td>hasPreparedAccessNeedGroup</td>
      <td>PreparedAccessNeedGroup</td>
      <td>Links to a [=Prepared Access Need Group=] associated with the Access Grant.</td>
    </tr>
    <tr>
      <td>hasDataGrant</td>
      <td>DataGrant</td>
      <td>Links to a [=Data Grant=] associated with the Access Grant.</td>
    </tr>
  </tbody>
</table>

The [AccessGrantShape](#shexAccessGrant) is used to validate an instance
of the [AccessGrant](#classAccessGrant) class.

<pre highlight="turtle" id="shexAccessGrant">
<#AccessGrantShape> {
  a [ eco:AccessGrant ] ;
  eco:registeredBy IRI ;
  eco:registeredWith IRI? ;
  eco:registeredAt xsd:dateTime ;
  eco:accessGrantSubject @AccessGrantSubject ;
  eco:hasPreparedAccessNeedGroup @PreparedAccessNeedGroupShape+ ;
  eco:hasDataGrant @DataGrantShape+
}
</pre>

The [AccessGrantTree](ecosystem.tree#access-grant-tree) is assigned to a
resource via the [AccessRegistryTree](#treeAccessRegistry), and ensure
that the assigned resource will validate against the
[AccessGrantShape](#shexAccessGrant).

<pre highlight="turtle" id="treeAccessGrant">
<#access-grant-tree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeResource ;
  st:validatedBy &lt;ecos#AccessGrantShape&gt; ;
  st:matchesUriTemplate "{id}" .
</pre>

### Access Grant Subject ### {#datamodel-access-grant-subject}

An <dfn>Access Grant Subject</dfn> represents a unique combination of
who and what is being granted access. For example, it allows a single [=Agent=]
to be specified, or a given [=Agent=] using a given [=Application=].

<table class="classinfo data" align="left" id="classAccessGrantSubject">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>[AccessGrantSubject](ecosystem.ttl#AccessGrant)</th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>accessByAgent</td>
      <td>Agent</td>
      <td>[=Agent=] being granted access</td>
    </tr>
    <tr>
      <td>accessByApplication</td>
      <td>Application</td>
      <td>[=Application=] being granted access</td>
    </tr>
  </tbody>
</table>

The [AccessGrantSubjectShape](#shexAccessGrantSubject) is used to validate
an instance of the [AccessGrantSubject](#classAccessGrantSubject) class.

<pre highlight="turtle" id="shexAccessGrantSubject">
<#AccessGrantSubjectShape> {
  a [ eco:AccessGrantSubject ] ;
  eco:accessGrantSubjectAgent IRI? ;
  eco:accessGrantSubjectApplication IRI?
}
</pre>

### Data Grant ### {#datamodel-data-grant}

A <dfn>Data Grant</dfn> records a decision made by a
given [=Agent=] based upon [=Prepared Access Needs=] presented to them
for a given [=Data Registration=].

<table class="classinfo data" align="left" id="classDataGrant">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [DataGrant](ecosystem.ttl#DataGrant)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>hasRegistration</td>
      <td>DataRegistration</td>
      <td>[=Data Registration=] the [=Data Grant=] applies to</td>
    </tr>
    <tr>
      <td>registeredShapeTree</td>
      <td>st:ShapeTree</td>
      <td>The [=shape tree=] registered at the target [=Data Registration=]</td>
    </tr>
    <tr>
      <td>satisfiesPreparedAccessNeed</td>
      <td>PreparedAccessNeed</td>
      <td>Links to a [=Prepared Access Need=] satisfied by the [=Data Grant=]</td>
    </tr>
    <tr>
      <td>accessMode</td>
      <td>acl:Read, acl:Write, acl:Control, acl:Append</td>
      <td>Union of access modes from [=Prepared Access Needs=] linked by
      satisfiesPreparedAccessNeed</td>
    </tr>
    <tr>
      <td>scopeOfDataGrant</td>
      <td> eco:AllInstances, eco:InheritInstances,
      eco:SelectedInstances, eco:NoAccess</td>
      <td>Identifies the access scope of the [=Data Grant=]
        <ul>
          <li>eco:AllInstances - Scope includes
              access to all [=Registered Data Instances=] of the associated
              [=Data Registration=]</li>
          <li>eco:InheritInstances - Scope includes
              access to [=Registered Data Instances=] inherited by
              instances selected in the [=Data Grant=] linked via
              eco:inheritsFrom</li>
          <li>eco:SelectedInstances - Scope includes
              access only to those [=Registered Data Instances=] specifically
              selected by the [=Agent=]</li>
          <li>eco:NoAccess</li> - No access is granted
        </ul>
      </td>
    </tr>
    <tr>
      <td>inheritsFrom</td>
      <td>[DataGrant](#classDataGrant)</td>
      <td>Identifies a [=Data Grant=] whose selected
      [=Registered Data Instances=] narrow the scope of instances to be
      presented by this grant.</td>
    </tr>
    <tr>
      <td>hasRegisteredDataInstance</td>
      <td>Instance of registeredShapeTree</td>
      <td>Links to a [=Registered Data Instance=] of registeredShapeTree.</td>
    </tr>
  </tbody>
</table>

The [DataGrantShape](#shexDataGrant) is used to
validate an instance of the [DataGrant](#classDataGrant)
class.

<pre highlight="turtle" id="shexDataGrant">
<#DataGrantShape> {
  a [ eco:DataGrant ] ;
  eco:hasRegistration IRI ;
  eco:registeredShapeTree IRI ;
  eco:satisfiesPreparedAccessNeed @PreparedAccessNeedShape+ ;
  eco:accessMode [ acl:Read acl:Write acl:Append acl:Control ]+ ;
  eco:scopeOfDataGrant [ eco:SelectedInstances eco:AllInstances eco:InheritInstances eco:NoAccess ]+ ;
  eco:inheritsFrom @DataGrantShape*
}
</pre>

### Access Invitation ### {#datamodel-access-invitation}

An <dfn>Access Invitation</dfn> is a subclass of [=Access Grant=] used when
an [=Agent=] wishes to grant access to another [=Agent=] whose
decentralized [=identity=] is unknown to them, or may not exist yet, so they
must be first invited through another channel (such as phone or email).

Like an [=Access Grant=], an [=Access Invitation=] links to access
criteria detailed in one or more [=Prepared Access Need Groups=], with
associated [=Data Grants=] indicating the intended access to be granted.

However, instead of linking to an [=Access Grant Subject=], an
[=Access Invitation=] links to one or more [=Access Invitation Channels=].

Each channel represents a mechanism through which the invitation can
be delivered and validated. The mechanism is designed so that multiple
channels may be validated before an invitation is confirmed and
converted to an [=Access Grant=].

<table class="classinfo data" align="left" id="classAccessInvitation">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessInvitation](ecosystem.ttl#AccessInvitation)
        a rdfs:subClassOf [[#datamodel-access-grant|AccessGrant]]
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>registeredBy</td>
      <td>Agent</td>
      <td>[=Agent=] that registered the [=Access Invitation=]</td>
    </tr>
    <tr>
      <td>registeredWith</td>
      <td>Application</td>
      <td>[=Application=] used to create the [=Access Invitation=]</td>
    </tr>
    <tr>
      <td>registeredAt</td>
      <td>xsd:dateTime</td>
      <td>Date and time the [=Access Invitation=] was created</td>
    </tr>
    <tr>
      <td>updatedAt</td>
      <td>xsd:dateTime</td>
      <td>Date and time the [=Access Invitation=] was updated</td>
    </tr>
    <tr>
      <td>expiresAt</td>
      <td>xsd:dateTime</td>
      <td>Date and time the [=Access Invitation=] expires</td>
    </tr>
    <tr>
      <td>hasAccessInvitationChannel</td>
      <td>AccessInvitationChannel</td>
      <td>Links to an [=Access Invitation Channel=]</td>
    </tr>
    <tr>
      <td>hasPreparedAccessNeedGroup</td>
      <td>PreparedAccessNeedGroup</td>
      <td>Links to a [=Prepared Access Need Group=] associated with the
      [=Access Invitation=].</td>
    </tr>
    <tr>
      <td>hasDataGrant</td>
      <td>DataGrant</td>
      <td>Links to a [=Data Grant=] associated with the
      [=Access Invitation=].</td>
    </tr>
  </tbody>
</table>

The [AccessInvitationShape](#shexAccessInvitation) is used to validate an
instance of the [AccessInvitation](#classAccessInvitation) class.

<pre highlight="turtle" id="shexAccessInvitation">
<#AccessInvitationShape> {
  a [ eco:AccessInvitation ] ;
  eco:registeredBy IRI ;
  eco:registeredWith IRI? ;
  eco:registeredAt xsd:dateTime ;
  eco:updatedAt xsd:dateTime ;
  eco:expiresAt xsd:dateTime? ;
  eco:hasPreparedAccessNeedGroup @&lt;#:PreparedAccessNeedGroupShape&gt;+ ;
  eco:hasDataGrant @&lt;#:DataGrantShape&gt;+
  eco:hasAccessInvitationChannel @&lt;#:AccessInvitationChannelShape&gt;+ ;
}
</pre>

The [AccessInvitationTree](ecosystem.tree#access-invitation-tree) is assigned
to a resource via the [AccessRegistryTree](#treeAccessRegistry), and ensures
that the assigned resource will validate against the
[AccessInvitationShape](#shexAccessInvitation).

<pre highlight="turtle" id="treeAccessInvitation">
<#access-invitation-tree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeResource ;
  st:validatedBy &lt;ecos#AccessInvitationShape&gt; ;
  st:matchesUriTemplate "{id}" .
</pre>

### Access Invitation Channel ### {#datamodel-access-invitation-channel}

An <dfn>Access Invitation Channel</dfn> represents a mechanism through
which an [=Access Invitation=] can be delivered and validated.

<table class="classinfo data" align="left" id="classAccessInvitationChannel">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessInvitationChannel](ecosystem.ttl#AccessInvitationChannel)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>rdf:type</td>
      <td>eco:PhoneInvitationChannel,
      eco:EmailInvitationChannel,
      eco:SMSInvitationChannel,
      eco:OfflineInvitationChannel</td>
      <td>Each channel is represented by a subClassOf
      AccessInvitationChannel</td>
    </tr>
    <tr>
      <td>channelTarget</td>
      <td>xsd:string</td>
      <td>Target used when validating the channel</td>
    </tr>
    <tr>
      <td>channelCode</td>
      <td>xsd:string</td>
      <td>Code used for channel validation</td>
    </tr>
    <tr>
      <td>isValidated</td>
      <td>xsd:boolean</td>
      <td>Indicates whether the channel has been validated</td>
    </tr>
    <tr>
      <td>remainingAttempts</td>
      <td>xsd:integer</td>
      <td>Number of allowed validation attempts remaining</td>
    </tr>
  </tbody>
</table>

The [AccessInvitationChannelShape](#shexAccessInvitationChannel) is used to
validate an instance of the
[AccessInvitationChannel](#classAccessInvitation) class.

<pre highlight="turtle" id="shexAccessInvitationChannel">
<#AccessInvitationChannelShape> {
   a @<#ChannelTypes> ;
   eco:channelTarget xsd:string ;
   eco:channelCode xsd:string ;
   eco:isValidated xsd:boolean ;
   eco:remainingAttempts xsd:integer
}

<#ChannelTypes> [
  :PhoneInvitationChannel   # Telephone
  :EmailInvitationChannel   # E-mail
  :SMSInvitationChannel     # SMS (Simple Messaging Service)
  :OfflineInvitationChannel # Other communication, e.g. verbal, shared note
]
</pre>

## Resource Hierarchy ## {#access-hierarchy}

<table class="data tree" align="left">
  <col>
  <col>
  <col>
  <col>
  <thead>
    <tr>
      <th>Resource</th>
      <th>Class</th>
      <th>Shape</th>
      <th>Shape Tree</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`/registries/#registrar`</td>
      <td>[Registrar](#)</td>
      <td>[RegistrarShape](#)</td>
      <td>[RegistrarTree](#)</td>
    </tr>
    <tr>
      <td>`-- access#set`</td>
      <td>[AccessRegistrySet](#classAccessRegistrySet)</td>
      <td>[AccessRegistrySetShape](#shexAccessRegistrySet)</td>
      <td>[AccessRegistrySetTree](#treeAccessRegistrySet)</td>
    </tr>
    <tr>
      <td>`/access/#registry`</td>
      <td>[AccessRegistry](#classAccessRegistry)</td>
      <td>[AccessRegistryShape](#shexAccessRegistry)</td>
      <td>[AccessRegistryTree](#treeAccessRegistry)</td>
    </tr>
    <tr>
      <td>`-- c482f931...630e5ab0#grant`</td>
      <td>[AccessGrant](#classAccessGrant)</td>
      <td>[AccessGrantShape](#shexAccessGrant)</td>
      <td>[AccessGrantTree](#treeAccessGrant)</td>
    </tr>
    <tr>
      <td>`-- e0983a7e...88c387ea#grant`</td>
      <td>[AccessGrant](#classAccessGrant)</td>
      <td>[AccessGrantShape](#shexAccessGrant)</td>
      <td>[AccessGrantTree](#treeAccessGrant)</td>
    </tr>
    <tr>
      <td>`-- eddf13d6...7f4962c5#grant`</td>
      <td>[AccessGrant](#classAccessGrant)</td>
      <td>[AccessGrantShape](#shexAccessGrant)</td>
      <td>[AccessGrantTree](#treeAccessGrant)</td>
    </tr>
    <tr>
      <td>`-- a990c1b9...c041eb74#grant`</td>
      <td>[AccessGrant](#classAccessGrant)</td>
      <td>[AccessGrantShape](#shexAccessGrant)</td>
      <td>[AccessGrantTree](#treeAccessGrant)</td>
    </tr>
    <tr>
      <td>`-- 265ef957...6689aee7#grant`</td>
      <td>[AccessGrant](#classAccessGrant)</td>
      <td>[AccessGrantShape](#shexAccessGrant)</td>
      <td>[AccessGrantTree](#treeAccessGrant)</td>
    </tr>
  </tbody>
</table>

The [=Access Registry Set=] and the [=Access Registry=] MAY or MAY NOT
be on the same [=pod=].

[=Access Registry Set=] and [=Access Registry=] resources MAY use any
resource or subject names.

[=Access Grants=] MUST use \[UUIDs](https://www.ietf.org/rfc/rfc4122.txt)
for resource names.

## Operations ## {#access-operations}

* [[#access-initialize]] - Initializes a new [=Access Grant=] for a given
    [=Access Grant Subject=] or an [=Access Invitation=] for one or more
    [=Access Invitation Channels=] with one or more [=Access Need Groups
* [[#access-loadgrant]] - Load an existing [=Access Grant=]
    from an [=Access Registry=]
* [[#access-loadinvitation]] - Load an existing [=Access Invitation=]
    from an [=Access Registry=]
* [[#access-recordgrant]] - Store a new or updated [=Access Grant=]
    in an [=Access Registry=]
* [[#access-recordinvitation]] - Store a new or updated [=Access Invitation=]
    in an [=Access Registry=]
* [[#access-applyperms]] - Apply permissions to [=acl resources=] based
    on [=Access Grant=] decisions.

The [[#access-present]] operation is non-normative, and meant to instruct
a developer in how to load and initialize an [=Access Grant=], present it
to an [=Agent=], invoke the appropriate operations to manipulate
[=Data Grants=] in accordance with the [=Agent's=] decisions, and then
record those decisions, which will also apply the permission changes.

### Initialize Grant ### {#access-initialize}

Initialize an [=Access Grant=] or [=Access Invitation=] by processing
the input [=Access Need Groups=]
into [=Prepared Access Need Groups=], then initializing [=Data Grants=] with
no access (yet) for the corresponding [=Prepared Access Needs=] in each group.

#### Inputs #### {#initialize-inputs}

* Let `SUBJECT` be an [=Access Grant Subject=]
* Let `ICHANNELS` be a set of [=Access Invitation Channels=]
* Let `GROUPS` be [=Access Need Groups=] to associate with the [=Access Grant=]
* Let `LANG` be the [=Agent's=] preferred language

#### Outputs #### {#initialize-outputs}

* A newly initialized [=Access Grant=] or [=Access Invitation=]

#### Operation Details #### {#initialize-details}

1. <em class="rfc2119">MUST</em> return a status code of 400 if both
    `SUBJECT` and `ICHANNELS` are provided
1. If `SUBJECT` is provided
    1. Let `NEW` be a newly initialized [=Access Grant=]
    1. Let `NEW hasAccessGrantSubject` be `SUBJECT`
1. If `ICHANNELS` is provided
    1. Let `NEW` be a newly initialized [=Access Invitation=]
    1. For each [=Access Invitation Channel=] `ICHANNEL` in `ICHANNELS`
        1. Let `ICHANNEL` be linked to `NEW` via `NEW hasAccessInvitationChannel`
1. For each [=Access Need Group=] `GROUP` in `GROUPS`
    1. Let `PGROUP` be the [=Prepared Access Need Group=] returned from
        [[#prepare-group]] with inputs `GROUP`, `LANG`
    1. Link `PGROUP` to `NEW` via `NEW hasPreparedAccessNeedGroup`
1. Let `PGROUPS` be all [=Prepared Access Need Groups=] linked to `NEW`
    via `hasPreparedAccessNeedGroup`
1. Let `DATAGRANTS` be an empty set of [=Data Grants=]
1. For each [=Prepared Access Group=] `PGROUP` in `PGROUPS`
    1. For each [=Prepared Access Need=] `PNEED` in `PGROUP`
        1. Let `MATCHING` be a [=Data Grant=] in `DATAGRANTS` where
            `PNEED registeredShapeTree` == `MATCHING registeredShapeTree`
        1. If `MATCHING` let `PNEED hasDataGrant` be `MATCHING`
        1. If `MATCHING` is missing
            1. Let `NEWDATAGRANT` be a newly initialized [=Data Grant=]
            1. Let `NEWDATAGRANT registeredShapeTree` be `PNEED registeredShapeTree`
            1. Let `NEWDATAGRANT hasRegistration` be a [=Data Registration=] `DR`
                where `DR registeredShapeTree` == `NEWDATAGRANT registeredShapeTree`
            1. Let `NEWDATAGRANT scopeOfDataGrant` be `eco:NoAccess`
            1. Let `PNEED hasDataGrant` be `NEWDATAGRANT`
            1. Add `PNEED hasDataGrant` to `DATAGRANTS`
        1. Let `DATAGRANT` be `PNEED hasDataGrant`
        1. Let `DATAGRANT satisfiesPreparedAccessNeed` include `PNEED`
        1. Let `DATAGRANT accessmode`s include `PNEED accessmode`s
  1. Return `NEW`

### Load Grant ### {#access-loadgrant}

This operation will load an [=Access Grant=] from a given [=Access Registry=]

#### Inputs #### {#loadgrant-inputs}

* Let `SUBJECT` be an [=Access Grant Subject=]
* Let `REGISTRY` be an [=Access Registry=]

#### Outputs #### {#loadgrant-outputs}

* An [=Access Grant=] corresponding to `SUBJECT`

#### Operation Details #### {#loadgrant-details}

1. For each [=Access Grant=] `GRANT` included in `REGISTRY hasRegistration`
    1. return `GRANT` if `GRANT hasAccessGrantSubject` == `SUBJECT`

### Load Invitation ### {#access-loadinvitation}

This operation will load an [=Access Invitation=] from a given [=Access Registry=]

#### Inputs #### {#loadinvitation-inputs}

* Let `TARGET` be a `eco:ChannelTarget` to match
* Let `CODE` be an optional `eco:channelCode` to match
* Let `REGISTRY` be an [=Access Registry=]

#### Outputs #### {#loadinvitation-outputs}

*  [=Access Invitations=] matching `TARGET` and (if provided) `CODE`

#### Operation Details #### {#loadinvitation-details}

1. Let `INVITATIONS` be an empty set of [=Access Invitations=]
1. For each [=Access Invitation=] `INVITATION` linked via `REGISTRY hasRegistration`
    1. For each [=Access Invitation Channel=] `ICHANNEL` linked via
        `INVITATION hasAccessInvitationChannel`
        1. Next if `ICHANNEL channelTarget` != `TARGET`
        1. Next if `CODE` is not empty and `ICHANNEL channelCode` != `CODE`
        1. Add `INVITATION` to `INVITATIONS`
1. Return `INVITATIONS`

### Validate Grant ### {#access-validategrant}

This operation is used to validate an [=Access Grant=]
or [=Access Invitation=] before it is stored in an [=Access Registry=]

#### Inputs #### {#validategrant-inputs}

* Let `GRANT` be an [=Access Grant=] or [=Access Invitation=]

#### Outputs #### {#validategrant-outputs}

* Success or Failure Code

#### Operation Details #### {#validategrant-details}

1. If `GRANT` is an [=Access Invitation=]
    1. Perform a validation of the RDF graph of `GRANT` against
        [eco:AccessInvitationShape](ecosystem.shex#AccessInvitationShape).
        <em class="rfc2119">MUST</em> return a status code of 400 if
        validation fails.
1. If `GRANT` is an [=Access Grant=]
    1. Perform a validation of the RDF graph of `GRANT` against
        [eco:AccessGrantShape](ecosystem.shex#AccessGrantShape).
        <em class="rfc2119">MUST</em> return a status code of 400 if
        validation fails.
1. Let `PGROUPS` be the [=Prepared Access Need Groups=] linked to `GRANT`
    via `GRANT hasPreparedAccessNeedGroup`
1. Let `DGRANTS` be the [=Data Grants=] linked to `GRANT`
    via `GRANT hasDataGrant`
1. For each [=Prepared Access Need Group=] `PGROUP` in `PGROUPS`:
    1. For each [=Prepared Access Need=] `PNEED` in `PGROUP` traversed via
        `PNEED skos:narrower` or `PNEED referencesPreparedAccessNeed`:
        1. Let `NDGRANT` be the [=Data Grant=] associated with
            `NEED` via `NEED hasDataGrant`
            1. Error if `NDGRANT` is missing
            1. Error if `NDGRANT satisfiesPreparedAccessNeed` doesn't link to `NEED`
            1. Error if `eco:RegisteredShapeTree` is not the same in `NDGRANT` and `NEED`
1. For each [=Data Grant=] `DGRANT` in `DGRANTS`
    1. Let `NEEDS` be all [=Prepared Access Needs=] across `PGROUPS`
    1. Let `DGNEEDS` be all [=Prepared Access Needs=] linked to `DGRANT` via
        `DGRANT satisfiesPreparedAccessNeed`
    1. Error if `DGNEEDS` is not in `NEEDS`
    1. Error if `DGNEEDS` is empty
    1. Error if `DGRANT` access modes are not an exact union of
        `DGNEEDS accessMode` values when `DGRANT scopeOfDataGrant` is not
        `eco:NoAccess`

### Record Grant ### {#access-recordgrant}

This operation stores a new or updated [=Access Grant=] in
an [=Access Registry=], applies permissions accordingly, and
calls for an access receipt to be provided.

#### Inputs #### {#recordgrant-inputs}

* Let `GRANT` be an [=Access Grant=]
* Let `REGISTRY` be an [=Access Registry=]

#### Outputs #### {#recordgrant-outputs}

* An [=Access Grant=] stored in `REGISTRY` with permissions applied and
    [=Access Receipt=] provided

#### Operation Details #### {#recordgrant-details}

1. Call [[#access-validategrant]] with inputs: `GRANT`.
    <em class="rfc2119">MUST</em> return a status code of 400 if
    validation fails.
1. Add or Update `GRANT` resource in the `REGISTRY` container, conforming to
    the assigned [ecot:access-grant-tree](ecosystem.tree#access-grant-tree).
1. Link `GRANT` to the `REGISTRY` via `ACCESS hasRegistration` if
        it has not already been added
1. Call [[#access-applyperms]] with inputs: `GRANT`
1. TODO - CALL TO PROVIDE ACCESS RECEIPT GOES HERE
1. Return `GRANT`

Issue: Need to properly factor in multi-pod scenarios. Must identify the
proper access registry to store things in based on the data registration, which
means pods will also need to be registered.

### Record Invitation ### {#access-recordinvitation}

This operation stores a new or updated [=Access Invitation=] in
an [=Access Registry=].

#### Inputs #### {#recordinvitation-inputs}

* Let `INVITATION` be an [=Access Invitation=]
* Let `REGISTRY` be an [=Access Registry=]

#### Outputs #### {#recordinvitation-outputs}

* An [=Access Invitation=] stored in `REGISTRY`

#### Operation Details #### {#recordinvitation-details}

1. Call [[#access-validategrant]] with inputs: `INVITATION`.
    <em class="rfc2119">MUST</em> return a status code of 400 if
    validation fails.
1. Add or Update `INVITATION` resource in the `REGISTRY` container, conforming to
    the assigned
    [ecot:access-invitation-tree](ecosystem.tree#access-invitation-tree)
1. Link `INVITATION` to the `REGISTRY` via `ACCESS hasRegistration` if
        it has not already been added
1. TODO - CALL TO DELIVER INVITATION VIA CHANNEL GOES HERE
1. Return `INVITATION`

### Deliver Invitation ### {#access-deliverinvitation}

### Validate Invitation ### {#access-validateinvitation}

### Apply Permissions ### {#access-applyperms}

#### Inputs #### {#applyperms-inputs}

* Let `GRANT` be an [=Access Grant=] linked to any new or updated
    [=Prepared Access Need Groups=] and [=Data Grants=]
    for a given [=Authorization Subject=]

#### Outputs #### {#applyperms-outputs}

* Let `GRANT` be an [=Access Grant=] that has had the relevant permissions applied.

#### Operation Details #### {#applyperms-details}

1. Let `DGRANTS` be the [=Data Grants=] linked to `GRANT`
    via `GRANT hasDataGrant`
1. For each [=Data Grant=] `DGRANT` in `GRANTS`
    1. Let the [=Data Registration=] linked via `DGRANT hasRegistration` be `DREG`
    1. If `DGRANT scopeOfDataGrant` includes `eco:NoAccess`
        1. Ignore any other scopes linked via `DGRANT scopeOfDataGrant`
        1. Let `ACL` be the [=ACL Resource=] directly associated with `DREG`
        1. Let `STATEMENTS` be any [=Authorization Statements=] in `ACL` directly
            associated with `GRANT accessGrantSubject`.
        1. For each `STATEMENT` in `STATEMENTS`
            1. Remove [=Authorization Subject=] from `STATEMENT`
            2. Remove `STATEMENT` if there are no remaining [=Authorization Subjects=]
    1. If `DGRANT scopeOfDataGrant` includes `eco:AllInstances`
        1. Error if `eco:AllInstances` is not the only scope associated via
            `DGRANT scopeOfDataGrant`
        1. Let `ACL` be the [=ACL Resource=] directly associated with `DREG`
        1. Let `STATEMENTS` be any [=Authorization Statements=] in `ACL` directly
            associated with `GRANT accessGrantSubject`.
        1. For each `STATEMENT` in `STATEMENTS`
            1. Remove [=Authorization Subject=] from `STATEMENT`
            1. Remove `STATEMENT` from `ACL` if there are no
                remaining [=Authorization Subjects=] in `STATEMENT`
        1. Add a new [=Authorization Statement=] `NEWSTATEMENT` to `ACL`
            1. Set `NEWSTATEMENT` [=Authorization Subject=] to
                `GRANT accessGrantSubject`.
            2. Set the [=access modes=] for `NEWSTATEMENT` to
                the [=access modes=] linked via `DGRANT accessMode`
                such that all [=Registered Data Instances=] in `REG` inherit
                those [=access modes=]
    1. If `DGRANT scopeOfDataGrant` includes ONLY `eco:InheritInstances`
        1. Let `IDGRANT` be the inherited [=Data Grant=]
        1. Error if `DGRANT inheritsFrom` is missing
        1. Error if `IDGRANT eco:RegisteredShapeTree` does not have a reference
            to `DGRANT eco:registeredShapeTree` via `st:references`
        1. Let `ACL` be the [=ACL Resource=] directly associated with `DREG`
        1. Let `STATEMENTS` be any [=Authorization Statements=] in `ACL` directly
            associated with `GRANT accessGrantSubject`.
        1. For each `STATEMENT` in `STATEMENTS`
            1. Remove [=Authorization Subject=] from `STATEMENT`
            1. Remove `STATEMENT` from `ACL` if there are no
                remaining [=Authorization Subjects=] in `STATEMENT`
        1. Add a new [=Authorization Statement=] `NEWSTATEMENT` to `ACL`
            1. Set `NEWSTATEMENT` [=Authorization Subject=] to
                `GRANT accessGrantSubject`.
            1. Set the [=access modes=] for `NEWSTATEMENT` to
                the [=access modes=] linked via `DGRANT accessMode`
                such that all [=Registered Data Instances=] in `REG` inherit
                those [=access modes=], with the following condition:
                    1. Access will only be granted to
                        [=Registered Data Instances=] when a link exists between
                        `IDGRANT eco:registeredShapeTree` and
                        `DGRANT eco:registeredShapeTree`.
                    1. The predicate of the link must be the same as the
                        property detailed in `st:traverseViaShapePath`, in the
                        `st:references` from `IDGRANT eco:registeredShapeTree`
    1. If `DGRANT scopeOfDataGrant` includes `eco:InheritInstances` AND `eco:SelectedInstances`
        1. Error if any other scopes are associated via `DGRANT scopeOfDataGrant`
        1. Error if `DGRANT inheritsFrom` is missing
        1. Error if `IDGRANT eco:RegisteredShapeTree` does not have a reference
            to `DGRANT eco:registeredShapeTree` via `st:references`
        1. Use instructions for `eco:SelectInstances`
    1. If `DGRANT scopeOfDataGrant` includes `eco:SelectedInstances`
        1. Let `INSTANCES` be the [=Registered Data Instances=] linked via
            `DGRANT eco:hasRegisteredDataInstance`
        1. Error if there are no `INSTANCES`
        1. For each `INSTANCE` in `INSTANCES`
          1. Error if `INSTANCE` is missing
          1. Let `ACL` be the [=ACL Resource=] directly associated with `INSTANCE`
          1. Let `STATEMENTS` be any [=Authorization Statements=] in `ACL` directly
              associated with `GRANT accessGrantSubject`
          1. For each `STATEMENT` in `STATEMENTS`
              1. Remove [=Authorization Subject=] from `STATEMENT`
              1. Remove `STATEMENT` from `ACL` if there are no
                  remaining [=Authorization Subjects=] in `STATEMENT`
          1. Add a new [=Authorization Statement=] `NEWSTATEMENT` to `ACL`
              1. Set `NEWSTATEMENT` [=Authorization Subject=] to
                  `GRANT accessGrantSubject`.
              1. Set the [=access modes=] for `NEWSTATEMENT` to
                  the [=access modes=] linked via `DGRANT accessMode`
              1. If `INSTANCE` is a container, ensure all [=resources=] in the
                  container are set to inherit those [=access modes=]

Issue: Deal with cases when the data registration doesn't exist yet

Issue: Append mode for AllInstances needs to be specially handled, and may
require an additional attribute specified in the requested [=Access Needs=]

### Present Grant ### {#access-present}

This operation is non-normative, and meant to instruct
a developer in how to load and initialize an [=Access Grant=] or
[=Access Invitation=], present it to an [=Agent=], invoke the appropriate
operations to manipulate [=Data Grants=] in accordance with the
[=Agent's=] decisions, and then record and act upon those decisions.

#### Inputs #### {#present-inputs}

* Let `SUBJECT` be an [=Access Grant Subject=]
* Let `TARGET` be the `eco:channelTarget` of an [=Access Invitation=]
* Let `ICHANNELS` be a set of [=Access Invitation Channels=] for a new
    [=Access Invitation=]
* Let `REGISTRY` be an [=Access Registry=]
* Let `GROUPS` be an optional set of [=Access Need Groups=]
* Let `LANG` be the [=Agent's=] preferred language

#### Operation Details #### {#present-details}

1. <em class="rfc2119">MUST</em> return a status code of 400 if both
    `SUBJECT` and `TARGET` are provided
1. If `SUBJECT` is provided
    1. Let `GRANT` be an [=Access Grant=] returned by [[#access-loadgrant]] with
        inputs: `SUBJECT`, `REGISTRY`
        1. If `GRANT` is missing, let `GRANT` be an [=Access Grant=] returned
            by [[#access-initialize]] with inputs: `SUBJECT`, `REGISTRY`,
            `GROUPS`, `LANG`.
    1. Present the [=Access Grant Subject=]
1. If `TARGET` is provided
    1. Let `GRANT` be an [=Access Invitation=] returned by
        [[#access-loadinvitation]] with inputs: `TARGET`, `REGISTRY`
        1. If `GRANT` is missing, let `GRANT` be an [=Access Invitation=]
            returned by [[#access-initialize]] with inputs: `ICHANNELS`,
            `REGISTRY`, `GROUPS`, `LANG`
1. If available, present the [=Agent=] who granted access via `registeredBy`
1. If available, present the [=Application=] used by the [=Agent=] to grant
    access via `registeredWith`
1. If available, present the timestamp of creation via `registeredAt`,
    and update via `updatedAt`
1. For each [=Prepared Access Need Group=] `PGROUP` linked via
    `GRANT hasPreparedAccessNeedGroup`
    1. Let `GDEC` be the [=Access Need Group Decorator=] linked via
        `PGROUP hasAccessNeedGroupDecorator`
    1. Present the group name via `GDEC skos:prefLabel`
    1. Present the group description via `GDEC skos:definition`
    1. Identify the [=Agent=] that will be granted access via `authenticatesAs`.
        `eco:Pilot` indicates a piloted application.
    1. If `PGROUP accessNecessity` is `AccessOptional` and `PGROUP isEnabled`
        is `true`, allow the group to be disabled by invoking the
        [[#access-denygroup]] operation with inputs: `GRANT`, `PREPARED`
    1. If `PGROUP accessNecessity` is `AccessOptional` and `PGROUP isEnabled`
        is false, allow the group to be enabled by setting `PGROUP isEnabled`
        to `true`.
    1. If (`PGROUP accessNecessity` is `AccessOptional` and `PGROUP isEnabled`),
        or if `PGROUP accessNecessity` is `AccessRequired`
        1. For each [=Root Prepared Access Need=] `ROOT` linked via
            `PGROUP hasPreparedAccessNeed`
              1. For each [=Prepared Access Need=] `PNEED` starting with `ROOT`
                  and traversed via `PNEED skos:narrower` or
                  `PNEED referencesPreparedAccessNeed`:
                  1. Let `DATAGRANT` be `PNEED hasDataGrant`
                  1. Let `NDEC` be `PNEED hasAccessNeedDecorator`
                  1. Let `STDEC` be `PNEED hasShapeTreeDecorator`
                  1. If `PNEED accessNecessity` is `AccessOptional`,
                      and `DATAGRANT scopeOfDataGrant` is `eco:NoAccess`
                      1. Allow access selection to be enabled and managed as detailed
                          in the remainder of this operation.
                  1. Present the name of the [=shape tree=] via `STDEC skos:prefLabel`
                  1. Present the reason access to this data is needed via
                      `NDEC skos:prefLabel`
                  1. For each [=Supporting Access Need=] `SUPPORTING` linked
                      via `PNEED supportedBy`
                      1. Present the name of the [=shape tree=] via the
                          associated [=Shape Tree Decorator=]
                      1. Present the reason access to this data is needed via the
                          associated [=Access Need Decorator=]
                  1. If `DATAGRANT scopeOfDataGrant` is `eco:NoAccess`
                      1. Allow `eco:AllInstances` to be selected, which invokes
                          the [[#access-selectall]] operation with inputs:
                          `GRANT`, `PGROUP`, `PNEED`
                      1. Allow a subset of [=Registered Data Instances=] be selected,
                          and let `INSTANCES` be that subset, invoking
                          the [[#access-select]] operation with inputs:
                          `INSTANCES`, `GRANT`, `PGROUP`, `PNEED`
                  1. If `DATAGRANT scopeOfDataGrant` is `eco:AllInstances`, then
                      present the user with summary details, and the ability to
                      see specific instances.
                          1. Let `INSTANCES` be a selected set of
                              [=Registered Data Instances=]
                          1. If the user chooses to select
                              specific instances from this list, invoke the
                              [[#access-select]] operation with inputs: `INSTANCES`,
                              `GRANT`, `PGROUP`, `PNEED`.
                  1. If `DATAGRANT scopeOfDataGrant` is `eco:SelectedInstances`, then
                      present the user with the specific instances they have selected,
                      and:
                          1. Let `INSTANCES` be a selected set of
                              [=Registered Data Instances=]
                          1. Allow the selected [=Registered Data Instances=] to be
                              adjusted, and invoke the [[#access-select]] operation with
                              inputs: `INSTANCES`, `DATAGRANT`, `PGROUP`, `PNEED`.
                          1. Allow all [=Registered Data Instances=] to be selected,
                              invoking the [[#access-selectall]] operation with inputs:
                              `GRANT`, `PGROUP`, `PNEED`.
                  1. If `DATAGRANT scopeOfDataGrant` is `eco:InheritInstances`, present
                      the inherited [=Registered Data Instances=] and:
                      1. Let `INSTANCES` be a selected set of
                          [=Registered Data Instances=]
                      1. Allow a subset to be selected, invoking
                          the [[#access-select]] operation with inputs: `INSTANCES`,
                          `GRANT`, `PGROUP`, `PNEED`
                      1. Identify the [=Prepared Access Need=] / [=Data Grant=]
                          and selected [=Registered Data Instances=] that were inherited
                          from.
                  1. If `DATAGRANT scopeOfDataGrant` includes `eco:SelectedInstances`
                      and `eco:InheritInstances`
                      1. Let `INSTANCES` be a selected set of
                          [=Registered Data Instances=]
                      1. Give the ability to adjust the selected instances, invoking
                          the [[#access-select]] operation with inputs:
                          `INSTANCES`, `GRANT`, `PGROUP`, `PNEED`.
                      1. Give the ability to revert to all inherited instances,
                          invoking the [[#access-selectall]] operation with inputs:
                          `GRANT`, `PGROUP`, `PNEED`
    1. Call [[#access-recordgrant]] if `GRANT` is an [=Access Grant=] to save.
    1. Call [[#access-recordinvitation]] if `GRANT` is an [=Access Invitation=] to
        save.

Issue: Consider when an existing Access Need Group is expanded or contracted

Issue: Consider when there are new Groups being requested from a given Agent

### Deny Prepared Access Need Group ### {#access-denygroup}

This operation is used when a given [=Prepared Access Group=] with optional
necessity has been denied.

#### Inputs #### {#denygroup-inputs}

* Let `GRANT` be an [=Access Grant=]
* Let `PGROUP` be a [=Prepared Access Need Group=]

#### Operation Details #### {#denygroup-details}

1. Let `PGROUP isEnabled` be `false` if `PGROUP accessNecessity` is
    `eco:AccessOptional`
1. For each [=Prepared Access Need=] `PNEED` in `PGROUP`
    1. Let `DATAGRANT` be `PNEED hasDataGrant`
    1. Let `DATAGRANT scopeOfDataGrant` be `eco:NoAccess`

### Select Specific Instances for Access ### {#access-select}

Used to select specific [=Registered Data Instances=] for a given
[=Data Grant=], which has a recursive application down the hierachy,
with subordinate [=Data Grants=] reducing their associated scope of
[=Registered Data Instances=] to only those related to the instances above them.

#### Inputs #### {#select-inputs}

#### Inputs #### {#select-outputs}

#### Operation Details #### {#select-details}


### Select All Instances for Access ### {#access-selectall}

Used to select all [=Registered Data Instances=] for a given [=Data Grant=].
In the event where this is moving from a subset of inherited instances,
this will expand to only include all inherited instances.

#### Inputs #### {#selectall-inputs}

#### Inputs #### {#selectall-outputs}

#### Operation Details #### {#selectall-details}


Access Receipts {#receipts}
=====================

## Overview ## {#receipts-overview}

## Data Model ## {#receipts-datamodel}

### Summary ### {#receipts-datamodel-summary}

<figure id="fig-receipt-model">
  <img src="diagrams/receipt-model.svg" width=100%/>
  <figcaption>Data model for the [=Access Receipt Registry=]</figcaption>
</figure>

The [=Access Receipt Registry=] extends the [[#reg-model]] with type-specific
subclasses and subproperties.

An [=Agent=] has a [=Registrar=] that links to [=Access Receipt Registry Sets=]
via the [eco:hasAccessReceiptRegistrySet](ecosystem.ttl#hasAccessReceiptRegistrySet) property.

An [=Access Receipt Registry Set=] links to any number of
[=Access Receipt Registries=] via
the [eco:hasRegistry](ecosystem.ttl#hasRegistry) property.

An [=Access Receipt Registry=] links to any number of registered
[=Access Receipts=] via the
[eco:hasRegistration](ecosystem.ttl#hasRegistration) property.

<figure id="fig-receipt-registrar">
  <figcaption>A [=Registrar=] at https://bob.pod.example/registries/#registrar
  linking to an [=Access Receipt Registry Set=]</figcaption>
  <pre highlight="turtle">
  <#registrar>
    a eco:Registrar;
    eco:hasAccessReceiptRegistrySet &lt;https://bob.pod.example/registries/receipt#set&gt; .
  </pre>
  </figure>
</figure>

<figure id ="fig-receipt-registry-set">
   <figcaption>An [=Access Receipt Registry Set=] at
   https://bob.pod.example/registries/receipt#set linking to two different
  [=Access Receipt Registries=]</figcaption>
  <pre highlight="turtle">
  <#set>
    a eco:AccessReceiptRegistrySet;
    eco:hasRegistry &lt;https://bob.pod.example/receipts/#registry&gt; ,
                    &lt;https://bob.otherpod.example/receipts/#registry&gt; .
  </pre>
</figure>

<figure id="fig-receipt-registry">
  <figcaption>An [=Access Receipt Registry=] at
  https://bob.pod.example/receipts/#registry
  linking to several registered [=Access Receipts=]
  </figcaption>
  <pre highlight="turtle">
  <#registry>
    a eco:AccessReceiptRegistry ;
    eco:hasRegistration &lt;fa6d6553-0308-4abd-bce6-888df653695a#receipt&gt; ,
                        &lt;d49eae8c-e138-4153-86ed-63832deadc6b#receipt&gt; ,
                        &lt;506a0cee-1dc9-4720-a768-294aa0284502#receipt&gt; .
  </pre>
</figure>

<figure id="fig-access-receipt">
  <figcaption>An [=Access Receipt=] at
  https://bob.pod.example/receipts/fa6d6553-0308-4abd-bce6-888df653695a#receipt
  </figcaption>
  <pre highlight="turtle">
  <#receipt>
    a eco:AccessReceipt ;
    eco:registeredBy https://bob.pod.example/profile/id#me ;
    eco:registeredWith https://trusted.example/id#agent ;
    eco:registeredAt "2020-09-05T06:15:01Z"^^xsd:dateTime ;
    eco:updatedAt "2020-09-05T06:15:01Z"^^xsd:dateTime ;
    eco:fromAgent https://alice.pod.example/profile/id#me ;
    eco:toAgent https://bob.pod.example/profile/id#me ;
    eco:hasDataReceipt <#notebook-receipt>, <#note-receipt> .

  <#notebook-receipt>
    a eco:DataReceipt ;
    eco:hasRegistration https://alice.pod.example/data/notebook/#registration ;
    eco:registeredShapeTree note:notebook-tree ;
    eco:accessMode acl:Read, acl:Write ;
    eco:scopeOfDataGrant eco:SelectedInstances ;
    eco:hasRegisteredDataInstance https://alice.pod.example/data/notebook/notebook-1/#notebook ,
                                  https://alice.pod.example/data/notebook/notebook-2/#notebook .

  <#note-receipt>
    a eco:DataReceipt ;
    eco:hasRegistration https://alice.pod.example/data/note/#registration ;
    eco:registeredShapeTree note:note-tree ;
    eco:accessMode acl:Read, acl:Write ;
    eco:scopeOfDataGrant eco:inheritInstances ;
    eco:inheritsFrom <#notebook-receipt> ;
    eco:hasRegisteredDataInstance https://alice.pod.example/data/note/note-1/#note ,
                                  https://alice.pod.example/data/note/note-2/#note ,
                                  https://alice.pod.example/data/note/note-3/#note ,
                                  https://alice.pod.example/data/note/note-4/#note ,
                                  https://alice.pod.example/data/note/note-5/#note .
  </pre>
</figure>

### Access Receipt Registry Set ### {#datamodel-receipt-registry-set}

An <dfn>Access Receipt Registry Set</dfn> is a [=Registry Set=] specifically
made up of [=Access Receipt Registries=].

<table class="classinfo data" align="left" id="classAccessReceiptRegistrySet">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3 text-align=left>
        [AccessReceiptRegistrySet](ecosystem.ttl#AccessReceiptRegistrySet)
        a rdfs:subClassOf [[#reg-model|RegistrySet]]
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>hasRegistry</td>
      <td>Registry</td>
      <td>Link to associated [=Access Receipt Registries=]</td>
    </tr>
  </tbody>
</table>

The [AccessReceiptRegistrySetShape](#shexAccessReceiptRegistrySet) is used to
validate an instance of the
[AccessReceiptRegistrySet](#classAccessReceiptRegistrySet) class.

<pre highlight="turtle" id="shexAccessReceiptRegistrySet">
<#AccessReceiptRegistrySetShape> {
  a [ eco:AccessReceiptRegistrySet ] ;
  eco:hasRegistry IRI+
}
</pre>

The [AccessReceiptRegistrySetTree](ecosystem.tree#access-receipt-registry-set-tree)
is assigned to a resource to ensure it will validate against the
[AccessReceiptRegistrySetShape](#shexAccessReceiptRegistrySet).

<pre highlight="turtle" id="treeAccessReceiptRegistrySet">
<#access-receipt-registry-set-tree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeResource ;
  st:validatedBy &lt;ecos#AccessReceiptRegistrySetShape&gt; ;
  st:matchesUriTemplate "receipt" .
</pre>

### Access Receipt Registry ### {#datamodel-access-receipt-registry}

An <dfn>Access Receipt Registry</dfn> is a collection of
[=Access Receipts=] stored in a specific location in a [=pod=].

<table class="classinfo data" align="left" id="classAccessReceiptRegistry">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessReceiptRegistry](ecosystem.ttl#AccessReceiptRegistry)
        a rdfs:subClassOf [[#reg-model|Registry]]
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>hasRegistration</td>
      <td>Registration</td>
      <td>Link to associated [=Access Receipts=]</td>
    </tr>
  </tbody>
</table>

The [AccessReceiptRegistryShape](#shexAccessReceiptRegistry) is used to
validate an instance of the
[AccessReceiptRegistry](#classAccessReceiptRegistry) class.

<pre highlight="turtle" id="shexAccessReceiptRegistry">
<#AccessReceiptRegistryShape> {
  a [ eco:AccessReceiptRegistry ] ;
  eco:hasRegistration IRI*
}
</pre>

The [AccessReceiptRegistryTree](ecosystem.tree#access-receipt-registry-tree)
is assigned to a container resource to ensure that it will validate against the
[AccessReceiptRegistryShape](#shexAccessReceiptRegistry), and contain only
conformant instances of the [AccessReceiptTree](#treeAccessReceipt).

<pre highlight="turtle" id="treeAccessReceiptRegistry">
<#access-receipt-registry-tree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeContainer ;
  st:validatedBy &lt;ecos#AccessReceiptRegistryShape&gt; ;
  st:contains <#access-receipt-tree> ,
              st:AllowNone .
</pre>

### Access Receipt ### {#datamodel-access-receipt}

Each <dfn>Access Receipt</dfn>

<table class="classinfo data" align="left" id="classAccessReceipt">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessReceipt](ecosystem.ttl#AccessReceipt)
        a rdfs:subClassOf [[#reg-model|Registration]]
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>registeredBy</td>
      <td>Agent</td>
      <td>[=Agent=] that registered the [=Access Receipt=]</td>
    </tr>
    <tr>
      <td>registeredWith</td>
      <td>Application</td>
      <td>[=Application=] used to create the [=Access Receipt=]</td>
    </tr>
    <tr>
      <td>registeredAt</td>
      <td>xsd:dateTime</td>
      <td>Date and time the [=Access Receipt=] was created</td>
    </tr>
    <tr>
      <td>updatedAt</td>
      <td>xsd:dateTime</td>
      <td>Date and time the [=Access Receipt=] was updated</td>
    </tr>
    <tr>
      <td>fromAgent</td>
      <td>Agent</td>
      <td>[=Agent=] that granted access and sent the [=Access Receipt=]</td>
    </tr>
    <tr>
      <td>toAgent</td>
      <td>Agent</td>
      <td>[=Agent=] who was granted access and received the [=Access Receipt=]</td>
    </tr>
    <tr>
      <td>hasDataReceipt</td>
      <td>[DataReceipt](#classDataReceipt)</td>
      <td>[=Data Receipt=] for a shared [=Data Registration=] and any shared
      [=Registered Data Instances=]</td>
    </tr>
  </tbody>
</table>

The [AccessReceiptShape](#shexAccessReceipt) is used to validate an instance
of the [AccessReceipt](#classAccessReceipt) class.

<pre highlight="turtle" id="shexAccessReceipt">
<#AccessReceiptShape> {
  a [eco:AccessReceipt] ;
  eco:fromAgent IRI ;             # Agent who sent the receipt
  eco:toAgent IRI ;               # Recipient of the receipt
  eco:registeredBy IRI ;
  eco:registeredWith IRI? ;
  eco:registeredAt xsd:dateTime ;
  eco:updatedAt xsd:dateTime ;
  eco:hasDataReceipt @<#:DataReceiptShape> ;
}
</pre>

The [AccessReceiptTree](ecosystem.tree#access-receipt-tree) is assigned to a
resource via the [AccessRegistryTree](#treeAccessRegistry), and ensures
that the assigned resource will validate against the
[AccessReceiptShape](#shexAccessReceipt).

<pre highlight="turtle" id="treeAccessReceipt">
<#access-receipt-tree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeResource ;
  st:validatedBy &lt;ecos#AccessReceiptShape&gt; ;
  st:matchesUriTemplate "{id}" .
</pre>

### Data Receipt ### {#datamodel-data-receipt}

A <dfn>Data Receipt</dfn> ...

<table class="classinfo data" align="left" id="classDataReceipt">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [DataReceipt](ecosystem.ttl#DataReceipt)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>hasRegistration</td>
      <td>DataRegistration</td>
      <td>Remote [=Data Registration=] the [=Data Receipt=] applies to</td>
    </tr>
    <tr>
      <td>registeredShapeTree</td>
      <td>st:ShapeTree</td>
      <td>The [=shape tree=] registered at the target [=Data Registration=]</td>
    </tr>
    <tr>
      <td>accessMode</td>
      <td>acl:Read, acl:Write, acl:Control, acl:Append</td>
      <td>Access modes granted</td>
    </tr>
    <tr>
      <td>scopeOfDataGrant</td>
      <td> eco:AllInstances, eco:InheritInstances,
      eco:SelectedInstances, eco:NoAccess</td>
      <td>Identifies the access scope of the [=Data Grant=]
        <ul>
          <li>eco:AllInstances - Scope includes
              access to all [=Registered Data Instances=] of the associated
              [=Data Registration=]</li>
          <li>eco:InheritInstances - Scope includes
              access to [=Registered Data Instances=] inherited by
              instances selected in the [=Data Receipt=] linked via
              eco:inheritsFrom</li>
          <li>eco:SelectedInstances - Scope includes
              access only to those [=Registered Data Instances=] specifically
              selected by the [=Agent=]</li>
          <li>eco:NoAccess</li> - No access is granted
        </ul>
      </td>
    </tr>
    <tr>
      <td>inheritsFrom</td>
      <td>[DataReceipt](#classDataReceipt)</td>
      <td>Identifies a [=Data Receipt=] whose selected
      [=Registered Data Instances=] narrow the scope of instances to be
      presented by this receipt.</td>
    </tr>
    <tr>
      <td>hasRegisteredDataInstance</td>
      <td>Instance of registeredShapeTree</td>
      <td>Links to a [=Registered Data Instance=] of registeredShapeTree.</td>
    </tr>
  </tbody>
</table>

The [DataReceiptShape](#shexDataReceipt) is used to
validate an instance of the [DataReceipt](#classDataReceipt)
class.

<pre highlight="turtle" id="shexDataReceipt">
<#DataReceiptShape> {
  a [eco:DataReceipt] ;
  eco:hasRegistration IRI ;       # Remote data registration
  eco:registeredShapeTree IRI ;   # Associated shape tree
  eco:accessMode [ acl:Read acl:Write acl:Append acl:Control ]+ ;
  eco:scopeOfDataGrant [ eco:SelectedInstances eco:AllInstances eco:InheritInstances eco:NoAccess ]+ ;
  eco:hasRegisteredDataInstance IRI* ;     # if specific instances are selected or inherited
  eco:inheritsFrom @<#:DataReceiptShape>*
}
</pre>

## Resource Hierarchy ## {#receipts-hierarchy}

<table class="data tree" align="left">
  <col>
  <col>
  <col>
  <col>
  <thead>
    <tr>
      <th>Resource</th>
      <th>Class</th>
      <th>Shape</th>
      <th>Shape Tree</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`/registries/#registrar`</td>
      <td>[Registrar](#)</td>
      <td>[RegistrarShape](#)</td>
      <td>[RegistrarTree](#)</td>
    </tr>
    <tr>
      <td>`-- receipt#set`</td>
      <td>[AccessReceiptRegistrySet](#classAccessReceiptRegistrySet)</td>
      <td>[AccessReceiptRegistrySetShape](#shexAccessReceiptRegistrySet)</td>
      <td>[AccessReceiptRegistrySetTree](#treeAccessReceiptRegistrySet)</td>
    </tr>
    <tr>
      <td>`/receipts/#registry`</td>
      <td>[AccessReceiptRegistry](#classAccessReceiptRegistry)</td>
      <td>[AccessReceiptRegistryShape](#shexAccessReceiptRegistry)</td>
      <td>[AccessReceiptRegistryTree](#treeAccessReceiptRegistry)</td>
    </tr>
    <tr>
      <td>`-- fa6d6553...5a#receipt`</td>
      <td>[AccessReceipt](#classAccessReceipt)</td>
      <td>[AccessReceiptShape](#shexAccessReceipt)</td>
      <td>[AccessReceiptTree](#treeAccessReceipt)</td>
    </tr>
    <tr>
      <td>`-- d49eae8c...6b#receipt`</td>
      <td>[AccessReceipt](#classAccessReceipt)</td>
      <td>[AccessReceiptShape](#shexAccessReceipt)</td>
      <td>[AccessReceiptTree](#treeAccessReceipt)</td>
    </tr>
    <tr>
      <td>`-- 506a0cee...02#receipt`</td>
      <td>[AccessReceipt](#classAccessReceipt)</td>
      <td>[AccessReceiptShape](#shexAccessReceipt)</td>
      <td>[AccessReceiptTree](#treeAccessReceipt)</td>
    </tr>
  </tbody>
</table>

The [=Access Receipt Registry Set=] and the [=Access Receipt Registry=]
<em class="rfc2119">MAY</em> or <em class="rfc2119">MAY NOT</em>
be on the same [=pod=].

[=Access Receipt Registry Set=] and [=Access Receipt Registry=] resources
<em class="rfc2119">MAY</em> use any resource or subject names.

[=Access Receipts=] <em class="rfc2119">MUST</em>
use \[UUIDs](https://www.ietf.org/rfc/rfc4122.txt) for resource names.

## Operations ## {#receipts-operations}

### Provide Access Receipt ### {#receipts-provide}

#### Inputs #### {#provide-inputs}

* Let `GRANT` be an [=Access Grant=]
* Let `CONTROLLER` be the [=Agent=] granting access

#### Outputs #### {#provide-outputs}

* A provided [=Access Receipt=]

#### Operation Details #### {#provide-details}

1. Let `REC-SUBJECT` be the [=Access Grant Subject=] linked via
    `GRANT hasAccessGrantSubject`
1. Let `REC-AGENT` be `REC-SUBJECT accessByAgent`
1. Let `REC-APP` be `REC-SUBJECT accessByApplication`
1. Let `RECEIPT` be an empty [=Access Receipt=]
1. If `REC-APP` is not empty
    1. If `REC-APP eco:receivesAccessReceipt` is `ReceiptInRegistration`
        1. Let `RECEIPT` be result of [[#provide-registration]] with
            inputs: `GRANT`
    1. If `REC-APP eco:receivesAccessReceipt` is `ReceiptInMessage`
        1. Let `RECEIPT` be result of [[#provide-message]] with
            inputs: `GRANT`
1. If `REC-APP` is empty and `REC-AGENT` is not empty
    1. Return error if `REC-AGENT eco:receivesAccessReceipt` is not
        `ReceiptInMessage`
    1. Let `RECEIPT` be result of [[#provide-message]] with inputs: `GRANT`
1. Return `RECEIPT`

#### Provide Receipt in Application Registration #### {#provide-registration}

##### Inputs ##### {#provide-registration-inputs}

* Let `GRANT` be an [=Access Grant=]
* Let `CONTROLLER` be the [=Agent=] granting access

##### Outputs ##### {#provide-registration-outputs}

* An [=Access Receipt=] stored in an [=Application Registration=]

##### Operation Details ##### {#provide-registration-details}

1. Let `REC-SUBJECT` be the [=Access Grant Subject=] linked via
    `GRANT hasAccessGrantSubject`
1. Let `REC-APP` be `REC-SUBJECT accessByApplication`
1. 1. Let `RECEIPT` be an empty [=Access Receipt=]
1. Let `RECEIPT fromAgent` be `CONTROLLER`
1. Let `RECEIPT toAgent` be `REC-APP`
1. For each [=Data Grant=] `DATAGRANT` linked via `GRANT hasDataGrant`
    1. Let `RECEIPT hasDataReceipt` be linked to the result of
        [[#provide-datareceipt]] with inputs: `DATAGRANT`
1. Let `APPREG` be result of [[#appreg-lookup]] with
    inputs: `CONTROLLER`, `REC-APP`
    1. Call [[#appreg-new]] if `APPREG` is empty
1. Post `RECEIPT` to `APPREG` container
1. Let `CURRENT` be `APPREG hasAccessReceipt`
1. Remove `CURRENT` if it exists
1. Let `APPREG hasAccessReceipt` be `CURRENT`
1. Return `RECEIPT`

#### Provide Data Receipt #### {#provide-datareceipt}

##### Inputs ##### {#provide-datareceipt-inputs}

* Let `DATAGRANT` be a [=Data Grant=]
* Let `CONTROLLER` be the [=Agent=] granting access

##### Outputs ##### {#provide-datareceipt-outputs}

* A populated [=Data Receipt=]

##### Operation Details ##### {#provide-datareceipt-details}

1. Let `DATARECEIPT` be an empty [=Data Receipt=]
1. Let `DATARECEIPT hasRegistration` be `DATAGRANT hasRegistration`
1. Let `DATARECEIPT registeredShapeTree` be `DATAGRANT registeredShapeTree`
1. Let `DATARECEIPT accessMode`s be the same as `DATAGRANT accessMode`s
1. Let `DATARECEIPT scopeOfDataGrant`s be the same as `DATAGRANT scopeOfDataGrant`s
1. Let `DATARECEIPT hasRegisteredDataInstance`s be the same as
    `DATAGRANT hasRegisteredDataInstance`s
1. Let `DATARECEIPT inheritsFrom`s be the same as `DATAGRANT inheritsFrom`s
1. Return `DATARECEIPT`

#### Provide Receipt in Message #### {#provide-message}

##### Inputs ##### {#provide-message-inputs}

* Let `GRANT` be an [=Access Grant=]
* Let `CONTROLLER` be the [=Agent=] granting access

##### Outputs ##### {#provide-message-outputs}

* An [=Access Receipt=] posted to another [=Agent's=] access inbox

##### Operation Details ##### {#provide-message-details}

1. Let `REC-SUBJECT` be the [=Access Grant Subject=] linked via
    `GRANT hasAccessGrantSubject`
1. Let `REC-AGENT` be `REC-SUBJECT accessByAgent`
1. Let `RECEIPT` be an empty [=Access Receipt=]
1. Let `RECEIPT fromAgent` be `CONTROLLER`
1. Let `RECEIPT toAgent` be `REC-AGENT`
1. For each [=Data Grant=] `DATAGRANT` linked via `GRANT hasDataGrant`
    1. Let `RECEIPT hasDataReceipt` be linked to the result of
        [[#provide-datareceipt]] with inputs: `DATAGRANT`
1. Post `RECEIPT` to `REC-AGENT hasAccessInbox`
1. Return `RECEIPT`

### Record Access Receipt ### {#receipts-record}

This operation stores a new [=Access Receipt=] in
an [=Access Registry=], which in turn will update [=Remote Data Registries=]
to reflect the access granted in the [=Access Receipt=].

#### Inputs #### {#recordreceipt-inputs}

* Let `RECEIPT` be an [=Access Receipt=]
* Let `REGISTRY` be an [=Access Receipt Registry=]

#### Outputs #### {#recordreceipt-outputs}

* An [=Access Receipt=] stored in `REGISTRY` with permissions applied and
    [=Access Receipt=] provided

#### Operation Details #### {#recordreceipt-details}

1. Let `CURRENT` be an [=Access Receipt=] returned by [[#receipts-load]] with
    inputs: `FROMAGENT`, `REGISTRY`
1. If `CURRENT` is empty
    1. Add `RECEIPT` to `REGISTRY`
    1. Link `RECEIPT` to `REGISTRY` via `REGISTRY hasRegistration`
1. If `CURRENT` is not empty
    1. Update `CURRENT` with `RECEIPT`
1. Call [[#remote-update]] with inputs: `RECEIPT`
1. Return `RECEIPT`

### Load Access Receipt ### {#receipts-load}

#### Inputs #### {#loadreceipt-inputs}

* Let `AGENT` be an [=Agent=] to load a receipt for
* Let `REGISTRY` be an [=Access Receipt Registry=] to load from

#### Outputs #### {#loadreceipt-outputs}

* An [=Access Receipt=]

#### Operation Details #### {#loadreceipt-details}

1. For each [=Access Receipt=] `RECEIPT` included in `REGISTRY hasRegistration`
    1. return `RECEIPT` if `RECEIPT fromAgent` == `AGENT`

### Present Access Receipt ### {#receipts-present}

This operation shows an [=Agent=] an [=Access Receipt=] that was
delivered to them from another [=Agent=] who granted them access to the
data reflected in the receipt.

It presents them the access that has been granted in the receipt,
and prompts them to accept it. Acceptance will record the receipt in their
[=Access Receipt Registry=], and update their [=Remote Data Registry=] to
reflect it.

#### Inputs #### {#presentreceipt-inputs}

* Let `RECEIPT` be an [=Access Receipt=]
* Let `REGISTRY` be an [=Access Receipt Registry=]
* Let `LANG` be the [=Agent's=] preferred language

#### Operation Details #### {#presentreceipt-details}

1. Present `RECEIPT fromAgent` as the [=Agent=] granting access
1. Present `RECEIPT toAgent` as the [=Agent=] receiving access
1. Let `CURRENT` be an [=Access Receipt=] returned by [[#receipts-load]] with
    inputs: `RECEIPT fromAgent`, `REGISTRY`
1. If `CURRENT` is not empty
    1. Present the [=Agent=] that accepted it via `RECEIPT registeredBy`
    1. Present the [=Application=] is was accepted with via `RECEIPT registeredWith`
    1. Present when it was registered via `RECEIPT registeredAt`
    1. Present when it was last updated via `RECEIPT updatedAt`
1. For each [=Data Receipt=] `DATARECEIPT` linked via `RECEIPT hasDataReceipt`
    1. Let `STDEC` be the [=Shape Tree Decorator=]
        returned from the [Get Shape Tree Decorator](#) operation with
        inputs: `RECEIPT registeredShapeTree`, `LANG`
    1. Present the name of the [=shape tree=] via `STDEC skos:prefLabel`
    1. Present `RECEIPT accessMode`s
    1. Present `RECEIPT scopeOfDataGrant`
        1. If `RECEIPT scopeOfDataGrant` is `eco:NoAccess`
            1. Present the user any access that is being rescinded if
                they have an existing [=Data Receipt=] from `RECEIPT fromAgent`
                for `RECEIPT registeredShapeTree`
        1. If `RECEIPT scopeOfDataGrant` is `eco:AllInstances`
            1. Present the [=Agent=] with summary details, and the ability
                to view the [=Registered Data Instances=]
        1. If `RECEIPT scopeOfDataGrant` includes `eco:SelectedInstances`
            1. Present the [=Agent=] with summary details, and the ability
                to view the [=Registered Data Instances=]
        1. If `RECEIPT scopeOfDataGrant` includes `eco:InheritInstances`
            1. Present the [=Agent=] with summary details, and the ability
                to view the [=Registered Data Instances=], along with
                pointers to the [=Data Receipt=] they inherit from.
            1. Order this [=Data Receipt=] after the [=Data Receipt=] they
                inherit from.
1. Discard [=Access Receipt=] if [=Agent=] does not accept
1. Call [[#receipts-record]] with inputs: `RECEIPT`, `REGISTRY` if [=Agent=]
    accepts the [=Access Receipt=]

Remote Data Registration {#remote}
=====================

## Overview ## {#remote-overview}

## Data Model ## {#remote-datamodel}

### Summary ### {#remote-datamodel-summary}

<figure id="fig-receipt-model">
  <img src="diagrams/remote-model.svg" width=100%/>
  <figcaption>Data model for the [=Remote Data Registry=]</figcaption>
</figure>

The [=Remote Data Registry=] extends the [[#reg-model]] with type-specific
subclasses and subproperties.

An [=Agent=] has a [=Registrar=] that links to [=Remote Data Registry Sets=]
via the [eco:hasRemoteDataRegistrySet](ecosystem.ttl#hasAccessReceiptRegistrySet)
property.

A [=Remote Data Registry Set=] links to any number of
[=Remote Data Registries=] via
the [eco:hasRegistry](ecosystem.ttl#hasRegistry) property.

A [=Remote Data Registry=] links to any number of registered
[=Remote Data Registrations=] via the
[eco:hasRegistration](ecosystem.ttl#hasRegistration) property.

A [=Remote Data Registration=] may link to one or more
[=Remote Data Instances=] via the
[eco:hasRemoteDataInstance](ecosystem.ttl#hasRemoteDataInstance) property.

<figure id="fig-remote-registrar">
  <figcaption>A [=Registrar=] at https://bob.pod.example/registries/#registrar
  linking to a [=Remote Data Registry Set=]</figcaption>
  <pre highlight="turtle">
  <#registrar>
    a eco:Registrar;
    eco:hasRemoteDataRegistrySet &lt;https://bob.pod.example/registries/receipt#set&gt; .
  </pre>
  </figure>
</figure>

<figure id ="fig-remote-registry-set">
   <figcaption>A [=Remote Data Registry Set=] at
   https://bob.pod.example/registries/remote#set linking to two different
  [=Remote Data Registries=]</figcaption>
  <pre highlight="turtle">
  <#set>
    a eco:RemoteDataRegistrySet;
    eco:hasRegistry &lt;https://bob.pod.example/remote/#registry&gt; ,
                    &lt;https://bob.otherpod.example/remote/#registry&gt; .
  </pre>
</figure>

<figure id="fig-remote-registry">
  <figcaption>An [=Remote Data Registry=] at
  https://bob.pod.example/remote/#registry
  linking to several registered [=Remote Data Registrations=]
  </figcaption>
  <pre highlight="turtle">
  <#registry>
    a eco:RemoteDataRegistry ;
    eco:hasRegistration &lt;f0ebbd29-3a5a-4770-af29-cdb7693066b4/#registration&gt; ,
                        &lt;265dff0c-b199-42d8-95b3-d1eaae91c412/#registration&gt; ,
                        &lt;f68e95eb-a61f-408c-8d83-c4f21dae6115/#registration&gt; .
  </pre>
</figure>

<figure id="fig-remote-registration">
  <figcaption>An [=Remote Data Registration=] at
  https://bob.pod.example/remote/f0ebbd29-3a5a-4770-af29-cdb7693066b4/#registration
  </figcaption>
  <pre highlight="turtle">
  <#registration>
    a eco:RemoteDataRegistration ;
    eco:registeredBy https://bob.pod.example/profile/id#me ;
    eco:registeredWith https://trusted.example/id#agent ;
    eco:registeredAt "2020-09-05T06:15:01Z"^^xsd:dateTime ;
    eco:updatedAt "2020-09-05T06:15:01Z"^^xsd:dateTime ;
    eco:hasAccessReceipt https://bob.pod.example/receipts/fa6d6553-0308-4abd-bce6-888df653695a#receipt ;
    eco:hasRegistration https://alice.pod.example/data/notebook-tree/#registration ;
    eco:registeredShapeTree note:notebook-tree ;
    eco:scopeOfDataGrant eco:SelectedInstances ;
    eco:accessMode acl:Read, acl:Write ;
    eco:hasRemoteDataInstance https://bob.pod.example/remote/f0ebbd29-3a5a-4770-af29-cdb7693066b4/cd04e76b-d64d-4cea-aacf-fb248a295002#instance ,
                              https://bob.pod.example/remote/f0ebbd29-3a5a-4770-af29-cdb7693066b4/9506b58f-3c36-4c0c-a698-712baf478deb#instance .
  </pre>
</figure>

<figure id="fig-remote-data-instance">
  <figcaption>An [=Remote Data Instance=] at
  https://bob.pod.example/remote/f0ebbd29-3a5a-4770-af29-cdb7693066b4/cd04e76b-d64d-4cea-aacf-fb248a295002
  </figcaption>
  <pre highlight="turtle">
  <#registration>
    a eco:RemoteDataInstance ;
    eco:registeredAt "2020-09-05T06:15:01Z"^^xsd:dateTime ;
    eco:updatedAt "2020-09-05T06:15:01Z"^^xsd:dateTime ;
    eco:registeredShapeTree note:notebook-tree ;
    eco:accessMode acl:Read, acl:Write ;
    eco:hasRegisteredDataInstance https://alice.pod.example/data/notebook/notebook-1/#notebook ;
    eco:hasAccessReceipt https://bob.pod.example/receipts/fa6d6553-0308-4abd-bce6-888df653695a#receipt .
  </pre>
</figure>

### Remote Data Registry Set ### {#datamodel-remote-registry-set}

A <dfn>Remote Data Registry Set</dfn> is a [=Registry Set=] specifically
made up of [=Remote Data Registries=].

<table class="classinfo data" align="left" id="classRemoteDataRegistrySet">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3 text-align=left>
        [RemoteDataRegistrySet](ecosystem.ttl#RemoteDataRegistrySet)
        a rdfs:subClassOf [[#reg-model|RegistrySet]]
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>hasRegistry</td>
      <td>Registry</td>
      <td>Link to associated [=Remote Data Registries=]</td>
    </tr>
  </tbody>
</table>

The [RemoteDataRegistrySetShape](#shexRemoteDataRegistrySet) is used to
validate an instance of the
[RemoteDataRegistrySet](#classRemoteDataRegistrySet) class.

<pre highlight="turtle" id="shexRemoteDataRegistrySet">
<#RemoteDataRegistrySetShape> {
  a [ eco:RemoteDataRegistrySet ] ;
  eco:hasRegistry IRI+
}
</pre>

The [RemoteDataRegistrySetTree](ecosystem.tree#remote-data-registry-set-tree)
is assigned to a resource to ensure it will validate against the
[RemoteDataRegistrySetShape](#shexRemoteDataRegistrySet).

<pre highlight="turtle" id="treeRemoteDataRegistrySet">
<#remote-data-registry-set-tree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeResource ;
  st:validatedBy &lt;ecos#RemoteDataRegistrySetShape&gt; ;
  st:matchesUriTemplate "receipt" .
</pre>

### Remote Data Registry ### {#datamodel-remote-data-registry}

A <dfn>Remote Data Registry</dfn> is a collection of
[=Remote Data Registrations=] stored in a specific location in a [=pod=].

<table class="classinfo data" align="left" id="classRemoteDataRegistry">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [RemoteDataRegistry](ecosystem.ttl#RemoteDataRegistry)
        a rdfs:subClassOf [[#reg-model|Registry]]
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>hasRegistration</td>
      <td>Registration</td>
      <td>Link to associated [=Remote Data Registrations=]</td>
    </tr>
  </tbody>
</table>

The [RemoteDataRegistryShape](#shexRemoteDataRegistry) is used to
validate an instance of the
[RemoteDataRegistry](#classRemoteDataRegistry) class.

<pre highlight="turtle" id="shexRemoteDataRegistry">
<#RemoteDataRegistryShape> {
  a [ eco:RemoteDataRegistry ] ;
  eco:hasRegistration IRI*
}
</pre>

The [RemoteDataRegistryTree](ecosystem.tree#remote-data-registry-tree)
is assigned to a container resource to ensure that it will validate against the
[RemoteDataRegistryShape](#shexRemoteDataRegistry), and contain only
conformant instances of the
[RemoteDataRegistrationTree](#treeRemoteDataRegistration).

<pre highlight="turtle" id="treeRemoteDataRegistry">
<#remote-data-registry-tree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeContainer ;
  st:validatedBy &lt;ecos#RemoteDataRegistryShape&gt; ;
  st:contains <#remote-data-registration-tree> ,
              st:AllowNone .
</pre>

### Remote Data Registration ### {#datamodel-remote-data-registration}

An [=Agent=] maintains a <dfn>Remote Data Registration</dfn> to represent
a [=Data Registration=] that another [=Agent=] has shared with them. It
may represent access to the entire [=Data Registration=], or only to a
select group of [=Remote Data Instances=] within.

A [=Remote Data Registration=] is created when an [=Agent=] receives an
[=Access Receipt=] from another [=Agent=] that includes access to a given
[=Data Registration=].

* A [=Remote Data Registration=] MUST be associated with an [=Access Receipt=]
* If an [=Access Receipt=] is received that changes the access to a shared
    [=Data Registration=], the corresponding [=Remote Data Registration=]
    MUST be updated, and removed altogether if that access is removed.

<table class="classinfo data" align="left" id="classRemoteDataRegistration">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [RemoteDataRegistration](ecosystem.ttl#RemoteDataRegistration)
        a rdfs:subClassOf [[#reg-model|Registration]]
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>registeredBy</td>
      <td>Agent</td>
      <td>[=Agent=] that registered the [=Remote Data Registration=]</td>
    </tr>
    <tr>
      <td>registeredWith</td>
      <td>Application</td>
      <td>[=Application=] used to create the [=Remote Data Registration=]</td>
    </tr>
    <tr>
      <td>registeredAt</td>
      <td>xsd:dateTime</td>
      <td>Date and time the [=Remote Data Registration=] was created</td>
    </tr>
    <tr>
      <td>updatedAt</td>
      <td>xsd:dateTime</td>
      <td>Date and time the [=Remote Data Registration=] was updated</td>
    </tr>
    <tr>
      <td>hasRegistration</td>
      <td>Data Registration</td>
      <td>Link to the [=Data Registration=] that was shared</td>
    </tr>
    <tr>
      <td>registeredShapeTree</td>
      <td>st:ShapeTree</td>
      <td>Shape tree associated with the shared [=Data Registration=]</td>
    </tr>
    <tr>
      <td>scopeOfDataGrant</td>
      <td> eco:AllInstances, eco:InheritInstances,
      eco:SelectedInstances, eco:NoAccess</td>
      <td>Identifies the scope of access that was granted
        <ul>
          <li>eco:AllInstances - Scope includes
              access to all [=Registered Data Instances=] of the shared
              [=Data Registration=]</li>
          <li>eco:InheritInstances - Scope includes
              access to [=Registered Data Instances=] inherited by
              instances selected in the [=Data Receipt=] linked via
              eco:inheritsFrom</li>
          <li>eco:SelectedInstances - Scope includes
              access only to those [=Registered Data Instances=] specifically
              selected by the [=Agent=]</li>
          <li>eco:NoAccess - No access is granted</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>accessMode</td>
      <td>acl:Read, acl:Write, acl:Control, acl:Append</td>
      <td>Access modes granted on the shared [=Data Registration=]</td>
    </tr>
    <tr>
      <td>hasRemoteDataInstance</td>
      <td>[Remote Data Instance](#classRemoteDataInstance)</td>
      <td>Link to [=Remote Data Instance=] associated with the
      [=Remote Data Registration=]</td>
    </tr>
    <tr>
      <td>hasAccessReceipt</td>
      <td>[AccessReceipt](#classAccessReceipt)</td>
      <td>Link to [=Access Receipt=] that granted this shared access</td>
    </tr>
  </tbody>
</table>

The [RemoteDataRegistrationShape](#shexRemoteDataRegistration) is used to
validate an instance of the
[RemoteDataRegistration](#classRemoteDataRegistration) class.

<pre highlight="turtle" id="shexRemoteDataRegistration">
<#RemoteDataRegistration> {
  a [eco:RemoteDataRegistration] ;
  eco:registeredBy IRI ;
  eco:registeredWith IRI ;
  eco:registeredAt xsd:dateTime ;
  eco:updatedAt xsd:dateTime ;
  eco:hasRegistration IRI ;           # Remote data registration
  eco:registeredShapeTree IRI ;       # Associated shape tree
  eco:scopeOfDataGrant [ eco:SelectedInstances
                         eco:AllInstances
                         eco:InheritInstances
                         eco:NoAccess ]+ ;
  eco:accessMode [ acl:Read acl:Write acl:Append acl:Control ]+ ;
  eco:hasRemoteDataInstance IRI* ;    # if specific instances are selected or inherited
  eco:hasAccessReceipt IRI+ ;         # Associated access receipts
}
</pre>

The [RemoteDataRegistrationTree](ecosystem.tree#remote-data-registration-tree)
is assigned to a resource via the
[RemoteDataRegistryTree](#treeRemoteDataRegistry), and ensures
that the assigned resource will validate against the
[RemoteDataRegistrationShape](#shexRemoteDataRegistration).

<pre highlight="turtle" id="treeRemoteDataRegistration">
<#remote-data-registration-tree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeResource ;
  st:validatedBy &lt;ecos#RemoteDataRegistrationShape&gt; ;
  st:matchesUriTemplate "{id}" ;
  st:contains <#remote-data-instance-tree> ,
              st:AllowNone .
</pre>

### Remote Data Instance ### {#datamodel-remote-data-instance}

An [=Agent=] maintains a <dfn>Remote Data Instance</dfn> to represent
a [=Registered Data Instance=] that another [=Agent=] has shared with them.

A [=Remote Data Instance=] is created when an [=Agent=] receives an
[=Access Receipt=] from another [=Agent=] that includes access to a specific
[=Registered Data Instance=].

* A [=Remote Data Instance=] MUST be associated with an [=Access Receipt=]
* If an [=Access Receipt=] is received that changes the access to a shared
    [=Registered Data Instance=], the corresponding [=Remote Data Instance=]
    MUST be updated, and removed altogether if that access is removed.

<table class="classinfo data" align="left" id="classRemoteDataInstance">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [RemoteDataInstance](ecosystem.ttl#RemoteDataInstance)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>registeredAt</td>
      <td>xsd:dateTime</td>
      <td>When the [=Remote Data Instance=] was created</td>
    </tr>
    <tr>
      <td>updatedAt</td>
      <td>xsd:dateTime</td>
      <td>When the [=Remote Data Instance=] was last updated</td>
    </tr>
    <tr>
      <td>hasRegisteredDataInstance</td>
      <td>RegisteredDataInstance</td>
      <td>Link to [=Registered Data Instance=] associated with the
      [=Remote Data Instance=]</td>
    </tr>
    <tr>
      <td>registeredShapeTree</td>
      <td>st:ShapeTree</td>
      <td>Shape tree associated with the shared [=Registered Data Instance=]</td>
    </tr>
    <tr>
      <td>accessMode</td>
      <td>acl:Read, acl:Write, acl:Control, acl:Append</td>
      <td>Access modes granted on the shared [=Registered Data Instance=]</td>
    </tr>
    <tr>
      <td>hasAccessReceipt</td>
      <td>[AccessReceipt](#classAccessReceipt)</td>
      <td>Link to [=Access Receipt=] that granted this shared access</td>
    </tr>
  </tbody>
</table>

The [RemoteDataInstanceShape](#shexRemoteDataInstance) is used to
validate an instance of the
[RemoteDataInstance](#classRemoteDataInstance) class.

<pre highlight="turtle" id="shexRemoteDataInstance">
<#RemoteDataInstance> {
  a [eco:RemoteDataInstance] ;
  eco:hasRegisteredDataInstance IRI ; # Remote registered data instance
  eco:registeredAt xsd:dateTime ;
  eco:registeredShapeTree IRI ;       # Associated shape tree
  eco:accessMode [ acl:Read acl:Write acl:Append acl:Control ]+ ;
  eco:hasAccessReceipt IRI+ ;         # Associated access receipts
}
</pre>

The [RemoteDataInstanceTree](ecosystem.tree#remote-data-instance-tree)
is assigned to a resource via the
[RemoteDataInstanceTree](#treeRemoteDataInstance), and ensures
that the assigned resource will validate against the
[RemoteDataInstanceShape](#shexRemoteDataInstance).

<pre highlight="turtle" id="treeRemoteDataInstance">
<#remote-data-instance-tree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeResource ;
  st:validatedBy &lt;ecos#RemoteDataInstanceShape&gt; ;
  st:matchesUriTemplate "{id}" .
</pre>

## Resource Hierarchy ## {#remote-hierarchy}

<table class="data tree" align="left">
  <col>
  <col>
  <col>
  <col>
  <thead>
    <tr>
      <th>Resource</th>
      <th>Class</th>
      <th>Shape</th>
      <th>Shape Tree</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`/registries/#registrar`</td>
      <td>[Registrar](#)</td>
      <td>[RegistrarShape](#)</td>
      <td>[RegistrarTree](#)</td>
    </tr>
    <tr>
      <td>`-- remote#set`</td>
      <td>[RemoteDataRegistrySet](#classRemoteDataRegistrySet)</td>
      <td>[RemoteDataRegistrySetShape](#shexRemoteDataRegistrySet)</td>
      <td>[RemoteDataRegistrySetTree](#treeRemoteDataRegistrySet)</td>
    </tr>
    <tr>
      <td>`/remote/#registry`</td>
      <td>[RemoteDataRegistry](#classRemoteDataRegistry)</td>
      <td>[RemoteDataRegistryShape](#shexRemoteDataRegistry)</td>
      <td>[RemoteDataRegistryTree](#treeRemoteDataRegistry)</td>
    </tr>
    <tr>
      <td>`-- f0ebbd29...b4/#registration`</td>
      <td>[RemoteData](#classRemoteDataRegistration)</td>
      <td>[RemoteDataRegistrationShape](#shexRemoteDataRegistration)</td>
      <td>[RemoteDataRegistrationTree](#treeRemoteDataRegistration)</td>
    </tr>
    <tr>
      <td>`---- cd04e76b...02#instance`</td>
      <td>[RemoteDataInstance](#classRemoteDataInstance)</td>
      <td>[RemoteDataInstanceShape](#shexRemoteDataInstance)</td>
      <td>[RemoteDataInstanceTree](#treeRemoteDataInstance)</td>
    </tr>
    <tr>
      <td>`---- 9506b58f...eb#instance`</td>
      <td>[RemoteDataInstance](#classRemoteDataInstance)</td>
      <td>[RemoteDataInstanceShape](#shexRemoteDataInstance)</td>
      <td>[RemoteDataInstanceTree](#treeRemoteDataInstance)</td>
    </tr>
  </tbody>
</table>

The [=Remote Data Registry Set=] and the [=Remote Data Registry=]
<em class="rfc2119">MAY</em> or <em class="rfc2119">MAY NOT</em>
be on the same [=pod=].

[=Remote Data Registry Set=] and [=Remote Data Registry=] resources
<em class="rfc2119">MAY</em> use any resource or subject names.

[=Remote Data Registrations=] and [=Remote Data Instances=]
<em class="rfc2119">MUST</em> use \[UUIDs](https://www.ietf.org/rfc/rfc4122.txt)
for resource names.

## Operations ## {#remote-operations}

### Update Remote Data ### {#remote-update}

#### Inputs #### {#updateremote-inputs}

* Let `RECEIPT` be an [=Access Receipt=]

#### Outputs #### {#updateremote-outputs}

* Let `RECEIPT` be an [=Access Receipt=] updated with remote data associations

#### Operation Details #### {#updateremote-outputs}

TODO


Trusted Agents {#trusted}
=====================

## Overview ## {#trusted-overview}

A [=trusted Agent=] is an application that a [=Agent=] trusts
to perform actions for them with elevated privilege. They can be
trusted to help a [=Agent=] to make smart decisions related to
their data.

There's no limit to what a trusted agent can
assist with, but [[#appreg|registering applications]] and authorizing access to
data are two critical operations covered in this proposal.

A trusted [=application registration agent=] helps the [=Agent=]
make smart decisions about the applications they choose to utilize, and
ensure they get provisioned appropriately.

A trusted agent for data authorization is needed in cases where the resource
controller wishes to grant limited access to data in her Pod to another
[=authenticated agent=] or [=user-piloted application=], but needs
assistance to determine what access is needed, and help to provision
that access.

There are three typical patterns to interact with a trusted agent;
*Embedded*, *Synchronous*, and *Asynchronous*.

The **Embedded pattern** is employed when the application in question has full
control privileges, and the trusted agent capabilities can
be executed directly. An example of an application that could fall into
this category would be a Pod management application installed by default
by the user’s Pod provider.

The **Synchronous pattern** utilizes a web-based redirect flow much like an
OAuth2 grant flow. The user is redirected to the trusted agent URL, with
a callback parameter provided as part of the request. When the
trusted agent is finished, it sends the user back to the provided
callback URL. This is an excellent pattern for application registration
and data authorization.

The **Asynchronous pattern** utilizes an event based model, where a message is
sent to the Trusted Agent through some mechanism (direct, pubsub, etc).
This flow is most typical for server-side/bot applications or any piloted
clients that can make use of asynchronous notification processing.

A given trusted agent may employ one or more of these patterns.

## Data Model ## {#trusted-datamodel}

### Summary ### {#trusted-datamodel-summary}

## Resource Hierarchy ## {#trusted-hierarchy}

## Operations ## {#trusted-operations}

### Load Trusted Agent ### {#trusted-load}

### Redirect to Trusted Agent ### {#trusted-redirect}

### Return from Trusted Agent ### {#trusted-return}

Client Identification {#client}
=====================

Throughout this proposal, we see cases where Alice compartmentalizes access
to her data based on who or what is access it - the [=authenticated agent=].
In certain cases, we also limit access based on the application in use
by Alice - the
[=user-piloted application=].

We utilize a new optional predicate in an [=acl resource=] statement to
restrict access to permitted [=user-piloted applications=], identified by their
[=ApplicationIDs=].

Limiting access to data based on
the [=user-piloted application=] in use is only reliable in certain
instances when the [=application=] can be identified with confidence.

## Identifying client applications ## {#client-id}

For identification purposes, client [=applications=] in use across the world
today fall into two buckets; *strongly identifiable* and *weakly identifiable*.

**Strongly identifiable clients** can be identified by 3rd parties independently
from their user/controller. Only [=server-side applications=] are
strongly identifiable. As confidential clients, they can keep secrets
and can present attestations and third-party credentials
via DNS / domain certificates.

**Weakly identifiable clients** include in-browser JS apps and native desktop
or mobile applications. They are considered weakly identifiable because they
are not able to keep secrets on an instance level. They are often referred to
as public clients. Native apps should be strongly-identifiable in theory
(since they are able to keep secrets on an instance level), but not in
practice because the OS manufacturers do not make their trust
infrastructure available. **Weakly identifiable clients are only strongly
identifiable to the user controlling them**.

## Limiting access by client application ## {#client-limit}

In the case of a strongly identifiable [=server-side application=],
the [=authenticated agent=] and the client application are the same. The client
application has its own [=identity=] that can be strongly authenticated. Alice
chooses which data that client application's identity can access, in the same
way that she chooses which data Bob can access.

In the case of [=user-piloted applications=], the ability for a Solid pod to
limit access to data by the client application in use is only as strong as
the trustworthiness of the user piloting that application, and their ability
to avoid using malicious applications. The [=ApplicationID=] can be manipulated
by the user in control of the app. This means that Alice can strongly control
the applications that she uses to compartmentalize her own data, but has
limited ability to control the applications that Bob uses to access the data
she shares with him.

Definitions {#definitions}
=====================

<b>All definitions as stated below should be considered in the context of
an interoperable [=ecosystem=] for [=Solid=], whether explicitly stated
or not.</b>

<dfn>Solid</dfn> is a protocol made up of a number of open web standards
aimed at decentralizing data on the web.

A Solid <dfn>pod</dfn> is a place for storing and accessing data via
the [=Solid=] protocol, with mechanisms for controlling who or what can
access that data.

An interoperable <dfn>ecosystem</dfn> is
a collection of [=Solid=] compatible [=applications=] developed by one or more
entities, used by a community of users, that can safely access and manipulate
the same kinds of data in [=pods=].

An <dfn>Agent</dfn> is a distinct individual, group, organization, or piece
of software with an identity that can be strongly authenticated. Represented
by the [eco:Agent](ecosystem.ttl#Agent) class. Validated by the
[ecos:AgentShape](ecosystem.shex#AgentShape). Associated with resources by the
[ecot:agent-tree](ecosystem.tree#agent-tree). A given [=Agent=] is considered
the [=resource controller=] for any [=registrations=] in their [=registries=].

An <dfn>Application</dfn> is a piece of software that interfaces with a
Solid pod, either as a [=server-side application=], or as a
[=user-piloted application=]. Represented by the
[eco:Application](ecosystem.ttl#Application) class. Validated by the
[ecos:ApplicationShape](ecosystem.shex#ApplicationShape).

A <dfn>server-side application</dfn> runs on a dedicated server. They may
also act as autonomous [=authenticated agents=].

A <dfn>user-piloted application</dfn> runs on a user's device, with the user
as the [=authenticated agent=]. They include in-browser javascript
applications, native desktop applications, and mobile applications.

An <dfn>identity</dfn> in Solid is a unique URI that can be dereferenced to
return an [=identity profile document=]. Compatible identity systems
include [=WebID=] and [=DID=].

An <dfn>identity profile document</dfn> is a linked data document obtained
by dereferencing the URI for a given [=identity=]. It provides information
that can be used to prove that a given [=agent=] controls the document.

An <dfn>authenticated agent</dfn> is an [=agent=] that has strongly
authenticated their [=identity=] by proving control of the
[=identity profile document=] via an authentication protocol such as
[[WEBID-OIDC]].

A <dfn>WebID</dfn> is a web resource at an HTTP URI which refers to an
[=agent=]. An [=identity profile document=] can be accessed by
dereferencing the WebID. [[WEBID]]

A <dfn>DID</dfn> is a URI that associates a DID subject (e.g. an [=agent=],
thing, data model, abstract entity, etc.) with a DID document,
equivalent to an [=identity profile document=], to allow trustable
interactions with that subject. [[DID]]

An <dfn>identity provider</dfn> furnishes an [=agent=] with authenticated
credentials that prove agent is who it says it is, across the web.

A <dfn>token</dfn> is used to make authenticated requests to the [=Solid=]
server for a given [=authenticated agent=].

An <dfn>ApplicationID</dfn> is a web resource at an HTTP URI uniquely associated
with a given [=application=]. For [=server-side applications=], it may also
serve as an [=identity=]. An [=application profile document=] can be
accessed by dereferencing the ApplicationID.

An <dfn>application profile document</dfn> is a linked data document
obtained by dereferencing the URI for a given [=ApplicationID=]. It contains
useful information about an application that can be employed in
various workflows including application registration and data authorization.

A <dfn>resource controller</dfn> is an [=authenticated agent=] with full
privileges and control over a given resource or set of resources.

An <dfn>acl resource</dfn> as defined by [[WAC]] may be directly
associated with a resource or indirectly associated with a resource
through inheritance. It determines which [=authorization subjects=] can
access a resource, and the modes of access they have for it.

An <dfn>access mode</dfn> denotes operations (e.g. read, write)
that a given [=authorization subject=] can perform on a resource.

An <dfn>authorization subject</dfn> is the target of a given authorization
statement in an [=acl resource=]. It is either an [=Agent=] (individual,
group, [=server-side application=]), a
[=User-Piloted Application=] in use by *any* [=Agent=], or a combination of
a specific [=Agent=] using a specific [=User-Piloted Application=].

An <dfn>authorization statement</dfn> is ...

A <dfn>trusted agent</dfn> is any [=application=] that a
[=Agent=] trusts to perform actions for them. These
actions typically require some leve

An <dfn>application registration agent</dfn> is a type of [=trusted agent=]
that an [=Agent=] uses to register and manage applications that
interface with their [=pod=].

A <dfn>data authorization agent</dfn> is a type of [=trusted agent=]
that assists a [=Agent=] with the managing the data
in their [=Data Registries=], and authorizing access to it from other
[=authorization subjects=].

A <dfn>shape</dfn> provides a schema that RDF data graphs must meet in order
to be considered conformant. A shape associated with a given resource in a
[=pod=] ensures that any data stored in that resource must conform to the
associated shape. Shape languages include [[SHEX]] and [[SHACL]].

A <dfn>shape tree</dfn> defines a prospective tree of related resources
which can be read and written by applications. The shape tree associates
each of these resources with a shape. This allows one to treat a set of
related resources as a single grouping, and apply that to a range of
operations including access control, data organization, data validation,
and data migration. [[SHAPETREES]]

A <dfn>Registrar</dfn> for a given [=Agent=] provides [=Registries=],
organized in [=Registry Sets=]. Represented by the
[eco:Registrar](ecosystem.ttl#Registrar) class. Validated by the
[ecos:RegistrarShape](ecosystem.shex#RegistrarShape). Associated with
resources by the
[ecot:registrar-shape-tree](ecosystem.tree#registrar-shape-tree).

A <dfn>Registry Set</dfn> is a collection of one or more registries of a
specific type, including [=Application Registries=], Data Registries,
Access Registries, and Remote Registries. Represented by the
[eco:RegistrySet](ecosystem.ttl#RegistrySet) class.

A <dfn>Registry</dfn> is a collection of [=Registrations=] stored in a
specific location in a [=pod=]. It provides a place where an [=Agent=]
can register, store, and lookup essential data needed to participate in
the [=ecosystem=]. Represented by the
[eco:Registry](ecosystem.ttl#Registry) class.

A <dfn>Registration</dfn> is the basic data unit of any [=Registry=].

An <dfn>Application Registry Set</dfn> is a [=Registry Set=] specifically
made up of [=Application Registries=]. Represented by the
[eco:ApplicationRegistrySet](ecosystem.ttl#ApplicationRegistySet) class.
Validated by the
[ecos:ApplicationRegistrySetShape](ecosystem.shex#RegistrySetShape).
Associated with resources by the
[ecot:application-registry-set-tree](ecosystem.tree#application-registry-set-tree).

An <dfn>Application Registry</dfn> is a collection of
[=Application Registrations=] stored in a specific location in a [=pod=].
Represented by the
[eco:ApplicationRegistry](ecosystem.ttl#ApplicationRegistry) class.
Validated by the
[ecos:ApplicationRegistryShape](ecosystem.shex#ApplicationRegistryShape).
Associated with resources by the
[ecot:application-registry-tree](ecosystem.tree#application-registry-tree).

An <dfn>Application Registration</dfn> provides the [=Agent=]
with a place to maintain metadata, state, preferences, and
other application-specific data associated with a given [=Application=] they
have elected to use. Represented by the
[eco:ApplicationRegistration](ecosystem.ttl#ApplicationRegistration) class.
Validated by the
[ecos:ApplicationRegistrationShape](ecosystem.shex#ApplicationRegistrationShape).
Associated with resources by the
[ecot:application-registration-tree](ecosystem.tree#application-registration-tree).

A <dfn>Data Registry Set</dfn> is a [=Registry Set=] specifically made up of
[=Data Registries=]. Represented by the
[eco:DataRegistrySet](ecosystem.ttl#DataRegistrySet) class.
Validated by the
[ecos:DataRegistrySetShape](ecosystem.shex#DataRegistrySetShape).
Associated with resources by the
[ecot:data-registry-set-tree](ecosystem.tree#data-registry-set-tree).

A <dfn>Data Registry</dfn> is a collection of [=Data Registrations=], each
representing a unique type of data, stored in a specific location in a
Solid [=pod=]. Represented by the
[eco:DataRegistry](ecosystem.ttl#DataRegistry) class.
Validated by the
[ecos:DataRegistryShape](ecosystem.shex#DataRegistryShape).
Associated with resources through the
[ecot:data-registry-tree](ecosystem.tree#data-registry-tree).

A <dfn>Data Registration</dfn> provides the [=Agent=] with a place to store
[=Registered Data Instances=] of a particular type, conforming to a
given [=shape tree=]. Represented by the
[eco:DataRegistration](ecosystem.ttl#DataRegistration) class.
Validated by the
[ecos:DataRegistrationShape](ecosystem.shex#DataRegistrationShape).
Associated with resources through the
[ecot:data-registration-tree](ecosystem.tree#data-registration-tree).

A <dfn>Registered Data Instance</dfn> is a unique, stored instance of a
particular type of data conforming to a given [=shape tree=]. Each registered
data instance is contained within a given [=Data Registration=].

<pre class="biblio">
{
  "problems-and-goals": {
    "href": "https://github.com/solid/data-interoperability-panel/blob/master/problems-and-goals.md",
    "title": "Problems and Goals for Interoperability, Collaboration, and Security in a Solid Pod",
    "authors": [
      "Justin Bingham",
      "Eric Prud'hommeaux",
      "Jamie Fiedler",
      "Josh Collins"
    ]
  },
  "shapetrees": {
    "href": "https://shapetrees.github.io/specification/primer",
    "title": "Shape Trees",
    "authors": [
      "Justin Bingham",
      "Eric Prud'hommeaux",
      "Jamie Fiedler",
      "Josh Collins"
    ]
  },
  "wac": {
    "href": "https://solid.github.io/specification/wac/",
    "title": "Web Access Control"
  },
  "webid": {
    "href": "https://www.w3.org/2005/Incubator/webid/spec/identity/",
    "title": "WebID 1.0",
    "authors": [
      "Tim Berners-Lee",
      "Henry Story",
      "Andrei Sambra"
    ]
  },
  "did": {
    "href": "https://www.w3.org/TR/did-core/",
    "title": "Decentralized Identifiers (DIDs) v1.0",
    "authors": [
      "Drummond Reed",
      "Manu Sporney",
      "Dave Longley",
      "Christopher Allen",
      "Ryan Grant",
      "Markus Sabadello"
    ]
  },
  "shex": {
    "href": "http://shex.io/shex-semantics/index.html",
    "title": "Shape Expressions Language 2.1",
    "authors": [
      "Eric Prud'hommeaux",
      "Iovka Boneva",
      "Jose Emilio Labra Gayo",
      "Gregg Kellogg"
    ]
  },
  "shacl": {
    "href": "https://www.w3.org/TR/shacl/",
    "title": "Shapes Constraint Language (SHACL)",
    "authors": [
      "Holger Knublauch",
      "Dimitris Kontokostas"
    ]
  },
  "webid-oidc": {
    "href": "https://github.com/solid/webid-oidc-spec",
    "title": "WebID-OIDC Authentication Specification",
    "authors": [
      "Dmitri Zagidulin"
    ]
  }
}
</pre>
